; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Simon\Documents\GitHub\Sparta2.0\UCLAN-sparta\Scene.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?VT@?$CVarTypeInfo@PA_J@ATL@@2GB		; ATL::CVarTypeInfo<__int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ ; ATL::CVarTypeInfo<__int64 *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@_K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned __int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64>::pmField
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?MAX_VALUE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_VALUE
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PA_K@ATL@@2GB		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@M@ATL@@2GB			; ATL::CVarTypeInfo<float>::VT
PUBLIC	?value@?$integral_constant@I$07@std@@2IB	; std::integral_constant<unsigned int,8>::value
PUBLIC	?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ ; ATL::CVarTypeInfo<float>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAM@ATL@@2GB			; ATL::CVarTypeInfo<float *>::VT
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ ; ATL::CVarTypeInfo<float *>::pmField
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?cbNeverDelete@CRegParser@ATL@@1HB		; ATL::CRegParser::cbNeverDelete
PUBLIC	?MAX_TYPE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_TYPE
PUBLIC	?VT@?$CVarTypeInfo@N@ATL@@2GB			; ATL::CVarTypeInfo<double>::VT
PUBLIC	?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ ; ATL::CVarTypeInfo<double>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAN@ATL@@2GB			; ATL::CVarTypeInfo<double *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ ; ATL::CVarTypeInfo<double *>::pmField
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB	; ATL::CVarTypeInfo<tagVARIANT *>::VT
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t *>::VT
PUBLIC	?value@?$integral_constant@I$03@std@@2IB	; std::integral_constant<unsigned int,4>::value
PUBLIC	?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ ; ATL::CVarTypeInfo<wchar_t *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ ; ATL::CVarTypeInfo<wchar_t * *>::pmField
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown *>::pmField
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown * *>::VT
PUBLIC	?_Min@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Min
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown * *>::pmField
PUBLIC	?m_nLevel@CTrace@ATL@@1IA			; ATL::CTrace::m_nLevel
PUBLIC	?_Max@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Max
PUBLIC	?m_nCategory@CTrace@ATL@@1IA			; ATL::CTrace::m_nCategory
PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
PUBLIC	?_Min@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Min
PUBLIC	?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch *>::pmField
PUBLIC	?_Max@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Max
PUBLIC	__GUID_00000000_0000_0000_c000_000000000046
PUBLIC	?value@?$integral_constant@I$01@std@@2IB	; std::integral_constant<unsigned int,2>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?_Min@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Min
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch * *>::VT
PUBLIC	?_Max@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Max
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch * *>::pmField
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?_Min@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Min
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY>::VT
PUBLIC	?_Max@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Max
PUBLIC	?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY>::pmField
PUBLIC	__GUID_00020400_0000_0000_c000_000000000046
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	?_Min@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Min
PUBLIC	?_Max@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Max
PUBLIC	?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY *>::pmField
PUBLIC	?_Min@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Min
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?_Max@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Max
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?value@?$integral_constant@I$00@std@@2IB	; std::integral_constant<unsigned int,1>::value
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?value@?$_Maximum@$S@std@@2IB			; std::_Maximum<>::value
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	__GUID_00000146_0000_0000_c000_000000000046
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?MAX_VERTEX_ELTS@CModel@@0HB			; CModel::MAX_VERTEX_ELTS
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?mViewportWidth@CScene@@0HA			; CScene::mViewportWidth
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?mViewportHeight@CScene@@0HA			; CScene::mViewportHeight
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?MAX_LIGHTS@CScene@@0HB				; CScene::MAX_LIGHTS
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?MAX_SHADER_LIGHTS@CScene@@0HB			; CScene::MAX_SHADER_LIGHTS
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?MAX_OBJECTS@CScene@@0HB			; CScene::MAX_OBJECTS
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	__GUID_b196b284_bab4_101a_b69c_00aa00341d07
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?g_XMSinCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMSinCoefficients0
PUBLIC	?g_XMSinCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMSinCoefficients1
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?g_XMCosCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMCosCoefficients0
PUBLIC	?g_XMCosCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMCosCoefficients1
PUBLIC	?g_XMTanCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMTanCoefficients0
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?g_XMTanCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMTanCoefficients1
PUBLIC	?g_XMTanCoefficients2@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMTanCoefficients2
PUBLIC	?g_XMArcCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMArcCoefficients0
PUBLIC	_LIBID_ATLLib
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?g_XMArcCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMArcCoefficients1
PUBLIC	?g_XMATanCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMATanCoefficients0
PUBLIC	?g_XMATanCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMATanCoefficients1
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?g_XMATanEstCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMATanEstCoefficients0
PUBLIC	?g_XMATanEstCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMATanEstCoefficients1
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?g_XMArcEstCoefficients@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMArcEstCoefficients
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?g_XMIdentityR0@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMIdentityR0
PUBLIC	?g_XMIdentityR1@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMIdentityR1
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?g_XMIdentityR2@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMIdentityR2
PUBLIC	?g_XMIdentityR3@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMIdentityR3
PUBLIC	?g_XMNegIdentityR0@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegIdentityR0
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?g_XMNegIdentityR1@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegIdentityR1
PUBLIC	?g_XMNegIdentityR2@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegIdentityR2
PUBLIC	?g_XMNegIdentityR3@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegIdentityR3
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?g_XMNegativeZero@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMNegativeZero
PUBLIC	?g_XMNegate3@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMNegate3
PUBLIC	?g_XMMask3@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMMask3
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?g_XMMaskX@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMMaskX
PUBLIC	?g_XMMaskY@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMMaskY
PUBLIC	?g_XMMaskZ@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMMaskZ
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA ; ATL::CNoUIAssertHook::s_pfnPrevHook
PUBLIC	?g_XMMaskW@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMMaskW
PUBLIC	?g_XMOne@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMOne
PUBLIC	?g_XMOne3@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMOne3
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?g_XMZero@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMZero
PUBLIC	?g_XMTwo@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMTwo
PUBLIC	?g_XMFour@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMFour
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?g_XMSix@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMSix
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?g_XMNegativeOne@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegativeOne
PUBLIC	?g_XMOneHalf@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMOneHalf
PUBLIC	?g_XMNegativeOneHalf@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegativeOneHalf
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?g_XMEpsilon@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMEpsilon
PUBLIC	?g_XMInfinity@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMInfinity
PUBLIC	?g_XMQNaN@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMQNaN
PUBLIC	?g_XMQNaNTest@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMQNaNTest
PUBLIC	?g_XMAbsMask@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMAbsMask
PUBLIC	?g_XMFltMin@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFltMin
PUBLIC	?g_XMFltMax@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFltMax
PUBLIC	?g_XMNegOneMask@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMNegOneMask
PUBLIC	?g_XMMaskA8R8G8B8@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMaskA8R8G8B8
PUBLIC	?g_XMFlipA8R8G8B8@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMFlipA8R8G8B8
PUBLIC	?g_XMFixAA8R8G8B8@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixAA8R8G8B8
PUBLIC	?g_XMNormalizeA8R8G8B8@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMNormalizeA8R8G8B8
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?g_XMMaskA2B10G10R10@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMaskA2B10G10R10
PUBLIC	?g_XMFlipA2B10G10R10@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMFlipA2B10G10R10
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?g_XMFixAA2B10G10R10@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixAA2B10G10R10
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?g_XMNormalizeA2B10G10R10@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMNormalizeA2B10G10R10
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?g_XMMaskX16Y16@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMaskX16Y16
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?g_XMFlipX16Y16@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMFlipX16Y16
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?g_XMFixX16Y16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixX16Y16
PUBLIC	?g_XMNormalizeX16Y16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNormalizeX16Y16
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?g_XMMaskX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B ; DirectX::g_XMMaskX16Y16Z16W16
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?g_XMFlipX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B ; DirectX::g_XMFlipX16Y16Z16W16
PUBLIC	?g_XMFixX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixX16Y16Z16W16
PUBLIC	?g_XMNormalizeX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMNormalizeX16Y16Z16W16
PUBLIC	?g_XMNoFraction@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNoFraction
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?g_XMMaskByte@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMaskByte
PUBLIC	?g_XMNegateX@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMNegateX
PUBLIC	?g_XMNegateY@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMNegateY
PUBLIC	?g_XMNegateZ@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMNegateZ
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?g_XMNegateW@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMNegateW
PUBLIC	___pobjMapEntryFirst
PUBLIC	?g_XMSelect0101@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMSelect0101
PUBLIC	___pobjMapEntryLast
PUBLIC	?g_XMSelect1010@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMSelect1010
PUBLIC	?g_XMOneHalfMinusEpsilon@DirectX@@3UXMVECTORI32@1@B ; DirectX::g_XMOneHalfMinusEpsilon
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?g_XMSelect1000@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMSelect1000
PUBLIC	?g_XMSelect1100@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMSelect1100
PUBLIC	?g_XMSelect1110@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMSelect1110
PUBLIC	?g_XMSelect1011@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMSelect1011
PUBLIC	?g_XMFixupY16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixupY16
PUBLIC	?g_XMFixupY16W16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixupY16W16
PUBLIC	?g_XMFlipY@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFlipY
PUBLIC	?g_XMFlipZ@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFlipZ
PUBLIC	?g_XMFlipW@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFlipW
PUBLIC	?g_XMFlipYZ@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFlipYZ
PUBLIC	?g_XMFlipZW@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFlipZW
PUBLIC	?g_XMFlipYW@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFlipYW
PUBLIC	?g_XMMaskDec4@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMaskDec4
PUBLIC	?g_XMXorDec4@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMXorDec4
PUBLIC	?g_XMAddUDec4@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMAddUDec4
PUBLIC	?g_XMAddDec4@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMAddDec4
PUBLIC	?g_XMMulDec4@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMMulDec4
PUBLIC	?g_XMMaskByte4@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMaskByte4
PUBLIC	?g_XMXorByte4@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMXorByte4
PUBLIC	?g_XMAddByte4@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMAddByte4
PUBLIC	?g_XMFixUnsigned@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixUnsigned
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?g_XMMaxInt@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMMaxInt
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?g_XMMaxUInt@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMMaxUInt
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?g_XMUnsignedFix@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMUnsignedFix
PUBLIC	?g_XMsrgbScale@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMsrgbScale
PUBLIC	?g_XMsrgbA@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMsrgbA
PUBLIC	?g_XMsrgbA1@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMsrgbA1
PUBLIC	?g_XMExponentBias@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMExponentBias
PUBLIC	?g_XMSubnormalExponent@DirectX@@3UXMVECTORI32@1@B ; DirectX::g_XMSubnormalExponent
PUBLIC	?g_XMNumTrailing@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMNumTrailing
PUBLIC	?g_XMMinNormal@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMinNormal
PUBLIC	??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	?g_XMNegInfinity@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMNegInfinity
PUBLIC	??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	?g_XMNegQNaN@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMNegQNaN
PUBLIC	??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	?g_XMBin128@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMBin128
PUBLIC	??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?g_XMBinNeg150@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMBinNeg150
PUBLIC	??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@	; `string'
PUBLIC	?g_XM253@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XM253
PUBLIC	??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@	; `string'
PUBLIC	?g_XMExpEst1@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst1
PUBLIC	??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ ; `string'
PUBLIC	?g_XMExpEst2@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst2
PUBLIC	??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ ; `string'
PUBLIC	?g_XMExpEst3@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst3
PUBLIC	??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?g_XMExpEst4@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst4
PUBLIC	??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ ; `string'
PUBLIC	?g_XMExpEst5@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst5
PUBLIC	?g_XMExpEst6@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst6
PUBLIC	?g_XMExpEst7@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst7
PUBLIC	?g_XMLogEst0@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst0
PUBLIC	?g_XMLogEst1@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst1
PUBLIC	?g_XMLogEst2@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst2
PUBLIC	?g_XMLogEst3@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst3
PUBLIC	?g_XMLogEst4@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst4
PUBLIC	?g_XMLogEst5@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst5
PUBLIC	?g_XMLogEst6@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst6
PUBLIC	?g_XMLogEst7@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst7
PUBLIC	?g_XMLgE@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLgE
PUBLIC	?g_XMInvLgE@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMInvLgE
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	__GUID_0002e012_0000_0000_c000_000000000046
PUBLIC	?AliceBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::AliceBlue
PUBLIC	?AntiqueWhite@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::AntiqueWhite
PUBLIC	?Aqua@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Aqua
PUBLIC	?Aquamarine@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Aquamarine
PUBLIC	?Azure@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Azure
PUBLIC	?Beige@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Beige
PUBLIC	?Bisque@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Bisque
PUBLIC	?Black@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Black
PUBLIC	?BlanchedAlmond@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::BlanchedAlmond
PUBLIC	?Blue@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Blue
PUBLIC	?BlueViolet@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::BlueViolet
PUBLIC	?Brown@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Brown
PUBLIC	?BurlyWood@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::BurlyWood
PUBLIC	?CadetBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::CadetBlue
PUBLIC	?Chartreuse@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Chartreuse
PUBLIC	?Chocolate@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Chocolate
PUBLIC	?Coral@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Coral
PUBLIC	?CornflowerBlue@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::CornflowerBlue
PUBLIC	?Cornsilk@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Cornsilk
PUBLIC	?Crimson@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Crimson
PUBLIC	?Cyan@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Cyan
PUBLIC	?DarkBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkBlue
PUBLIC	?DarkCyan@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkCyan
PUBLIC	?DarkGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkGoldenrod
PUBLIC	?DarkGray@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkGray
PUBLIC	?DarkGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkGreen
PUBLIC	?DarkKhaki@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkKhaki
PUBLIC	?DarkMagenta@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkMagenta
PUBLIC	?DarkOliveGreen@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkOliveGreen
PUBLIC	?DarkOrange@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkOrange
PUBLIC	?DarkOrchid@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkOrchid
PUBLIC	?DarkRed@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkRed
PUBLIC	?DarkSalmon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkSalmon
PUBLIC	?DarkSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkSeaGreen
PUBLIC	__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
PUBLIC	?DarkSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkSlateBlue
PUBLIC	?DarkSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkSlateGray
PUBLIC	?DarkTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkTurquoise
PUBLIC	?DarkViolet@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkViolet
PUBLIC	?DeepPink@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DeepPink
PUBLIC	?DeepSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DeepSkyBlue
PUBLIC	?DimGray@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DimGray
PUBLIC	?DodgerBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DodgerBlue
PUBLIC	?Firebrick@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Firebrick
PUBLIC	?FloralWhite@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::FloralWhite
PUBLIC	?ForestGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::ForestGreen
PUBLIC	?Fuchsia@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Fuchsia
PUBLIC	?Gainsboro@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Gainsboro
PUBLIC	?GhostWhite@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::GhostWhite
PUBLIC	?Gold@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Gold
PUBLIC	?Goldenrod@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Goldenrod
PUBLIC	?Gray@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Gray
PUBLIC	?Green@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Green
PUBLIC	?GreenYellow@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::GreenYellow
PUBLIC	?Honeydew@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Honeydew
PUBLIC	?HotPink@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::HotPink
PUBLIC	?IndianRed@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::IndianRed
PUBLIC	?Indigo@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Indigo
PUBLIC	?Ivory@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Ivory
PUBLIC	?Khaki@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Khaki
PUBLIC	?Lavender@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Lavender
PUBLIC	?LavenderBlush@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LavenderBlush
PUBLIC	?LawnGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LawnGreen
PUBLIC	?LemonChiffon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LemonChiffon
PUBLIC	?LightBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightBlue
PUBLIC	?LightCoral@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightCoral
PUBLIC	?LightCyan@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightCyan
PUBLIC	?LightGoldenrodYellow@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LightGoldenrodYellow
PUBLIC	?LightGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightGreen
PUBLIC	?LightGray@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightGray
PUBLIC	?LightPink@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightPink
PUBLIC	?LightSalmon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightSalmon
PUBLIC	?LightSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LightSeaGreen
PUBLIC	?LightSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightSkyBlue
PUBLIC	?LightSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LightSlateGray
PUBLIC	?LightSteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LightSteelBlue
PUBLIC	?LightYellow@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightYellow
PUBLIC	?Lime@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Lime
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?LimeGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LimeGreen
PUBLIC	?Linen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Linen
PUBLIC	?Magenta@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Magenta
PUBLIC	?Maroon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Maroon
PUBLIC	?MediumAquamarine@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumAquamarine
PUBLIC	?MediumBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MediumBlue
PUBLIC	?MediumOrchid@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MediumOrchid
PUBLIC	??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?MediumPurple@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MediumPurple
PUBLIC	?MediumSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumSeaGreen
PUBLIC	?MediumSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumSlateBlue
PUBLIC	?MediumSpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumSpringGreen
PUBLIC	?MediumTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumTurquoise
PUBLIC	?MediumVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumVioletRed
PUBLIC	?MidnightBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MidnightBlue
PUBLIC	?MintCream@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MintCream
PUBLIC	?MistyRose@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MistyRose
PUBLIC	?Moccasin@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Moccasin
PUBLIC	?NavajoWhite@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::NavajoWhite
PUBLIC	?Navy@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Navy
PUBLIC	?OldLace@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::OldLace
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?Olive@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Olive
PUBLIC	?OliveDrab@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::OliveDrab
PUBLIC	?Orange@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Orange
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?OrangeRed@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::OrangeRed
PUBLIC	?Orchid@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Orchid
PUBLIC	?PaleGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::PaleGoldenrod
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?PaleGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::PaleGreen
PUBLIC	?PaleTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::PaleTurquoise
PUBLIC	?PaleVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::PaleVioletRed
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?PapayaWhip@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::PapayaWhip
PUBLIC	?PeachPuff@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::PeachPuff
PUBLIC	?Peru@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Peru
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?Pink@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Pink
PUBLIC	?Plum@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Plum
PUBLIC	?PowderBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::PowderBlue
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?Purple@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Purple
PUBLIC	?Red@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Red
PUBLIC	??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?RosyBrown@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::RosyBrown
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?RoyalBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::RoyalBlue
PUBLIC	?SaddleBrown@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SaddleBrown
PUBLIC	?Salmon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Salmon
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?SandyBrown@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SandyBrown
PUBLIC	?SeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SeaGreen
PUBLIC	?SeaShell@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SeaShell
PUBLIC	__GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?Sienna@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Sienna
PUBLIC	?Silver@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Silver
PUBLIC	?SkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SkyBlue
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?SlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SlateBlue
PUBLIC	?SlateGray@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SlateGray
PUBLIC	?Snow@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Snow
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?SpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SpringGreen
PUBLIC	?SteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SteelBlue
PUBLIC	?Tan@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Tan
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?Teal@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Teal
PUBLIC	?Thistle@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Thistle
PUBLIC	?Tomato@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Tomato
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?Transparent@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Transparent
PUBLIC	?Turquoise@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Turquoise
PUBLIC	?Violet@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Violet
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?Wheat@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Wheat
PUBLIC	?White@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::White
PUBLIC	?WhiteSmoke@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::WhiteSmoke
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?Yellow@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Yellow
PUBLIC	?YellowGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::YellowGreen
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?VT@?$CVarTypeInfo@D@ATL@@2GB			; ATL::CVarTypeInfo<char>::VT
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ ; ATL::CVarTypeInfo<char>::pmField
PUBLIC	?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA	; ATL::CComApartment::ATL_CREATE_OBJECT
PUBLIC	?VT@?$CVarTypeInfo@E@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ ; ATL::CVarTypeInfo<unsigned char>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAD@ATL@@2GB			; ATL::CVarTypeInfo<char *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ ; ATL::CVarTypeInfo<char *>::pmField
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	??_C@_13HADIAKP@?$AAS?$AA?$AA@			; `string'
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	?VT@?$CVarTypeInfo@PAE@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char *>::VT
PUBLIC	??_C@_13LHMFKAAD@?$AAM?$AA?$AA@			; `string'
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ ; ATL::CVarTypeInfo<unsigned char *>::pmField
PUBLIC	_CLSID_Registrar
PUBLIC	??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@			; `string'
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	??_C@_13OPKGLAFF@?$AAB?$AA?$AA@			; `string'
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@	; `string'
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	?VT@?$CVarTypeInfo@F@ATL@@2GB			; ATL::CVarTypeInfo<short>::VT
PUBLIC	??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ ; ATL::CVarTypeInfo<short>::pmField
PUBLIC	__GUID_00000109_0000_0000_c000_000000000046
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?VT@?$CVarTypeInfo@PAF@ATL@@2GB			; ATL::CVarTypeInfo<short *>::VT
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ ; ATL::CVarTypeInfo<short *>::pmField
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	_IID_IRegistrar
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?VT@?$CVarTypeInfo@G@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short>::VT
PUBLIC	?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ ; ATL::CVarTypeInfo<unsigned short>::pmField
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?VT@?$CVarTypeInfo@PAG@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short *>::VT
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ ; ATL::CVarTypeInfo<unsigned short *>::pmField
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?VT@?$CVarTypeInfo@H@ATL@@2GB			; ATL::CVarTypeInfo<int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ ; ATL::CVarTypeInfo<int>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAH@ATL@@2GB			; ATL::CVarTypeInfo<int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ ; ATL::CVarTypeInfo<int *>::pmField
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?VT@?$CVarTypeInfo@I@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ ; ATL::CVarTypeInfo<unsigned int>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAI@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ ; ATL::CVarTypeInfo<unsigned int *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@J@ATL@@2GB			; ATL::CVarTypeInfo<long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ ; ATL::CVarTypeInfo<long>::pmField
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PAJ@ATL@@2GB			; ATL::CVarTypeInfo<long *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ ; ATL::CVarTypeInfo<long *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ ; ATL::CVarTypeInfo<unsigned long>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAK@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ ; ATL::CVarTypeInfo<unsigned long *>::pmField
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?VT@?$CVarTypeInfo@_J@ATL@@2GB			; ATL::CVarTypeInfo<__int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ ; ATL::CVarTypeInfo<__int64>::pmField
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?m_nLevel@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLevel@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLevel
_BSS	ENDS
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
_BSS	SEGMENT
?mViewportWidth@CScene@@0HA DD 01H DUP (?)		; CScene::mViewportWidth
?mViewportHeight@CScene@@0HA DD 01H DUP (?)		; CScene::mViewportHeight
_BSS	ENDS
;	COMDAT ?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA
_BSS	SEGMENT
?s_pfnPrevHook@CNoUIAssertHook@ATL@@0P6AHHPADPAH@ZA DD 01H DUP (?) ; ATL::CNoUIAssertHook::s_pfnPrevHook
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_BSS	SEGMENT
?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA DD 01H DUP (?) ; ATL::CComApartment::ATL_CREATE_OBJECT
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_J@ATL@@2GB DW 014H			; ATL::CVarTypeInfo<__int64>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAK@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAK@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@K@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned long>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ DD 08H ; ATL::CVarTypeInfo<long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAJ@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAJ@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<long *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ DD 08H ; ATL::CVarTypeInfo<long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@J@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<long>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAI@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAI@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned int *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@I@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@I@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned int>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ DD 08H ; ATL::CVarTypeInfo<int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAH@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAH@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<int *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ DD 08H ; ATL::CVarTypeInfo<int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@H@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@H@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<int>::VT
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short *>::pmField
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAG@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAG@ATL@@2GB DW 04012H		; ATL::CVarTypeInfo<unsigned short *>::VT
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@G@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@G@ATL@@2GB DW 012H			; ATL::CVarTypeInfo<unsigned short>::VT
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ DD 08H ; ATL::CVarTypeInfo<short *>::pmField
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAF@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAF@ATL@@2GB DW 04002H		; ATL::CVarTypeInfo<short *>::VT
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
CONST	SEGMENT
__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713 DD 07fd52380H
	DW	04e07H
	DW	0101bH
	DB	0aeH
	DB	02dH
	DB	08H
	DB	00H
	DB	02bH
	DB	02eH
	DB	0c7H
	DB	013H
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT __GUID_00000109_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000109_0000_0000_c000_000000000046 DD 0109H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ DD 08H ; ATL::CVarTypeInfo<short>::pmField
CONST	ENDS
;	COMDAT ??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ DB 'D', 00H, 'e', 00H
	DB	'l', 00H, 'e', 00H, 't', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@F@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@F@ATL@@2GB DW 02H			; ATL::CVarTypeInfo<short>::VT
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'N'
	DB	00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ DB 'V', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ??_C@_13OPKGLAFF@?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ DB 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ ; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ DB 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char *>::pmField
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ ; ATL::szDwordVal
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ??_C@_13LHMFKAAD@?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ DB 'M', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAE@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAE@ATL@@2GB DW 04011H		; ATL::CVarTypeInfo<unsigned char *>::VT
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ??_C@_13HADIAKP@?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_13HADIAKP@?$AAS?$AA?$AA@ DB 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:??_C@_13HADIAKP@?$AAS?$AA?$AA@ ; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ DD 08H ; ATL::CVarTypeInfo<char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAD@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAD@ATL@@2GB DW 04010H		; ATL::CVarTypeInfo<char *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@E@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@E@ATL@@2GB DW 011H			; ATL::CVarTypeInfo<unsigned char>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ DD 08H ; ATL::CVarTypeInfo<char>::pmField
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@D@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@D@ATL@@2GB DW 010H			; ATL::CVarTypeInfo<char>::VT
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?YellowGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?YellowGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f1a9a9br ; 0.603922 ; DirectX::Colors::YellowGreen
	DD	03f4dcdcfr			; 0.803922
	DD	03e48c8car			; 0.196078
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Yellow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Yellow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Yellow
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?WhiteSmoke@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?WhiteSmoke@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f75f5f7r ; 0.960784 ; DirectX::Colors::WhiteSmoke
	DD	03f75f5f7r			; 0.960784
	DD	03f75f5f7r			; 0.960784
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?White@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?White@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::White
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Wheat@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Wheat@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f75f5f7r ; 0.960784 ; DirectX::Colors::Wheat
	DD	03f5edee0r			; 0.870588
	DD	03f33b3b4r			; 0.701961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?Violet@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Violet@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f6eeef0r ; 0.933333 ; DirectX::Colors::Violet
	DD	03f028283r			; 0.509804
	DD	03f6eeef0r			; 0.933333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Turquoise@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Turquoise@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e808081r ; 0.25098 ; DirectX::Colors::Turquoise
	DD	03f60e0e2r			; 0.878431
	DD	03f50d0d2r			; 0.815686
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Transparent@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Transparent@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Transparent
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?Tomato@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Tomato@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Tomato
	DD	03ec6c6c8r			; 0.388235
	DD	03e8e8e8fr			; 0.278431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Thistle@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Thistle@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f58d8dar ; 0.847059 ; DirectX::Colors::Thistle
	DD	03f3fbfc0r			; 0.74902
	DD	03f58d8dar			; 0.847059
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Teal@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Teal@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Teal
	DD	03f008081r			; 0.501961
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?Tan@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Tan@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f52d2d4r ; 0.823529 ; DirectX::Colors::Tan
	DD	03f34b4b5r			; 0.705882
	DD	03f0c8c8dr			; 0.54902
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e8c8c8dr ; 0.27451 ; DirectX::Colors::SteelBlue
	DD	03f028283r			; 0.509804
	DD	03f34b4b5r			; 0.705882
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::SpringGreen
	DD	03f800000r			; 1
	DD	03efeff00r			; 0.498039
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?Snow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Snow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Snow
	DD	03f7afafcr			; 0.980392
	DD	03f7afafcr			; 0.980392
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SlateGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SlateGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ee0e0e2r ; 0.439216 ; DirectX::Colors::SlateGray
	DD	03f008081r			; 0.501961
	DD	03f109091r			; 0.564706
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ed4d4d6r ; 0.415686 ; DirectX::Colors::SlateBlue
	DD	03eb4b4b5r			; 0.352941
	DD	03f4dcdcfr			; 0.803922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?SkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f078788r ; 0.529412 ; DirectX::Colors::SkyBlue
	DD	03f4eced0r			; 0.807843
	DD	03f6bebedr			; 0.921569
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Silver@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Silver@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f40c0c2r ; 0.752941 ; DirectX::Colors::Silver
	DD	03f40c0c2r			; 0.752941
	DD	03f40c0c2r			; 0.752941
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Sienna@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Sienna@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f20a0a1r ; 0.627451 ; DirectX::Colors::Sienna
	DD	03ea4a4a5r			; 0.321569
	DD	03e34b4b5r			; 0.176471
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT __GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
CONST	SEGMENT
__GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c DD 06f15aaf2H
	DW	0d208H
	DW	04e89H
	DB	09aH
	DB	0b4H
	DB	048H
	DB	095H
	DB	035H
	DB	0d3H
	DB	04fH
	DB	09cH
CONST	ENDS
;	COMDAT ?SeaShell@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SeaShell@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::SeaShell
	DD	03f75f5f7r			; 0.960784
	DD	03f6eeef0r			; 0.933333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e38b8b9r ; 0.180392 ; DirectX::Colors::SeaGreen
	DD	03f0b8b8cr			; 0.545098
	DD	03eaeaeafr			; 0.341176
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SandyBrown@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SandyBrown@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f74f4f6r ; 0.956863 ; DirectX::Colors::SandyBrown
	DD	03f24a4a5r			; 0.643137
	DD	03ec0c0c2r			; 0.376471
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?Salmon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Salmon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7afafcr ; 0.980392 ; DirectX::Colors::Salmon
	DD	03f008081r			; 0.501961
	DD	03ee4e4e6r			; 0.447059
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SaddleBrown@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SaddleBrown@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0b8b8cr ; 0.545098 ; DirectX::Colors::SaddleBrown
	DD	03e8a8a8br			; 0.270588
	DD	03d989899r			; 0.0745098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?RoyalBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?RoyalBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e828283r ; 0.254902 ; DirectX::Colors::RoyalBlue
	DD	03ed2d2d4r			; 0.411765
	DD	03f61e1e3r			; 0.882353
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?RosyBrown@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?RosyBrown@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f3cbcbdr ; 0.737255 ; DirectX::Colors::RosyBrown
	DD	03f0f8f90r			; 0.560784
	DD	03f0f8f90r			; 0.560784
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ DB 'A', 00H, 'p', 00H
	DB	'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?Red@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Red@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Red
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Purple@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Purple@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f008081r ; 0.501961 ; DirectX::Colors::Purple
	DD	000000000r			; 0
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?PowderBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PowderBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f30b0b1r ; 0.690196 ; DirectX::Colors::PowderBlue
	DD	03f60e0e2r			; 0.878431
	DD	03f66e6e8r			; 0.901961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Plum@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Plum@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5ddddfr ; 0.866667 ; DirectX::Colors::Plum
	DD	03f20a0a1r			; 0.627451
	DD	03f5ddddfr			; 0.866667
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Pink@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Pink@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Pink
	DD	03f40c0c2r			; 0.752941
	DD	03f4bcbcdr			; 0.796079
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?Peru@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Peru@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f4dcdcfr ; 0.803922 ; DirectX::Colors::Peru
	DD	03f058586r			; 0.521569
	DD	03e7cfcfer			; 0.247059
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PeachPuff@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PeachPuff@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::PeachPuff
	DD	03f5adadcr			; 0.854902
	DD	03f39b9bar			; 0.72549
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PapayaWhip@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PapayaWhip@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::PapayaWhip
	DD	03f6feff1r			; 0.937255
	DD	03f55d5d7r			; 0.835294
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?PaleVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5bdbddr ; 0.858824 ; DirectX::Colors::PaleVioletRed
	DD	03ee0e0e2r			; 0.439216
	DD	03f139394r			; 0.576471
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f2fafb0r ; 0.686275 ; DirectX::Colors::PaleTurquoise
	DD	03f6eeef0r			; 0.933333
	DD	03f6eeef0r			; 0.933333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f189899r ; 0.596078 ; DirectX::Colors::PaleGreen
	DD	03f7bfbfdr			; 0.984314
	DD	03f189899r			; 0.596078
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?PaleGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f6eeef0r ; 0.933333 ; DirectX::Colors::PaleGoldenrod
	DD	03f68e8ear			; 0.909804
	DD	03f2aaaabr			; 0.666667
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Orchid@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Orchid@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5adadcr ; 0.854902 ; DirectX::Colors::Orchid
	DD	03ee0e0e2r			; 0.439216
	DD	03f56d6d8r			; 0.839216
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?OrangeRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OrangeRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::OrangeRed
	DD	03e8a8a8br			; 0.270588
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?Orange@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Orange@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Orange
	DD	03f25a5a6r			; 0.647059
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?OliveDrab@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OliveDrab@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ed6d6d8r ; 0.419608 ; DirectX::Colors::OliveDrab
	DD	03f0e8e8fr			; 0.556863
	DD	03e0c8c8dr			; 0.137255
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Olive@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Olive@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f008081r ; 0.501961 ; DirectX::Colors::Olive
	DD	03f008081r			; 0.501961
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?OldLace@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OldLace@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7dfdffr ; 0.992157 ; DirectX::Colors::OldLace
	DD	03f75f5f7r			; 0.960784
	DD	03f66e6e8r			; 0.901961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Navy@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Navy@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Navy
	DD	000000000r			; 0
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?NavajoWhite@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?NavajoWhite@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::NavajoWhite
	DD	03f5edee0r			; 0.870588
	DD	03f2dadaer			; 0.678431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Moccasin@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Moccasin@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Moccasin
	DD	03f64e4e6r			; 0.894118
	DD	03f35b5b6r			; 0.709804
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MistyRose@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MistyRose@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::MistyRose
	DD	03f64e4e6r			; 0.894118
	DD	03f61e1e3r			; 0.882353
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MintCream@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MintCream@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f75f5f7r ; 0.960784 ; DirectX::Colors::MintCream
	DD	03f800000r			; 1
	DD	03f7afafcr			; 0.980392
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MidnightBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MidnightBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03dc8c8car ; 0.0980392 ; DirectX::Colors::MidnightBlue
	DD	03dc8c8car			; 0.0980392
	DD	03ee0e0e2r			; 0.439216
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f47c7c9r ; 0.780392 ; DirectX::Colors::MediumVioletRed
	DD	03da8a8a9r			; 0.0823529
	DD	03f058586r			; 0.521569
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e909091r ; 0.282353 ; DirectX::Colors::MediumTurquoise
	DD	03f51d1d3r			; 0.819608
	DD	03f4ccccer			; 0.8
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::MediumSpringGreen
	DD	03f7afafcr			; 0.980392
	DD	03f1a9a9br			; 0.603922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ef6f6f8r ; 0.482353 ; DirectX::Colors::MediumSlateBlue
	DD	03ed0d0d2r			; 0.407843
	DD	03f6eeef0r			; 0.933333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e70f0f2r ; 0.235294 ; DirectX::Colors::MediumSeaGreen
	DD	03f33b3b4r			; 0.701961
	DD	03ee2e2e4r			; 0.443137
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumPurple@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumPurple@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f139394r ; 0.576471 ; DirectX::Colors::MediumPurple
	DD	03ee0e0e2r			; 0.439216
	DD	03f5bdbddr			; 0.858824
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ DB 'C', 00H, 'L', 00H
	DB	'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?MediumOrchid@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumOrchid@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f3ababbr ; 0.729412 ; DirectX::Colors::MediumOrchid
	DD	03eaaaaabr			; 0.333333
	DD	03f53d3d5r			; 0.827451
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::MediumBlue
	DD	000000000r			; 0
	DD	03f4dcdcfr			; 0.803922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumAquamarine@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumAquamarine@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ecccccer ; 0.4 ; DirectX::Colors::MediumAquamarine
	DD	03f4dcdcfr			; 0.803922
	DD	03f2aaaabr			; 0.666667
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Maroon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Maroon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f008081r ; 0.501961 ; DirectX::Colors::Maroon
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Magenta@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Magenta@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Magenta
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Linen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Linen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7afafcr ; 0.980392 ; DirectX::Colors::Linen
	DD	03f70f0f2r			; 0.941177
	DD	03f66e6e8r			; 0.901961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LimeGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LimeGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e48c8car ; 0.196078 ; DirectX::Colors::LimeGreen
	DD	03f4dcdcfr			; 0.803922
	DD	03e48c8car			; 0.196078
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?Lime@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Lime@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Lime
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightYellow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightYellow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LightYellow
	DD	03f800000r			; 1
	DD	03f60e0e2r			; 0.878431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f30b0b1r ; 0.690196 ; DirectX::Colors::LightSteelBlue
	DD	03f44c4c6r			; 0.768628
	DD	03f5edee0r			; 0.870588
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03eeeeef0r ; 0.466667 ; DirectX::Colors::LightSlateGray
	DD	03f088889r			; 0.533333
	DD	03f19999ar			; 0.6
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f078788r ; 0.529412 ; DirectX::Colors::LightSkyBlue
	DD	03f4eced0r			; 0.807843
	DD	03f7afafcr			; 0.980392
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e008081r ; 0.12549 ; DirectX::Colors::LightSeaGreen
	DD	03f32b2b3r			; 0.698039
	DD	03f2aaaabr			; 0.666667
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSalmon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSalmon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LightSalmon
	DD	03f20a0a1r			; 0.627451
	DD	03ef4f4f6r			; 0.478431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightPink@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightPink@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LightPink
	DD	03f36b6b7r			; 0.713726
	DD	03f41c1c3r			; 0.756863
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f53d3d5r ; 0.827451 ; DirectX::Colors::LightGray
	DD	03f53d3d5r			; 0.827451
	DD	03f53d3d5r			; 0.827451
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f109091r ; 0.564706 ; DirectX::Colors::LightGreen
	DD	03f6eeef0r			; 0.933333
	DD	03f109091r			; 0.564706
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGoldenrodYellow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGoldenrodYellow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7afafcr ; 0.980392 ; DirectX::Colors::LightGoldenrodYellow
	DD	03f7afafcr			; 0.980392
	DD	03f52d2d4r			; 0.823529
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightCyan@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightCyan@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f60e0e2r ; 0.878431 ; DirectX::Colors::LightCyan
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightCoral@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightCoral@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::LightCoral
	DD	03f008081r			; 0.501961
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f2dadaer ; 0.678431 ; DirectX::Colors::LightBlue
	DD	03f58d8dar			; 0.847059
	DD	03f66e6e8r			; 0.901961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LemonChiffon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LemonChiffon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LemonChiffon
	DD	03f7afafcr			; 0.980392
	DD	03f4dcdcfr			; 0.803922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LawnGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LawnGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ef8f8far ; 0.486275 ; DirectX::Colors::LawnGreen
	DD	03f7cfcfer			; 0.988235
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LavenderBlush@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LavenderBlush@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LavenderBlush
	DD	03f70f0f2r			; 0.941177
	DD	03f75f5f7r			; 0.960784
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Lavender@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Lavender@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f66e6e8r ; 0.901961 ; DirectX::Colors::Lavender
	DD	03f66e6e8r			; 0.901961
	DD	03f7afafcr			; 0.980392
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Khaki@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Khaki@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::Khaki
	DD	03f66e6e8r			; 0.901961
	DD	03f0c8c8dr			; 0.54902
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Ivory@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Ivory@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Ivory
	DD	03f800000r			; 1
	DD	03f70f0f2r			; 0.941177
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Indigo@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Indigo@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e969697r ; 0.294118 ; DirectX::Colors::Indigo
	DD	000000000r			; 0
	DD	03f028283r			; 0.509804
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?IndianRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?IndianRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f4dcdcfr ; 0.803922 ; DirectX::Colors::IndianRed
	DD	03eb8b8b9r			; 0.360784
	DD	03eb8b8b9r			; 0.360784
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?HotPink@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?HotPink@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::HotPink
	DD	03ed2d2d4r			; 0.411765
	DD	03f34b4b5r			; 0.705882
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Honeydew@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Honeydew@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::Honeydew
	DD	03f800000r			; 1
	DD	03f70f0f2r			; 0.941177
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?GreenYellow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?GreenYellow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f2dadaer ; 0.678431 ; DirectX::Colors::GreenYellow
	DD	03f800000r			; 1
	DD	03e3cbcbdr			; 0.184314
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Green@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Green@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Green
	DD	03f008081r			; 0.501961
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f008081r ; 0.501961 ; DirectX::Colors::Gray
	DD	03f008081r			; 0.501961
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Goldenrod@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Goldenrod@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5adadcr ; 0.854902 ; DirectX::Colors::Goldenrod
	DD	03f25a5a6r			; 0.647059
	DD	03e008081r			; 0.12549
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gold@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gold@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Gold
	DD	03f57d7d9r			; 0.843137
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?GhostWhite@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?GhostWhite@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f78f8far ; 0.972549 ; DirectX::Colors::GhostWhite
	DD	03f78f8far			; 0.972549
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gainsboro@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gainsboro@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5cdcder ; 0.862745 ; DirectX::Colors::Gainsboro
	DD	03f5cdcder			; 0.862745
	DD	03f5cdcder			; 0.862745
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Fuchsia@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Fuchsia@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Fuchsia
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?ForestGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?ForestGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e088889r ; 0.133333 ; DirectX::Colors::ForestGreen
	DD	03f0b8b8cr			; 0.545098
	DD	03e088889r			; 0.133333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?FloralWhite@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?FloralWhite@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::FloralWhite
	DD	03f7afafcr			; 0.980392
	DD	03f70f0f2r			; 0.941177
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Firebrick@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Firebrick@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f32b2b3r ; 0.698039 ; DirectX::Colors::Firebrick
	DD	03e088889r			; 0.133333
	DD	03e088889r			; 0.133333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DodgerBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DodgerBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03df0f0f2r ; 0.117647 ; DirectX::Colors::DodgerBlue
	DD	03f109091r			; 0.564706
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DimGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DimGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ed2d2d4r ; 0.411765 ; DirectX::Colors::DimGray
	DD	03ed2d2d4r			; 0.411765
	DD	03ed2d2d4r			; 0.411765
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DeepSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DeepSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DeepSkyBlue
	DD	03f3fbfc0r			; 0.74902
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DeepPink@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DeepPink@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::DeepPink
	DD	03da0a0a1r			; 0.0784314
	DD	03f139394r			; 0.576471
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkViolet@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkViolet@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f149495r ; 0.580392 ; DirectX::Colors::DarkViolet
	DD	000000000r			; 0
	DD	03f53d3d5r			; 0.827451
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DarkTurquoise
	DD	03f4eced0r			; 0.807843
	DD	03f51d1d3r			; 0.819608
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e3cbcbdr ; 0.184314 ; DirectX::Colors::DarkSlateGray
	DD	03e9e9e9fr			; 0.309804
	DD	03e9e9e9fr			; 0.309804
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e909091r ; 0.282353 ; DirectX::Colors::DarkSlateBlue
	DD	03e74f4f6r			; 0.239216
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT __GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
CONST	SEGMENT
__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352 DD 0fc4801a3H
	DW	02ba9H
	DW	011cfH
	DB	0a2H
	DB	029H
	DB	00H
	DB	0aaH
	DB	00H
	DB	03dH
	DB	073H
	DB	052H
CONST	ENDS
;	COMDAT ?DarkSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0f8f90r ; 0.560784 ; DirectX::Colors::DarkSeaGreen
	DD	03f3cbcbdr			; 0.737255
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSalmon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSalmon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f69e9ebr ; 0.913726 ; DirectX::Colors::DarkSalmon
	DD	03f169697r			; 0.588235
	DD	03ef4f4f6r			; 0.478431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0b8b8cr ; 0.545098 ; DirectX::Colors::DarkRed
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOrchid@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOrchid@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f19999ar ; 0.6 ; DirectX::Colors::DarkOrchid
	DD	03e48c8car			; 0.196078
	DD	03f4ccccer			; 0.8
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOrange@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOrange@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::DarkOrange
	DD	03f0c8c8dr			; 0.54902
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOliveGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOliveGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03eaaaaabr ; 0.333333 ; DirectX::Colors::DarkOliveGreen
	DD	03ed6d6d8r			; 0.419608
	DD	03e3cbcbdr			; 0.184314
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkMagenta@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkMagenta@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0b8b8cr ; 0.545098 ; DirectX::Colors::DarkMagenta
	DD	000000000r			; 0
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkKhaki@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkKhaki@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f3dbdber ; 0.741176 ; DirectX::Colors::DarkKhaki
	DD	03f37b7b8r			; 0.717647
	DD	03ed6d6d8r			; 0.419608
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DarkGreen
	DD	03ec8c8car			; 0.392157
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f29a9aar ; 0.662745 ; DirectX::Colors::DarkGray
	DD	03f29a9aar			; 0.662745
	DD	03f29a9aar			; 0.662745
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f38b8b9r ; 0.721569 ; DirectX::Colors::DarkGoldenrod
	DD	03f068687r			; 0.52549
	DD	03d30b0b1r			; 0.0431373
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkCyan@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkCyan@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DarkCyan
	DD	03f0b8b8cr			; 0.545098
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DarkBlue
	DD	000000000r			; 0
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Cyan@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Cyan@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Cyan
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Crimson@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Crimson@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5cdcder ; 0.862745 ; DirectX::Colors::Crimson
	DD	03da0a0a1r			; 0.0784314
	DD	03e70f0f2r			; 0.235294
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Cornsilk@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Cornsilk@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Cornsilk
	DD	03f78f8far			; 0.972549
	DD	03f5cdcder			; 0.862745
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?CornflowerBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?CornflowerBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ec8c8car ; 0.392157 ; DirectX::Colors::CornflowerBlue
	DD	03f159596r			; 0.584314
	DD	03f6dedefr			; 0.929412
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Coral@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Coral@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Coral
	DD	03efeff00r			; 0.498039
	DD	03ea0a0a1r			; 0.313726
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Chocolate@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Chocolate@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f52d2d4r ; 0.823529 ; DirectX::Colors::Chocolate
	DD	03ed2d2d4r			; 0.411765
	DD	03df0f0f2r			; 0.117647
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Chartreuse@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Chartreuse@Colors@DirectX@@3UXMVECTORF32@2@B DD 03efeff00r ; 0.498039 ; DirectX::Colors::Chartreuse
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?CadetBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?CadetBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ebebebfr ; 0.372549 ; DirectX::Colors::CadetBlue
	DD	03f1e9e9fr			; 0.619608
	DD	03f20a0a1r			; 0.627451
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BurlyWood@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BurlyWood@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5edee0r ; 0.870588 ; DirectX::Colors::BurlyWood
	DD	03f38b8b9r			; 0.721569
	DD	03f078788r			; 0.529412
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Brown@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Brown@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f25a5a6r ; 0.647059 ; DirectX::Colors::Brown
	DD	03e28a8a9r			; 0.164706
	DD	03e28a8a9r			; 0.164706
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BlueViolet@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BlueViolet@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0a8a8br ; 0.541176 ; DirectX::Colors::BlueViolet
	DD	03e2cacadr			; 0.168627
	DD	03f62e2e4r			; 0.886275
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Blue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Blue@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Blue
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BlanchedAlmond@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BlanchedAlmond@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::BlanchedAlmond
	DD	03f6bebedr			; 0.921569
	DD	03f4dcdcfr			; 0.803922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Black@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Black@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Black
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Bisque@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Bisque@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Bisque
	DD	03f64e4e6r			; 0.894118
	DD	03f44c4c6r			; 0.768628
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Beige@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Beige@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f75f5f7r ; 0.960784 ; DirectX::Colors::Beige
	DD	03f75f5f7r			; 0.960784
	DD	03f5cdcder			; 0.862745
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Azure@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Azure@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::Azure
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Aquamarine@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Aquamarine@Colors@DirectX@@3UXMVECTORF32@2@B DD 03efeff00r ; 0.498039 ; DirectX::Colors::Aquamarine
	DD	03f800000r			; 1
	DD	03f54d4d6r			; 0.831373
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Aqua@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Aqua@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Aqua
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?AntiqueWhite@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?AntiqueWhite@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7afafcr ; 0.980392 ; DirectX::Colors::AntiqueWhite
	DD	03f6bebedr			; 0.921569
	DD	03f57d7d9r			; 0.843137
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?AliceBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?AliceBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::AliceBlue
	DD	03f78f8far			; 0.972549
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT __GUID_0002e012_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0002e012_0000_0000_c000_000000000046 DD 02e012H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT ?g_XMInvLgE@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMInvLgE@DirectX@@3UXMVECTORF32@1@B DD 03f317218r ; 0.693147 ; DirectX::g_XMInvLgE
	DD	03f317218r			; 0.693147
	DD	03f317218r			; 0.693147
	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?g_XMLgE@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLgE@DirectX@@3UXMVECTORF32@1@B DD 03fb8aa3br ; 1.4427 ; DirectX::g_XMLgE
	DD	03fb8aa3br			; 1.4427
	DD	03fb8aa3br			; 1.4427
	DD	03fb8aa3br			; 1.4427
CONST	ENDS
;	COMDAT ?g_XMLogEst7@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst7@DirectX@@3UXMVECTORF32@1@B DD 0bc2d4f59r ; -0.010578 ; DirectX::g_XMLogEst7
	DD	0bc2d4f59r			; -0.010578
	DD	0bc2d4f59r			; -0.010578
	DD	0bc2d4f59r			; -0.010578
CONST	ENDS
;	COMDAT ?g_XMLogEst6@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst6@DirectX@@3UXMVECTORF32@1@B DD 03d6a1405r ; 0.057148 ; DirectX::g_XMLogEst6
	DD	03d6a1405r			; 0.057148
	DD	03d6a1405r			; 0.057148
	DD	03d6a1405r			; 0.057148
CONST	ENDS
;	COMDAT ?g_XMLogEst5@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst5@DirectX@@3UXMVECTORF32@1@B DD 0be153261r ; -0.1457 ; DirectX::g_XMLogEst5
	DD	0be153261r			; -0.1457
	DD	0be153261r			; -0.1457
	DD	0be153261r			; -0.1457
CONST	ENDS
;	COMDAT ?g_XMLogEst4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst4@DirectX@@3UXMVECTORF32@1@B DD 03e7e8e61r ; 0.24859 ; DirectX::g_XMLogEst4
	DD	03e7e8e61r			; 0.24859
	DD	03e7e8e61r			; 0.24859
	DD	03e7e8e61r			; 0.24859
CONST	ENDS
;	COMDAT ?g_XMLogEst3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst3@DirectX@@3UXMVECTORF32@1@B DD 0beb359der ; -0.350295 ; DirectX::g_XMLogEst3
	DD	0beb359der			; -0.350295
	DD	0beb359der			; -0.350295
	DD	0beb359der			; -0.350295
CONST	ENDS
;	COMDAT ?g_XMLogEst2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst2@DirectX@@3UXMVECTORF32@1@B DD 03ef571d2r ; 0.479384 ; DirectX::g_XMLogEst2
	DD	03ef571d2r			; 0.479384
	DD	03ef571d2r			; 0.479384
	DD	03ef571d2r			; 0.479384
CONST	ENDS
;	COMDAT ?g_XMLogEst1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst1@DirectX@@3UXMVECTORF32@1@B DD 0bf38a351r ; -0.721242 ; DirectX::g_XMLogEst1
	DD	0bf38a351r			; -0.721242
	DD	0bf38a351r			; -0.721242
	DD	0bf38a351r			; -0.721242
CONST	ENDS
;	COMDAT ?g_XMLogEst0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst0@DirectX@@3UXMVECTORF32@1@B DD 03fb8aa2ar ; 1.44269 ; DirectX::g_XMLogEst0
	DD	03fb8aa2ar			; 1.44269
	DD	03fb8aa2ar			; 1.44269
	DD	03fb8aa2ar			; 1.44269
CONST	ENDS
;	COMDAT ?g_XMExpEst7@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst7@DirectX@@3UXMVECTORF32@1@B DD 0b7364261r ; -1.08635e-005 ; DirectX::g_XMExpEst7
	DD	0b7364261r			; -1.08635e-005
	DD	0b7364261r			; -1.08635e-005
	DD	0b7364261r			; -1.08635e-005
CONST	ENDS
;	COMDAT ?g_XMExpEst6@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst6@DirectX@@3UXMVECTORF32@1@B DD 0391aa7d7r ; 0.000147491 ; DirectX::g_XMExpEst6
	DD	0391aa7d7r			; 0.000147491
	DD	0391aa7d7r			; 0.000147491
	DD	0391aa7d7r			; 0.000147491
CONST	ENDS
;	COMDAT ?g_XMExpEst5@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst5@DirectX@@3UXMVECTORF32@1@B DD 0baae1854r ; -0.00132824 ; DirectX::g_XMExpEst5
	DD	0baae1854r			; -0.00132824
	DD	0baae1854r			; -0.00132824
	DD	0baae1854r			; -0.00132824
CONST	ENDS
;	COMDAT ??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ DB 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?g_XMExpEst4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst4@DirectX@@3UXMVECTORF32@1@B DD 03c1d8c54r ; 0.00961598 ; DirectX::g_XMExpEst4
	DD	03c1d8c54r			; 0.00961598
	DD	03c1d8c54r			; 0.00961598
	DD	03c1d8c54r			; 0.00961598
CONST	ENDS
;	COMDAT ??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?g_XMExpEst3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst3@DirectX@@3UXMVECTORF32@1@B DD 0bd6357car ; -0.0555036 ; DirectX::g_XMExpEst3
	DD	0bd6357car			; -0.0555036
	DD	0bd6357car			; -0.0555036
	DD	0bd6357car			; -0.0555036
CONST	ENDS
;	COMDAT ??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ DB 'S', 00H, 'Y'
	DB	00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?g_XMExpEst2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst2@DirectX@@3UXMVECTORF32@1@B DD 03e75fdedr ; 0.240226 ; DirectX::g_XMExpEst2
	DD	03e75fdedr			; 0.240226
	DD	03e75fdedr			; 0.240226
	DD	03e75fdedr			; 0.240226
CONST	ENDS
;	COMDAT ??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ DB 'S'
	DB	00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H, 'T', 00H
	DB	'Y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?g_XMExpEst1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst1@DirectX@@3UXMVECTORF32@1@B DD 0bf317218r ; -0.693147 ; DirectX::g_XMExpEst1
	DD	0bf317218r			; -0.693147
	DD	0bf317218r			; -0.693147
	DD	0bf317218r			; -0.693147
CONST	ENDS
;	COMDAT ??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@ DB 'S', 00H, 'A', 00H, 'M', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?g_XM253@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XM253@DirectX@@3UXMVECTORI32@1@B DD 0fdH		; DirectX::g_XM253
	DD	0fdH
	DD	0fdH
	DD	0fdH
CONST	ENDS
;	COMDAT ??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@ DB 'M', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?g_XMBinNeg150@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMBinNeg150@DirectX@@3UXMVECTORI32@1@B DD 0c3160000H	; DirectX::g_XMBinNeg150
	DD	0c3160000H
	DD	0c3160000H
	DD	0c3160000H
CONST	ENDS
;	COMDAT ??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'H'
	DB	00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?g_XMBin128@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMBin128@DirectX@@3UXMVECTORI32@1@B DD 043000000H	; DirectX::g_XMBin128
	DD	043000000H
	DD	043000000H
	DD	043000000H
CONST	ENDS
;	COMDAT ??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ DB 'I'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?g_XMNegQNaN@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMNegQNaN@DirectX@@3UXMVECTORI32@1@B DD 0ffc00000H	; DirectX::g_XMNegQNaN
	DD	0ffc00000H
	DD	0ffc00000H
	DD	0ffc00000H
CONST	ENDS
;	COMDAT ??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?g_XMNegInfinity@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMNegInfinity@DirectX@@3UXMVECTORI32@1@B DD 0ff800000H ; DirectX::g_XMNegInfinity
	DD	0ff800000H
	DD	0ff800000H
	DD	0ff800000H
CONST	ENDS
;	COMDAT ??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ DB 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?g_XMMinNormal@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMinNormal@DirectX@@3UXMVECTORI32@1@B DD 0800000H	; DirectX::g_XMMinNormal
	DD	0800000H
	DD	0800000H
	DD	0800000H
CONST	ENDS
;	COMDAT ?g_XMNumTrailing@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMNumTrailing@DirectX@@3UXMVECTORI32@1@B DD 017H	; DirectX::g_XMNumTrailing
	DD	017H
	DD	017H
	DD	017H
CONST	ENDS
;	COMDAT ?g_XMSubnormalExponent@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMSubnormalExponent@DirectX@@3UXMVECTORI32@1@B DD 0ffffff82H ; DirectX::g_XMSubnormalExponent
	DD	0ffffff82H
	DD	0ffffff82H
	DD	0ffffff82H
CONST	ENDS
;	COMDAT ?g_XMExponentBias@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMExponentBias@DirectX@@3UXMVECTORI32@1@B DD 07fH	; DirectX::g_XMExponentBias
	DD	07fH
	DD	07fH
	DD	07fH
CONST	ENDS
;	COMDAT ?g_XMsrgbA1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMsrgbA1@DirectX@@3UXMVECTORF32@1@B DD 03f870a3dr ; 1.055 ; DirectX::g_XMsrgbA1
	DD	03f870a3dr			; 1.055
	DD	03f870a3dr			; 1.055
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMsrgbA@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMsrgbA@DirectX@@3UXMVECTORF32@1@B DD 03d6147aer ; 0.055 ; DirectX::g_XMsrgbA
	DD	03d6147aer			; 0.055
	DD	03d6147aer			; 0.055
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMsrgbScale@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMsrgbScale@DirectX@@3UXMVECTORF32@1@B DD 0414eb852r ; 12.92 ; DirectX::g_XMsrgbScale
	DD	0414eb852r			; 12.92
	DD	0414eb852r			; 12.92
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMUnsignedFix@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMUnsignedFix@DirectX@@3UXMVECTORF32@1@B DD 04f000000r ; 2.14748e+009 ; DirectX::g_XMUnsignedFix
	DD	04f000000r			; 2.14748e+009
	DD	04f000000r			; 2.14748e+009
	DD	04f000000r			; 2.14748e+009
CONST	ENDS
;	COMDAT ?g_XMMaxUInt@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMMaxUInt@DirectX@@3UXMVECTORF32@1@B DD 04f7fffffr ; 4.29497e+009 ; DirectX::g_XMMaxUInt
	DD	04f7fffffr			; 4.29497e+009
	DD	04f7fffffr			; 4.29497e+009
	DD	04f7fffffr			; 4.29497e+009
CONST	ENDS
;	COMDAT ?g_XMMaxInt@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMMaxInt@DirectX@@3UXMVECTORF32@1@B DD 04effffffr ; 2.14748e+009 ; DirectX::g_XMMaxInt
	DD	04effffffr			; 2.14748e+009
	DD	04effffffr			; 2.14748e+009
	DD	04effffffr			; 2.14748e+009
CONST	ENDS
;	COMDAT ?g_XMFixUnsigned@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixUnsigned@DirectX@@3UXMVECTORF32@1@B DD 04f000000r ; 2.14748e+009 ; DirectX::g_XMFixUnsigned
	DD	04f000000r			; 2.14748e+009
	DD	04f000000r			; 2.14748e+009
	DD	04f000000r			; 2.14748e+009
CONST	ENDS
;	COMDAT ?g_XMAddByte4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMAddByte4@DirectX@@3UXMVECTORF32@1@B DD 0c3000000r ; -128 ; DirectX::g_XMAddByte4
	DD	0c7000000r			; -32768
	DD	0cb000000r			; -8.38861e+006
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMXorByte4@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMXorByte4@DirectX@@3UXMVECTORI32@1@B DD 080H	; DirectX::g_XMXorByte4
	DD	08000H
	DD	0800000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskByte4@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskByte4@DirectX@@3UXMVECTORI32@1@B DD 0ffH	; DirectX::g_XMMaskByte4
	DD	0ff00H
	DD	0ff0000H
	DD	0ff000000H
CONST	ENDS
;	COMDAT ?g_XMMulDec4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMMulDec4@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMMulDec4
	DD	03a800000r			; 0.000976563
	DD	035800000r			; 9.53674e-007
	DD	030800000r			; 9.31323e-010
CONST	ENDS
;	COMDAT ?g_XMAddDec4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMAddDec4@DirectX@@3UXMVECTORF32@1@B DD 0c4000000r ; -512 ; DirectX::g_XMAddDec4
	DD	0c9000000r			; -524288
	DD	0ce000000r			; -5.36871e+008
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMAddUDec4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMAddUDec4@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMAddUDec4
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	04f000000r			; 2.14748e+009
CONST	ENDS
;	COMDAT ?g_XMXorDec4@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMXorDec4@DirectX@@3UXMVECTORI32@1@B DD 0200H	; DirectX::g_XMXorDec4
	DD	080000H
	DD	020000000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskDec4@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskDec4@DirectX@@3UXMVECTORI32@1@B DD 03ffH	; DirectX::g_XMMaskDec4
	DD	0ffc00H
	DD	03ff00000H
	DD	0c0000000H
CONST	ENDS
;	COMDAT ?g_XMFlipYW@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipYW@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMFlipYW
	DD	080000000H
	DD	00H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMFlipZW@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipZW@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMFlipZW
	DD	00H
	DD	080000000H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMFlipYZ@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipYZ@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMFlipYZ
	DD	080000000H
	DD	080000000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMFlipW@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipW@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMFlipW
	DD	00H
	DD	00H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMFlipZ@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipZ@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMFlipZ
	DD	00H
	DD	080000000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMFlipY@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipY@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMFlipY
	DD	080000000H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMFixupY16W16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixupY16W16@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMFixupY16W16
	DD	03f800000r			; 1
	DD	037800000r			; 1.52588e-005
	DD	037800000r			; 1.52588e-005
CONST	ENDS
;	COMDAT ?g_XMFixupY16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixupY16@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMFixupY16
	DD	037800000r			; 1.52588e-005
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMSelect1011@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMSelect1011@DirectX@@3UXMVECTORI32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1011
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
CONST	ENDS
;	COMDAT ?g_XMSelect1110@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMSelect1110@DirectX@@3UXMVECTORI32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1110
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMSelect1100@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMSelect1100@DirectX@@3UXMVECTORI32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1100
	DD	0ffffffffH
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMSelect1000@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMSelect1000@DirectX@@3UXMVECTORI32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1000
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?g_XMOneHalfMinusEpsilon@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMOneHalfMinusEpsilon@DirectX@@3UXMVECTORI32@1@B DD 03efffffdH ; DirectX::g_XMOneHalfMinusEpsilon
	DD	03efffffdH
	DD	03efffffdH
	DD	03efffffdH
CONST	ENDS
;	COMDAT ?g_XMSelect1010@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMSelect1010@DirectX@@3UXMVECTORI32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1010
	DD	00H
	DD	0ffffffffH
	DD	00H
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ?g_XMSelect0101@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMSelect0101@DirectX@@3UXMVECTORI32@1@B DD 00H	; DirectX::g_XMSelect0101
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
CONST	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT ?g_XMNegateW@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegateW@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMNegateW
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	0bf800000r			; -1
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?g_XMNegateZ@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegateZ@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMNegateZ
	DD	03f800000r			; 1
	DD	0bf800000r			; -1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMNegateY@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegateY@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMNegateY
	DD	0bf800000r			; -1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMNegateX@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegateX@DirectX@@3UXMVECTORF32@1@B DD 0bf800000r ; -1 ; DirectX::g_XMNegateX
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMMaskByte@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskByte@DirectX@@3UXMVECTORI32@1@B DD 0ffH	; DirectX::g_XMMaskByte
	DD	0ffH
	DD	0ffH
	DD	0ffH
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?g_XMNoFraction@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNoFraction@DirectX@@3UXMVECTORF32@1@B DD 04b000000r ; 8.38861e+006 ; DirectX::g_XMNoFraction
	DD	04b000000r			; 8.38861e+006
	DD	04b000000r			; 8.38861e+006
	DD	04b000000r			; 8.38861e+006
CONST	ENDS
;	COMDAT ?g_XMNormalizeX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNormalizeX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B DD 038000100r ; 3.05185e-005 ; DirectX::g_XMNormalizeX16Y16Z16W16
	DD	038000100r			; 3.05185e-005
	DD	030000100r			; 4.65675e-010
	DD	030000100r			; 4.65675e-010
CONST	ENDS
;	COMDAT ?g_XMFixX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B DD 0c7000000r ; -32768 ; DirectX::g_XMFixX16Y16Z16W16
	DD	0c7000000r			; -32768
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMFlipX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B DD 08000H ; DirectX::g_XMFlipX16Y16Z16W16
	DD	08000H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?g_XMMaskX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B DD 0ffffH ; DirectX::g_XMMaskX16Y16Z16W16
	DD	0ffffH
	DD	0ffff0000H
	DD	0ffff0000H
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?g_XMNormalizeX16Y16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNormalizeX16Y16@DirectX@@3UXMVECTORF32@1@B DD 038000100r ; 3.05185e-005 ; DirectX::g_XMNormalizeX16Y16
	DD	030000100r			; 4.65675e-010
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMFixX16Y16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixX16Y16@DirectX@@3UXMVECTORF32@1@B DD 0c7000000r ; -32768 ; DirectX::g_XMFixX16Y16
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?g_XMFlipX16Y16@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipX16Y16@DirectX@@3UXMVECTORI32@1@B DD 08000H	; DirectX::g_XMFlipX16Y16
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?g_XMMaskX16Y16@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskX16Y16@DirectX@@3UXMVECTORI32@1@B DD 0ffffH	; DirectX::g_XMMaskX16Y16
	DD	0ffff0000H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?g_XMNormalizeA2B10G10R10@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNormalizeA2B10G10R10@DirectX@@3UXMVECTORF32@1@B DD 03b004020r ; 0.00195695 ; DirectX::g_XMNormalizeA2B10G10R10
	DD	036004020r			; 1.91108e-006
	DD	031004020r			; 1.86629e-009
	DD	02faaaaabr			; 3.10441e-010
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?g_XMFixAA2B10G10R10@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixAA2B10G10R10@DirectX@@3UXMVECTORF32@1@B DD 0c4000000r ; -512 ; DirectX::g_XMFixAA2B10G10R10
	DD	0c9000000r			; -524288
	DD	0ce000000r			; -5.36871e+008
	DD	04f000000r			; 2.14748e+009
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?g_XMFlipA2B10G10R10@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipA2B10G10R10@DirectX@@3UXMVECTORI32@1@B DD 0200H ; DirectX::g_XMFlipA2B10G10R10
	DD	080000H
	DD	020000000H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMMaskA2B10G10R10@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskA2B10G10R10@DirectX@@3UXMVECTORI32@1@B DD 03ffH ; DirectX::g_XMMaskA2B10G10R10
	DD	0ffc00H
	DD	03ff00000H
	DD	0c0000000H
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?g_XMNormalizeA8R8G8B8@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNormalizeA8R8G8B8@DirectX@@3UXMVECTORF32@1@B DD 033808081r ; 5.98384e-008 ; DirectX::g_XMNormalizeA8R8G8B8
	DD	037808081r			; 1.53186e-005
	DD	03b808081r			; 0.00392157
	DD	02f808081r			; 2.33744e-010
CONST	ENDS
;	COMDAT ?g_XMFixAA8R8G8B8@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixAA8R8G8B8@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMFixAA8R8G8B8
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	04f000000r			; 2.14748e+009
CONST	ENDS
;	COMDAT ?g_XMFlipA8R8G8B8@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipA8R8G8B8@DirectX@@3UXMVECTORI32@1@B DD 00H	; DirectX::g_XMFlipA8R8G8B8
	DD	00H
	DD	00H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMMaskA8R8G8B8@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskA8R8G8B8@DirectX@@3UXMVECTORI32@1@B DD 0ff0000H ; DirectX::g_XMMaskA8R8G8B8
	DD	0ff00H
	DD	0ffH
	DD	0ff000000H
CONST	ENDS
;	COMDAT ?g_XMNegOneMask@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMNegOneMask@DirectX@@3UXMVECTORI32@1@B DD 0ffffffffH ; DirectX::g_XMNegOneMask
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
CONST	ENDS
;	COMDAT ?g_XMFltMax@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFltMax@DirectX@@3UXMVECTORI32@1@B DD 07f7fffffH	; DirectX::g_XMFltMax
	DD	07f7fffffH
	DD	07f7fffffH
	DD	07f7fffffH
CONST	ENDS
;	COMDAT ?g_XMFltMin@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFltMin@DirectX@@3UXMVECTORI32@1@B DD 0800000H	; DirectX::g_XMFltMin
	DD	0800000H
	DD	0800000H
	DD	0800000H
CONST	ENDS
;	COMDAT ?g_XMAbsMask@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMAbsMask@DirectX@@3UXMVECTORI32@1@B DD 07fffffffH	; DirectX::g_XMAbsMask
	DD	07fffffffH
	DD	07fffffffH
	DD	07fffffffH
CONST	ENDS
;	COMDAT ?g_XMQNaNTest@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMQNaNTest@DirectX@@3UXMVECTORI32@1@B DD 07fffffH	; DirectX::g_XMQNaNTest
	DD	07fffffH
	DD	07fffffH
	DD	07fffffH
CONST	ENDS
;	COMDAT ?g_XMQNaN@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMQNaN@DirectX@@3UXMVECTORI32@1@B DD 07fc00000H	; DirectX::g_XMQNaN
	DD	07fc00000H
	DD	07fc00000H
	DD	07fc00000H
CONST	ENDS
;	COMDAT ?g_XMInfinity@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMInfinity@DirectX@@3UXMVECTORI32@1@B DD 07f800000H	; DirectX::g_XMInfinity
	DD	07f800000H
	DD	07f800000H
	DD	07f800000H
CONST	ENDS
;	COMDAT ?g_XMEpsilon@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMEpsilon@DirectX@@3UXMVECTORF32@1@B DD 034000000r ; 1.19209e-007 ; DirectX::g_XMEpsilon
	DD	034000000r			; 1.19209e-007
	DD	034000000r			; 1.19209e-007
	DD	034000000r			; 1.19209e-007
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?g_XMNegativeOneHalf@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegativeOneHalf@DirectX@@3UXMVECTORF32@1@B DD 0bf000000r ; -0.5 ; DirectX::g_XMNegativeOneHalf
	DD	0bf000000r			; -0.5
	DD	0bf000000r			; -0.5
	DD	0bf000000r			; -0.5
CONST	ENDS
;	COMDAT ?g_XMOneHalf@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMOneHalf@DirectX@@3UXMVECTORF32@1@B DD 03f000000r ; 0.5 ; DirectX::g_XMOneHalf
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
CONST	ENDS
;	COMDAT ?g_XMNegativeOne@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegativeOne@DirectX@@3UXMVECTORF32@1@B DD 0bf800000r ; -1 ; DirectX::g_XMNegativeOne
	DD	0bf800000r			; -1
	DD	0bf800000r			; -1
	DD	0bf800000r			; -1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?g_XMSix@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMSix@DirectX@@3UXMVECTORF32@1@B DD 040c00000r ; 6	; DirectX::g_XMSix
	DD	040c00000r			; 6
	DD	040c00000r			; 6
	DD	040c00000r			; 6
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?g_XMFour@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFour@DirectX@@3UXMVECTORF32@1@B DD 040800000r ; 4	; DirectX::g_XMFour
	DD	040800000r			; 4
	DD	040800000r			; 4
	DD	040800000r			; 4
CONST	ENDS
;	COMDAT ?g_XMTwo@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTwo@DirectX@@3UXMVECTORF32@1@B DD 040000000r ; 2	; DirectX::g_XMTwo
	DD	040000000r			; 2
	DD	040000000r			; 2
	DD	040000000r			; 2
CONST	ENDS
;	COMDAT ?g_XMZero@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMZero@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0	; DirectX::g_XMZero
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?g_XMOne3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMOne3@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1	; DirectX::g_XMOne3
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMOne@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMOne@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1	; DirectX::g_XMOne
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMMaskW@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskW@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMMaskW
	DD	00H
	DD	00H
	DD	0ffffffffH
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?g_XMMaskZ@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskZ@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMMaskZ
	DD	00H
	DD	0ffffffffH
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskY@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskY@DirectX@@3UXMVECTORI32@1@B DD 00H		; DirectX::g_XMMaskY
	DD	0ffffffffH
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskX@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskX@DirectX@@3UXMVECTORI32@1@B DD 0ffffffffH	; DirectX::g_XMMaskX
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?g_XMMask3@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMask3@DirectX@@3UXMVECTORI32@1@B DD 0ffffffffH	; DirectX::g_XMMask3
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMNegate3@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMNegate3@DirectX@@3UXMVECTORI32@1@B DD 080000000H	; DirectX::g_XMNegate3
	DD	080000000H
	DD	080000000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMNegativeZero@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMNegativeZero@DirectX@@3UXMVECTORI32@1@B DD 080000000H ; DirectX::g_XMNegativeZero
	DD	080000000H
	DD	080000000H
	DD	080000000H
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?g_XMNegIdentityR3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegIdentityR3@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMNegIdentityR3
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
CONST	ENDS
;	COMDAT ?g_XMNegIdentityR2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegIdentityR2@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMNegIdentityR2
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMNegIdentityR1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegIdentityR1@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMNegIdentityR1
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?g_XMNegIdentityR0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegIdentityR0@DirectX@@3UXMVECTORF32@1@B DD 0bf800000r ; -1 ; DirectX::g_XMNegIdentityR0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMIdentityR3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMIdentityR3@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMIdentityR3
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMIdentityR2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMIdentityR2@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMIdentityR2
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?g_XMIdentityR1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMIdentityR1@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMIdentityR1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMIdentityR0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMIdentityR0@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMIdentityR0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?g_XMArcEstCoefficients@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMArcEstCoefficients@DirectX@@3UXMVECTORF32@1@B DD 03fc90da4r ; 1.57073 ; DirectX::g_XMArcEstCoefficients
	DD	0be593484r			; -0.212114
	DD	03d981627r			; 0.074261
	DD	0bc996e30r			; -0.0187293
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?g_XMATanEstCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMATanEstCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 0bea91d04r ; -0.330299 ; DirectX::g_XMATanEstCoefficients1
	DD	03e3876e2r			; 0.180141
	DD	0bdae5a36r			; -0.085133
	DD	03caaae5fr			; 0.0208351
CONST	ENDS
;	COMDAT ?g_XMATanEstCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMATanEstCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 03f7ff738r ; 0.999866 ; DirectX::g_XMATanEstCoefficients0
	DD	03f7ff738r			; 0.999866
	DD	03f7ff738r			; 0.999866
	DD	03f7ff738r			; 0.999866
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?g_XMATanCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMATanCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 0bd9a3174r ; -0.0752896 ; DirectX::g_XMATanCoefficients1
	DD	03d2fc1fer			; 0.0429096
	DD	0bc846e02r			; -0.0161657
	DD	03b3bd74ar			; 0.00286623
CONST	ENDS
;	COMDAT ?g_XMATanCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMATanCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 0beaaaa6cr ; -0.333331 ; DirectX::g_XMATanCoefficients0
	DD	03e4cbbe5r			; 0.199936
	DD	0be117fc7r			; -0.142089
	DD	03dda3d83r			; 0.106563
CONST	ENDS
;	COMDAT ?g_XMArcCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMArcCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 03cfd10f8r ; 0.0308919 ; DirectX::g_XMArcCoefficients1
	DD	0bc8bfc66r			; -0.0170881
	DD	03bda90c5r			; 0.00667009
	DD	0baa57a2cr			; -0.00126249
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?g_XMArcCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMArcCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 03fc90fdar ; 1.5708 ; DirectX::g_XMArcCoefficients0
	DD	0be5bbfcar			; -0.214599
	DD	03db63a9er			; 0.088979
	DD	0bd4d8392r			; -0.0501743
CONST	ENDS
;	COMDAT ?g_XMTanCoefficients2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTanCoefficients2@DirectX@@3UXMVECTORF32@1@B DD 03a1aac12r ; 0.000590027 ; DirectX::g_XMTanCoefficients2
	DD	0397abeb9r			; 0.000239129
	DD	038cb3f0cr			; 9.69154e-005
	DD	03824bec9r			; 3.92783e-005
CONST	ENDS
;	COMDAT ?g_XMTanCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTanCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 03cb327a4r ; 0.0218695 ; DirectX::g_XMTanCoefficients1
	DD	03c11371br			; 0.00886324
	DD	03b6b69e9r			; 0.00359213
	DD	03abed1b3r			; 0.00145583
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?g_XMTanCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTanCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMTanCoefficients0
	DD	03eaaaaabr			; 0.333333
	DD	03e088889r			; 0.133333
	DD	03d5d0dd1r			; 0.0539683
CONST	ENDS
;	COMDAT ?g_XMCosCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMCosCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 0b48bdd11r ; -2.60516e-007 ; DirectX::g_XMCosCoefficients1
	DD	0befff67er			; -0.499927
	DD	03d29f587r			; 0.0414939
	DD	0baa69fdbr			; -0.00127124
CONST	ENDS
;	COMDAT ?g_XMCosCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMCosCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 0bf000000r ; -0.5 ; DirectX::g_XMCosCoefficients0
	DD	03d2aaaa3r			; 0.0416666
	DD	0bab609aar			; -0.00138884
	DD	037cfb4c2r			; 2.47605e-005
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?g_XMSinCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMSinCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 0b2cd365br ; -2.38899e-008 ; DirectX::g_XMSinCoefficients1
	DD	0be2aa888r			; -0.166659
	DD	03c08373cr			; 0.00831395
	DD	0b9423ec8r			; -0.000185247
CONST	ENDS
;	COMDAT ?g_XMSinCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMSinCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 0be2aaaabr ; -0.166667 ; DirectX::g_XMSinCoefficients0
	DD	03c088886r			; 0.00833333
	DD	0b9500bf1r			; -0.000198409
	DD	03638b88er			; 2.75256e-006
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT __GUID_b196b284_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b284_bab4_101a_b69c_00aa00341d07 DD 0b196b284H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?MAX_OBJECTS@CScene@@0HB
CONST	SEGMENT
?MAX_OBJECTS@CScene@@0HB DD 07d0H			; CScene::MAX_OBJECTS
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?MAX_SHADER_LIGHTS@CScene@@0HB
CONST	SEGMENT
?MAX_SHADER_LIGHTS@CScene@@0HB DD 0cH			; CScene::MAX_SHADER_LIGHTS
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?MAX_LIGHTS@CScene@@0HB
CONST	SEGMENT
?MAX_LIGHTS@CScene@@0HB DD 01eH				; CScene::MAX_LIGHTS
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?MAX_VERTEX_ELTS@CModel@@0HB
CONST	SEGMENT
?MAX_VERTEX_ELTS@CModel@@0HB DD 040H			; CModel::MAX_VERTEX_ELTS
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT __GUID_00000146_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000146_0000_0000_c000_000000000046 DD 0146H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Maximum@$S@std@@2IB
CONST	SEGMENT
?value@?$_Maximum@$S@std@@2IB DD 00H			; std::_Maximum<>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$00@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$00@std@@2IB DD 01H		; std::integral_constant<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Max@?$AtlLimits@_K@ATL@@2_KB DQ ffffffffffffffffH	; ATL::AtlLimits<unsigned __int64>::_Max
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Min@?$AtlLimits@_K@ATL@@2_KB DQ 0000000000000000H	; ATL::AtlLimits<unsigned __int64>::_Min
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB DW 04006H	; ATL::CVarTypeInfo<tagCY *>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Max@?$AtlLimits@_J@ATL@@2_JB DQ 7fffffffffffffffH	; ATL::AtlLimits<__int64>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Min@?$AtlLimits@_J@ATL@@2_JB DQ 8000000000000000H	; ATL::AtlLimits<__int64>::_Min
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020400_0000_0000_c000_000000000046 DD 020400H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY>::pmField
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Max@?$AtlLimits@K@ATL@@2KB DD 0ffffffffH		; ATL::AtlLimits<unsigned long>::_Max
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB DW 06H		; ATL::CVarTypeInfo<tagCY>::VT
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Min@?$AtlLimits@K@ATL@@2KB DD 00H			; ATL::AtlLimits<unsigned long>::_Min
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch * *>::pmField
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Max@?$AtlLimits@J@ATL@@2JB DD 07fffffffH		; ATL::AtlLimits<long>::_Max
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB DW 04009H	; ATL::CVarTypeInfo<IDispatch * *>::VT
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Min@?$AtlLimits@J@ATL@@2JB DD 080000000H		; ATL::AtlLimits<long>::_Min
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$01@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$01@std@@2IB DD 02H		; std::integral_constant<unsigned int,2>::value
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000000_0000_0000_c000_000000000046 DD 00H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Max@?$AtlLimits@I@ATL@@2IB DD 0ffffffffH		; ATL::AtlLimits<unsigned int>::_Max
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB DW 09H	; ATL::CVarTypeInfo<IDispatch *>::VT
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Min@?$AtlLimits@I@ATL@@2IB DD 00H			; ATL::AtlLimits<unsigned int>::_Min
CONST	ENDS
;	COMDAT ?m_nCategory@CTrace@ATL@@1IA
_DATA	SEGMENT
?m_nCategory@CTrace@ATL@@1IA DD 0ffffffffH		; ATL::CTrace::m_nCategory
_DATA	ENDS
;	COMDAT ?_Max@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Max@?$AtlLimits@H@ATL@@2HB DD 07fffffffH		; ATL::AtlLimits<int>::_Max
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown * *>::pmField
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Min@?$AtlLimits@H@ATL@@2HB DD 080000000H		; ATL::AtlLimits<int>::_Min
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB DW 0400dH	; ATL::CVarTypeInfo<IUnknown * *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB DW 0dH	; ATL::CVarTypeInfo<IUnknown *>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB DW 04008H		; ATL::CVarTypeInfo<wchar_t * *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t *>::pmField
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$03@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$03@std@@2IB DD 04H		; std::integral_constant<unsigned int,4>::value
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_W@ATL@@2GB DW 08H			; ATL::CVarTypeInfo<wchar_t *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB DW 0400cH	; ATL::CVarTypeInfo<tagVARIANT *>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ DD 08H ; ATL::CVarTypeInfo<double *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAN@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAN@ATL@@2GB DW 04005H		; ATL::CVarTypeInfo<double *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ DD 08H ; ATL::CVarTypeInfo<double>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@N@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@N@ATL@@2GB DW 05H			; ATL::CVarTypeInfo<double>::VT
CONST	ENDS
;	COMDAT ?MAX_TYPE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_TYPE@CRegParser@ATL@@1HB DD 01000H			; ATL::CRegParser::MAX_TYPE
CONST	ENDS
;	COMDAT ?cbNeverDelete@CRegParser@ATL@@1HB
CONST	SEGMENT
?cbNeverDelete@CRegParser@ATL@@1HB DD 0cH		; ATL::CRegParser::cbNeverDelete
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB DD FLAT:??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
	DD	FLAT:??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
	DD	FLAT:??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DD	FLAT:??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
	DD	FLAT:??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
	DD	FLAT:??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
	DD	FLAT:??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
	DD	FLAT:??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ DD 08H ; ATL::CVarTypeInfo<float *>::pmField
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAM@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAM@ATL@@2GB DW 04004H		; ATL::CVarTypeInfo<float *>::VT
CONST	ENDS
CONST	SEGMENT
_XM_PI	DD	040490fdbr			; 3.14159
_XM_2PI	DD	040c90fdbr			; 6.28319
_XM_1DIVPI DD	03ea2f983r			; 0.31831
_XM_1DIV2PI DD	03e22f983r			; 0.159155
_XM_PIDIV2 DD	03fc90fdbr			; 1.5708
_XM_PIDIV4 DD	03f490fdbr			; 0.785398
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ DD 08H ; ATL::CVarTypeInfo<float>::pmField
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$07@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$07@std@@2IB DD 08H		; std::integral_constant<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@M@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@M@ATL@@2GB DW 04H			; ATL::CVarTypeInfo<float>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_K@ATL@@2GB DW 04015H		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?MAX_VALUE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_VALUE@CRegParser@ATL@@1HB DD 01000H		; ATL::CRegParser::MAX_VALUE
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_K@ATL@@2GB DW 015H			; ATL::CVarTypeInfo<unsigned __int64>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_J@ATL@@2GB DW 04014H		; ATL::CVarTypeInfo<__int64 *>::VT
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	_hypot
PUBLIC	??BXMVECTORF32@DirectX@@QBE?AT__m128@@XZ	; DirectX::XMVECTORF32::operator __m128
PUBLIC	??0XMMATRIX@DirectX@@QAE@XZ			; DirectX::XMMATRIX::XMMATRIX
PUBLIC	??4XMMATRIX@DirectX@@QAEAAU01@ABU01@@Z		; DirectX::XMMATRIX::operator=
PUBLIC	??0XMFLOAT2@DirectX@@QAE@XZ			; DirectX::XMFLOAT2::XMFLOAT2
PUBLIC	??0XMFLOAT2@DirectX@@QAE@MM@Z			; DirectX::XMFLOAT2::XMFLOAT2
PUBLIC	??0XMFLOAT3@DirectX@@QAE@XZ			; DirectX::XMFLOAT3::XMFLOAT3
PUBLIC	??0XMFLOAT3@DirectX@@QAE@MMM@Z			; DirectX::XMFLOAT3::XMFLOAT3
PUBLIC	??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z		; DirectX::XMFLOAT3::operator=
PUBLIC	??0XMFLOAT4@DirectX@@QAE@XZ			; DirectX::XMFLOAT4::XMFLOAT4
PUBLIC	??0XMFLOAT4@DirectX@@QAE@MMMM@Z			; DirectX::XMFLOAT4::XMFLOAT4
PUBLIC	??4XMFLOAT4@DirectX@@QAEAAU01@ABU01@@Z		; DirectX::XMFLOAT4::operator=
PUBLIC	?XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@1@T__m128@@@Z ; DirectX::XMStoreFloat4
PUBLIC	?XMVectorSet@DirectX@@YQ?AT__m128@@MMMM@Z	; DirectX::XMVectorSet
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	??0?$_Func_class@X$$$V@std@@QAE@XZ		; std::_Func_class<void>::_Func_class<void>
PUBLIC	?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ		; std::_Func_class<void>::_Reset
PUBLIC	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
PUBLIC	??0?$function@$$A6AXXZ@std@@QAE@$$T@Z		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<2,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<32,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?GetCategoryName@CTrace@ATL@@CAPA_WI@Z		; ATL::CTrace::GetCategoryName
PUBLIC	?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z		; ATL::CTrace::TraceV
PUBLIC	?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z		; ATL::CTrace::TraceV
PUBLIC	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z	; ATL::CTrace::RegisterCategory
PUBLIC	??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
PUBLIC	?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
PUBLIC	?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
PUBLIC	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?ToRadians@@YAMM@Z				; ToRadians
PUBLIC	?square@@YAMM@Z					; square
PUBLIC	?SetDevice@CModel@@SAXPAUID3D11Device@@@Z	; CModel::SetDevice
PUBLIC	?SetDeviceContext@CModel@@SAXPAUID3D11DeviceContext@@@Z ; CModel::SetDeviceContext
PUBLIC	?GetPosition@CModel@@QAE?AUXMFLOAT3@DirectX@@XZ	; CModel::GetPosition
PUBLIC	?GetWorldMatrix@CModel@@QAE?AUXMMATRIX@DirectX@@XZ ; CModel::GetWorldMatrix
PUBLIC	?SetScale@CModel@@QAEXM@Z			; CModel::SetScale
PUBLIC	?SetViewport@CCamera@@SAXHH@Z			; CCamera::SetViewport
PUBLIC	?GetViewMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ ; CCamera::GetViewMatrix
PUBLIC	?GetProjectionMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ ; CCamera::GetProjectionMatrix
PUBLIC	?SetPosition@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z	; CCamera::SetPosition
PUBLIC	?SetRotation@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z	; CCamera::SetRotation
PUBLIC	?SetNearClip@CCamera@@QAEXM@Z			; CCamera::SetNearClip
PUBLIC	?GetCost@MapSquare@@QAEIII@Z			; MapSquare::GetCost
PUBLIC	?GetValueByOffset@MapSquare@@QAEIIIH@Z		; MapSquare::GetValueByOffset
PUBLIC	?GetWidth@MapSquare@@QAEIXZ			; MapSquare::GetWidth
PUBLIC	?GetHeight@MapSquare@@QAEIXZ			; MapSquare::GetHeight
PUBLIC	?GetPathNodes@MapSquare@@QAEXAAIAAPAUCoords@@@Z	; MapSquare::GetPathNodes
PUBLIC	?GetPathSplines@MapSquare@@QAEXAAIAAPAPAUsCoords@@@Z ; MapSquare::GetPathSplines
PUBLIC	?GetColourV@CLight@@QAE?AUXMFLOAT3@DirectX@@XZ	; CLight::GetColourV
PUBLIC	?GetModel@CLight@@QAEPAVCModel@@XZ		; CLight::GetModel
PUBLIC	?GetBrightness@CLight@@QAEMXZ			; CLight::GetBrightness
PUBLIC	??_GCLight@@QAEPAXI@Z				; CLight::`scalar deleting destructor'
PUBLIC	?GetModel@CRenderObject@@QAEPAVCModel@@XZ	; CRenderObject::GetModel
PUBLIC	?GetColourV@CRenderObject@@QAE?AUXMFLOAT3@DirectX@@XZ ; CRenderObject::GetColourV
PUBLIC	?GetTexture@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ ; CRenderObject::GetTexture
PUBLIC	?GetNormalMap@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ ; CRenderObject::GetNormalMap
PUBLIC	?IsLit@CRenderObject@@QAE_NXZ			; CRenderObject::IsLit
PUBLIC	?IsTransparent@CRenderObject@@QAE_NXZ		; CRenderObject::IsTransparent
PUBLIC	?Render@CRenderObject@@QAEXXZ			; CRenderObject::Render
PUBLIC	??_GCRenderObject@@QAEPAXI@Z			; CRenderObject::`scalar deleting destructor'
PUBLIC	?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ; ModelBatch::SetColour
PUBLIC	?Reset@ModelBatch@@QAEXXZ			; ModelBatch::Reset
PUBLIC	?SetLights@CScene@@AAEXUXMFLOAT3@DirectX@@QAPAVCLight@@H@Z ; CScene::SetLights
PUBLIC	?compareLights@CScene@@CAHPBX0@Z		; CScene::compareLights
PUBLIC	?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z		; CScene::WndProc
PUBLIC	?DrawObject@CScene@@AAEXH_N@Z			; CScene::DrawObject
PUBLIC	?DrawAllObjects@CScene@@AAEX_N@Z		; CScene::DrawAllObjects
PUBLIC	?DisplayMapText@CScene@@AAEXH@Z			; CScene::DisplayMapText
PUBLIC	?DisplayText@CScene@@AAEXQADI@Z			; CScene::DisplayText
PUBLIC	?LoadShaders@CScene@@AAE_NXZ			; CScene::LoadShaders
PUBLIC	?LoadTechnique@CScene@@AAE_NXZ			; CScene::LoadTechnique
PUBLIC	??0CScene@@QAE@XZ				; CScene::CScene
PUBLIC	??1CScene@@QAE@XZ				; CScene::~CScene
PUBLIC	?InitDevice@CScene@@QAE_NXZ			; CScene::InitDevice
PUBLIC	?ReleaseResources@CScene@@QAEXXZ		; CScene::ReleaseResources
PUBLIC	?LoadEffectFile@CScene@@QAE_NXZ			; CScene::LoadEffectFile
PUBLIC	?InitScene@CScene@@QAE_NXZ			; CScene::InitScene
PUBLIC	?UpdateScene@CScene@@QAEXM@Z			; CScene::UpdateScene
PUBLIC	?VisualisePath@CScene@@QAEXXZ			; CScene::VisualisePath
PUBLIC	?RenderScene@CScene@@QAEXXZ			; CScene::RenderScene
PUBLIC	?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z	; CScene::InitWindow
PUBLIC	?VisualiseTurrets@CScene@@QAEXXZ		; CScene::VisualiseTurrets
PUBLIC	??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z		; strcpy_s<100>
PUBLIC	??$_itoa_s@$05@@YAHHAAY05DH@Z			; _itoa_s<6>
PUBLIC	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z		; strcat_s<100>
PUBLIC	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z		; ATL::CA2WEX<128>::CA2WEX<128>
PUBLIC	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ			; ATL::CA2WEX<128>::~CA2WEX<128>
PUBLIC	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ		; ATL::CA2WEX<128>::operator wchar_t *
PUBLIC	?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z		; ATL::CA2WEX<128>::Init
PUBLIC	??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z	; ATL::AtlConvFreeMemory<wchar_t>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z	; ATL::AtlConvAllocMemory<wchar_t>
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	?g_XMTanEstCoefficients@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMTanEstCoefficients
PUBLIC	?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMPiConstants0
PUBLIC	?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegativeTwoPi
PUBLIC	?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegativePi
PUBLIC	?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMHalfPi
PUBLIC	?g_XMPi@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMPi
PUBLIC	?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMReciprocalPi
PUBLIC	?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMTwoPi
PUBLIC	?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMReciprocalTwoPi
PUBLIC	??_C@_1JE@DMOBBMDE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?5?$AAk@ ; `string'
PUBLIC	??_C@_1BK@FHLBGAOP@?$AAp?$AAD?$AAe?$AAs?$AAt?$AAi?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@2@T__m128@@@Z@4JA ; `DirectX::XMStoreFloat4'::`2'::__LINE__Var
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@ ; `string'
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@ ; `string'
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@ ; `string'
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@ ; `string'
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@ ; `string'
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@ ; `string'
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@ ; `string'
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@ ; `string'
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@		; `string'
PUBLIC	??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA	; `ATL::AtlThrowImpl'::`2'::__LINE__Var
PUBLIC	??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ ; `string'
PUBLIC	??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@ ; `string'
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ ; `string'
PUBLIC	??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA ; `ATL::AtlWinModuleInit'::`2'::__LINE__Var
PUBLIC	??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	??_C@_15KNBIKKIN@?$AA?$CF?$AAd?$AA?$AA@		; `string'
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_03FLNEJKFD@bob?$AA@			; `string'
PUBLIC	??_C@_06HGKAGIBP@Cube?4x?$AA@			; `string'
PUBLIC	??_C@_0O@MAAOBHJP@TrafficCone?4x?$AA@		; `string'
PUBLIC	??_C@_08EEMGLHJD@Sphere?4x?$AA@			; `string'
PUBLIC	??_C@_1CC@BMAIPOBA@?$AAA?$AAr?$AAi?$AAa?$AAl?$AA?4?$AAs?$AAp?$AAr?$AAi?$AAt?$AAe?$AAf?$AAo?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_08EEOHOBEO@Settings?$AA@			; `string'
PUBLIC	??_C@_0BK@MLELINGD@?5Settings?5position?$DN?85?55?8?5?$AA@ ; `string'
PUBLIC	??_C@_0BM@GIBHHGMJ@Graphics?5?9?5requires?5restart?$AA@ ; `string'
PUBLIC	??_C@_0M@IFKGHBCH@ResolutionX?$AA@		; `string'
PUBLIC	??_C@_0M@JMLNEAGG@ResolutionY?$AA@		; `string'
PUBLIC	??_C@_0L@PNCHNAPG@Node?5Model?$AA@		; `string'
PUBLIC	??_C@_0L@OIMGCOOI@Node?5Scale?$AA@		; `string'
PUBLIC	??_C@_0N@EPBODBBM@Spline?5Model?$AA@		; `string'
PUBLIC	??_C@_0N@FKPPMPAC@Spline?5Scale?$AA@		; `string'
PUBLIC	??_C@_0BK@JKDJKFPL@AI?5?9?5requires?5recalcualte?$AA@ ; `string'
PUBLIC	??_C@_0L@GCIJCCFE@Wall?5Range?$AA@		; `string'
PUBLIC	??_C@_0L@NBBONMFG@Base?5Range?$AA@		; `string'
PUBLIC	??_C@_0BD@BMBFNPNO@Heavy?5Turret?5Range?$AA@	; `string'
PUBLIC	??_C@_0BE@LFFKHKAN@Medium?5Turret?5Range?$AA@	; `string'
PUBLIC	??_C@_0BD@HEBLKGAH@Light?5Turret?5Range?$AA@	; `string'
PUBLIC	??_C@_0BE@EOIDACPB@Minimum?5Path?5Length?$AA@	; `string'
PUBLIC	??_C@_0BJ@BKJMPLKA@min?$DN0?41?5max?$DN0?49?5step?$DN0?41?$AA@ ; `string'
PUBLIC	??_C@_0BE@GHPNPPOJ@Maximum?5Path?5Length?$AA@	; `string'
PUBLIC	??_C@_0P@HKLMEJGE@ChokeThreshold?$AA@		; `string'
PUBLIC	??_C@_0N@BCBLNKGN@Calculations?$AA@		; `string'
PUBLIC	??_C@_0CA@JIMFFDAA@?5Calculations?5position?$DN?8205?55?8?5?$AA@ ; `string'
PUBLIC	??_C@_0BC@NDAFGNJG@Recalculate?5Walls?$AA@	; `string'
PUBLIC	??_C@_0BB@NOOMKGDN@Recalculate?5Path?$AA@	; `string'
PUBLIC	??_C@_0P@OPKEOGP@Visualise?5Path?$AA@		; `string'
PUBLIC	??_C@_0BD@ILICLLBG@Place?5Heavy?5Turret?$AA@	; `string'
PUBLIC	??_C@_0BE@CHBMJNCN@Place?5Medium?5Turret?$AA@	; `string'
PUBLIC	??_C@_0BD@GOKMAAEO@Place?5Light?5Turret?$AA@	; `string'
PUBLIC	??_C@_0BC@MANJMCAL@Visualise?5Turrets?$AA@	; `string'
PUBLIC	??_C@_0BG@FEONHGJL@Last?5Calculation?5Time?$AA@	; `string'
PUBLIC	??_C@_05DIOAMJFE@Files?$AA@			; `string'
PUBLIC	??_C@_0BJ@OBCGGGNI@?5Files?5position?$DN?8410?55?8?5?$AA@ ; `string'
PUBLIC	??_C@_0BA@ODBJHPLI@Reload?5Settings?$AA@	; `string'
PUBLIC	??_C@_0P@KLFADJFA@Write?5Settings?$AA@		; `string'
PUBLIC	??_C@_03NBOPHIOC@Map?$AA@			; `string'
PUBLIC	??_C@_0O@HOOOPNPM@Write?5map?5XML?$AA@		; `string'
PUBLIC	??_C@_0CG@PNBOIMLL@Final?5Project?5?9?5Project?5SPARTA?5?9@ ; `string'
PUBLIC	??_C@_04IHBDCLGJ@?5O?3?5?$AA@			; `string'
PUBLIC	??_C@_04JFKGIEIH@?5L?3?5?$AA@			; `string'
PUBLIC	??_C@_0BD@IBHNMNGC@Base?5Influence?5Map?$AA@	; `string'
PUBLIC	??_C@_0BF@IFJGMLAN@Base?52?5Influence?5Map?$AA@	; `string'
PUBLIC	??_C@_0M@PKLOLIMK@Square?5Cost?$AA@		; `string'
PUBLIC	??_C@_0BL@ELAJJFDJ@Heavy?5Turret?5Influence?5Map?$AA@ ; `string'
PUBLIC	??_C@_0BL@LIODDAAK@Light?5Turret?5Influence?5Map?$AA@ ; `string'
PUBLIC	??_C@_0BM@FFDBFNFB@Medium?5Turret?5Influence?5Map?$AA@ ; `string'
PUBLIC	??_C@_0BD@MPFDMOIL@Path?5Influence?5Map?$AA@	; `string'
PUBLIC	??_C@_0BD@KABNNPKE@Wall?5Influence?5Map?$AA@	; `string'
PUBLIC	??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@FLGJEDAL@?$AAD?$AAi?$AAs?$AAs?$AAe?$AAr?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_06KIJENJAF@fx_5_0?$AA@			; `string'
PUBLIC	??_C@_1CE@EDOLOMPE@?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AAh?$AAl?$AAs?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1MG@ICKGNNNA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf@ ; `string'
PUBLIC	??_C@_1DM@NILNGIMC@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AA?$AA@ ; `string'
PUBLIC	??_C@_04GHJNJNPO@main?$AA@			; `string'
PUBLIC	??_C@_1CC@NFHKBANH@?$AAP?$AAi?$AAx?$AAe?$AAl?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AAh?$AAl?$AAs?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1ME@MANEMGEF@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAi?$AAx?$AAe?$AAl?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi@ ; `string'
PUBLIC	??_C@_1DI@GKGJLLII@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAi?$AAx?$AAe?$AAl?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@GFEFGPPD@?$AA?4?$AA?1?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AAs?$AA?1?$AAT?$AAe?$AAc?$AAh?$AAn?$AAi?$AAq?$AAu?$AAe?$AA?4?$AAf?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@BFKLJCMH@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAe?$AAf?$AAf?$AAe?$AAc?$AAt?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_0N@BOAANELO@SingleColour?$AA@		; `string'
PUBLIC	??_C@_0M@JIFPIELG@WorldMatrix?$AA@		; `string'
PUBLIC	??_C@_0L@BCBAMPKD@ViewMatrix?$AA@		; `string'
PUBLIC	??_C@_0L@FHHLNBJL@ProjMatrix?$AA@		; `string'
PUBLIC	??_C@_0M@FMIDCGNI@ModelColour?$AA@		; `string'
PUBLIC	??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3cf5c28f
PUBLIC	__real@3d23d70a
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f490fdb
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40490fdb
PUBLIC	__real@41500000
PUBLIC	__real@41900000
PUBLIC	__real@41a00000
PUBLIC	__real@43340000
PUBLIC	__real@461c4000
PUBLIC	__real@4e396fca
PUBLIC	__real@c1700000
PUBLIC	__real@c2200000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy_s:PROC
EXTRN	_strcat_s:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_wcscpy_s:PROC
EXTRN	_wcslen:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__DefWindowProcW@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__RegisterClassExW@4:PROC
EXTRN	__imp__CreateWindowExW@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__AdjustWindowRect@12:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__LoadCursorW@8:PROC
EXTRN	__imp__LoadIconW@8:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_qsort:PROC
EXTRN	__itoa_s:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__recalloc:PROC
EXTRN	_D3D11CreateDeviceAndSwapChain@48:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	__hypot:PROC
EXTRN	__wassert:PROC
EXTRN	_swprintf_s:PROC
EXTRN	__vsnwprintf_s:PROC
EXTRN	__vswprintf_c_l:PROC
EXTRN	__vscwprintf:PROC
EXTRN	__CrtDbgReportW:PROC
EXTRN	?_Debug_message@std@@YAXPB_W0I@Z:PROC		; std::_Debug_message
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??0SpriteBatch@DirectX@@QAE@PAUID3D11DeviceContext@@@Z:PROC ; DirectX::SpriteBatch::SpriteBatch
EXTRN	?Begin@SpriteBatch@DirectX@@QAQXW4SpriteSortMode@2@PAUID3D11BlendState@@PAUID3D11SamplerState@@PAUID3D11DepthStencilState@@PAUID3D11RasterizerState@@V?$function@$$A6AXXZ@std@@UXMMATRIX@2@@Z:PROC ; DirectX::SpriteBatch::Begin
EXTRN	?End@SpriteBatch@DirectX@@QAAXXZ:PROC		; DirectX::SpriteBatch::End
EXTRN	??0SpriteFont@DirectX@@QAE@PAUID3D11Device@@PB_W@Z:PROC ; DirectX::SpriteFont::SpriteFont
EXTRN	?DrawString@SpriteFont@DirectX@@QAQXPAVSpriteBatch@2@PB_WABUXMFLOAT2@2@T__m128@@M22W4SpriteEffects@2@M@Z:PROC ; DirectX::SpriteFont::DrawString
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	_D3DX11CompileFromFileW@44:PROC
EXTRN	_D3DX11CreateEffectFromMemory@20:PROC
EXTRN	__imp__TwNewBar@4:PROC
EXTRN	__imp__TwAddVarRW@20:PROC
EXTRN	__imp__TwAddVarRO@20:PROC
EXTRN	__imp__TwAddButton@20:PROC
EXTRN	__imp__TwAddSeparator@12:PROC
EXTRN	__imp__TwDefine@4:PROC
EXTRN	__imp__TwInit@8:PROC
EXTRN	__imp__TwTerminate@0:PROC
EXTRN	__imp__TwDraw@0:PROC
EXTRN	__imp__TwWindowSize@8:PROC
EXTRN	__imp__TwGetLastError@0:PROC
EXTRN	__imp__TwEventWin@16:PROC
EXTRN	?XMF3ToFloat3@@YA?AUV3@@UXMFLOAT3@DirectX@@@Z:PROC ; XMF3ToFloat3
EXTRN	?KeyDownEvent@@YAXW4EKeyState@@@Z:PROC		; KeyDownEvent
EXTRN	?KeyUpEvent@@YAXW4EKeyState@@@Z:PROC		; KeyUpEvent
EXTRN	?KeyHit@@YA_NW4EKeyCode@@@Z:PROC		; KeyHit
EXTRN	?UpdateMatrix@CModel@@QAEXXZ:PROC		; CModel::UpdateMatrix
EXTRN	?Render@CModel@@QAEXPAUID3DX11EffectTechnique@@@Z:PROC ; CModel::Render
EXTRN	??0CCamera@@QAE@UXMFLOAT3@DirectX@@0MMM@Z:PROC	; CCamera::CCamera
EXTRN	?UpdateMatrices@CCamera@@QAEXXZ:PROC		; CCamera::UpdateMatrices
EXTRN	?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z:PROC ; CCamera::Control
EXTRN	?PixelFromWorldPt@CCamera@@QAE_NPAUXMFLOAT2@DirectX@@UXMFLOAT3@3@@Z:PROC ; CCamera::PixelFromWorldPt
EXTRN	??0MapSquare@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVSettingsManager@@@Z:PROC ; MapSquare::MapSquare
EXTRN	??1CLight@@QAE@XZ:PROC				; CLight::~CLight
EXTRN	?Update@CLight@@QAEXM@Z:PROC			; CLight::Update
EXTRN	??0CRenderObject@@QAE@QADUXMFLOAT3@DirectX@@1PAUID3DX11EffectTechnique@@2PAUID3D11ShaderResourceView@@3_N44@Z:PROC ; CRenderObject::CRenderObject
EXTRN	??1CRenderObject@@QAE@XZ:PROC			; CRenderObject::~CRenderObject
EXTRN	?SetColour@CRenderObject@@QAEXUXMFLOAT3@DirectX@@@Z:PROC ; CRenderObject::SetColour
EXTRN	?Update@CRenderObject@@QAEXM@Z:PROC		; CRenderObject::Update
EXTRN	?AddInstance@ModelBatch@@QAEPAUXMMATRIX@DirectX@@UXMFLOAT3@3@M@Z:PROC ; ModelBatch::AddInstance
EXTRN	?Load@ModelBatch@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3DX11EffectTechnique@@_N@Z:PROC ; ModelBatch::Load
EXTRN	?RenderBatch@ModelBatch@@QAEXPAUID3DX11EffectMatrixVariable@@PAUID3DX11EffectVectorVariable@@@Z:PROC ; ModelBatch::RenderBatch
EXTRN	??0ModelBatch@@QAE@XZ:PROC			; ModelBatch::ModelBatch
EXTRN	??1ModelBatch@@QAE@XZ:PROC			; ModelBatch::~ModelBatch
EXTRN	?ReloadSettings@@YGXPAX@Z:PROC			; ReloadSettings
EXTRN	?WriteSettings@@YGXPAX@Z:PROC			; WriteSettings
EXTRN	?CalculateWallIM@@YGXPAX@Z:PROC			; CalculateWallIM
EXTRN	?CalculatePath@@YGXPAX@Z:PROC			; CalculatePath
EXTRN	?TWVisualisePath@@YGXPAX@Z:PROC			; TWVisualisePath
EXTRN	?TwPlaceHeavyTurret@@YGXPAX@Z:PROC		; TwPlaceHeavyTurret
EXTRN	?TwPlaceMediumTurret@@YGXPAX@Z:PROC		; TwPlaceMediumTurret
EXTRN	?TwPlaceLightTurret@@YGXPAX@Z:PROC		; TwPlaceLightTurret
EXTRN	?TwVisualiseTurrets@@YGXPAX@Z:PROC		; TwVisualiseTurrets
EXTRN	?WriteMapXML@@YGXPAX@Z:PROC			; WriteMapXML
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?MatrixIdentity@SpriteBatch@DirectX@@0UXMMATRIX@2@B:BYTE ; DirectX::SpriteBatch::MatrixIdentity
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
EXTRN	?mpd3dDev@CModel@@0PAUID3D11Device@@A:DWORD	; CModel::mpd3dDev
EXTRN	?mp_d3dDeviceContext@CModel@@0PAUID3D11DeviceContext@@A:DWORD ; CModel::mp_d3dDeviceContext
EXTRN	?mViewportWidth@CCamera@@0HA:DWORD		; CCamera::mViewportWidth
EXTRN	?mViewportHeight@CCamera@@0HA:DWORD		; CCamera::mViewportHeight
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_BSS	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 028H DUP (?)	; ATL::_AtlComModule
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	8

_XAXIS	DB	010H DUP (?)
_YAXIS	DB	010H DUP (?)
_ZAXIS	DB	010H DUP (?)
_ORIGIN	DB	0cH DUP (?)
_NO_ROTATION DB	0cH DUP (?)
__BLACK	DB	0cH DUP (?)
__WHITE	DB	0cH DUP (?)
__RED	DB	0cH DUP (?)
__MRED	DB	0cH DUP (?)
__LRED	DB	0cH DUP (?)
__GREEN	DB	0cH DUP (?)
__ORANGE DB	0cH DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMTanEstCoefficients$initializer$ DD FLAT:??__Eg_XMTanEstCoefficients@DirectX@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c2200000
CONST	SEGMENT
__real@c2200000 DD 0c2200000r			; -40
CONST	ENDS
;	COMDAT __real@c1700000
CONST	SEGMENT
__real@c1700000 DD 0c1700000r			; -15
CONST	ENDS
;	COMDAT __real@4e396fca
CONST	SEGMENT
__real@4e396fca DD 04e396fcar			; 7.77778e+008
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41500000
CONST	SEGMENT
__real@41500000 DD 041500000r			; 13
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fdb
CONST	SEGMENT
__real@3f490fdb DD 03f490fdbr			; 0.785398
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3d23d70a
CONST	SEGMENT
__real@3d23d70a DD 03d23d70ar			; 0.04
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'p', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'c', 00H, 'o'
	DB	00H, 'l', 00H, 'l', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'n', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H, 'n'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FMIDCGNI@ModelColour?$AA@
CONST	SEGMENT
??_C@_0M@FMIDCGNI@ModelColour?$AA@ DB 'ModelColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHHLNBJL@ProjMatrix?$AA@
CONST	SEGMENT
??_C@_0L@FHHLNBJL@ProjMatrix?$AA@ DB 'ProjMatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCBAMPKD@ViewMatrix?$AA@
CONST	SEGMENT
??_C@_0L@BCBAMPKD@ViewMatrix?$AA@ DB 'ViewMatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIFPIELG@WorldMatrix?$AA@
CONST	SEGMENT
??_C@_0M@JIFPIELG@WorldMatrix?$AA@ DB 'WorldMatrix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOAANELO@SingleColour?$AA@
CONST	SEGMENT
??_C@_0N@BOAANELO@SingleColour?$AA@ DB 'SingleColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@BFKLJCMH@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAe?$AAf?$AAf?$AAe?$AAc?$AAt?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@BFKLJCMH@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAe?$AAf?$AAf?$AAe?$AAc?$AAt?$AAs?$AA?$AA@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'c', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ' ', 00H, 'e', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@GFEFGPPD@?$AA?4?$AA?1?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AAs?$AA?1?$AAT?$AAe?$AAc?$AAh?$AAn?$AAi?$AAq?$AAu?$AAe?$AA?4?$AAf?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@GFEFGPPD@?$AA?4?$AA?1?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AAs?$AA?1?$AAT?$AAe?$AAc?$AAh?$AAn?$AAi?$AAq?$AAu?$AAe?$AA?4?$AAf?$AAx?$AA?$AA@ DB '.'
	DB	00H, '/', 00H, 'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '/', 00H, 'T', 00H, 'e', 00H, 'c', 00H, 'h'
	DB	00H, 'n', 00H, 'i', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '.', 00H
	DB	'f', 00H, 'x', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@GKGJLLII@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAi?$AAx?$AAe?$AAl?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@GKGJLLII@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAi?$AAx?$AAe?$AAl?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?$AA@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'C', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ' ', 00H, 'P', 00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@MANEMGEF@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAi?$AAx?$AAe?$AAl?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi@
CONST	SEGMENT
??_C@_1ME@MANEMGEF@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAi?$AAx?$AAe?$AAl?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'P', 00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, ' ', 00H
	DB	'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'F', 00H, 'X', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 's', 00H, 'u'
	DB	00H, 'r', 00H, 'e', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H
	DB	'r', 00H, ' ', 00H, 'F', 00H, 'X', 00H, ' ', 00H, 'f', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 's', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'f', 00H
	DB	'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'a'
	DB	00H, 's', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@NFHKBANH@?$AAP?$AAi?$AAx?$AAe?$AAl?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AAh?$AAl?$AAs?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@NFHKBANH@?$AAP?$AAi?$AAx?$AAe?$AAl?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AAh?$AAl?$AAs?$AAl?$AA?$AA@ DB 'P'
	DB	00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 'S', 00H, 'h', 00H
	DB	'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'h', 00H, 'l'
	DB	00H, 's', 00H, 'l', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHJNJNPO@main?$AA@
CONST	SEGMENT
??_C@_04GHJNJNPO@main?$AA@ DB 'main', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@NILNGIMC@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@NILNGIMC@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AA?$AA@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'c', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ' ', 00H, 'V', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'e', 00H
	DB	'x', 00H, ' ', 00H, 'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, '.', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@ICKGNNNA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf@
CONST	SEGMENT
??_C@_1MG@ICKGNNNA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'V', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'e', 00H, 'x', 00H
	DB	' ', 00H, 'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 'F', 00H, 'X', 00H, ' ', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, '.', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 's'
	DB	00H, 'u', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'y', 00H, 'o', 00H
	DB	'u', 00H, 'r', 00H, ' ', 00H, 'F', 00H, 'X', 00H, ' ', 00H, 'f'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'f', 00H, 'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'a', 00H, 's', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H
	DB	's', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u'
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '.', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@ DB 'E', 00H, 'r', 00H
	DB	'r', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@EDOLOMPE@?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AAh?$AAl?$AAs?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@EDOLOMPE@?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AAh?$AAl?$AAs?$AAl?$AA?$AA@ DB 'V'
	DB	00H, 'e', 00H, 'r', 00H, 't', 00H, 'e', 00H, 'x', 00H, 'S', 00H
	DB	'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'h'
	DB	00H, 'l', 00H, 's', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KIJENJAF@fx_5_0?$AA@
CONST	SEGMENT
??_C@_06KIJENJAF@fx_5_0?$AA@ DB 'fx_5_0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@FLGJEDAL@?$AAD?$AAi?$AAs?$AAs?$AAe?$AAr?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@FLGJEDAL@?$AAD?$AAi?$AAs?$AAs?$AAe?$AAr?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?$AA@ DB 'D'
	DB	00H, 'i', 00H, 's', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'u', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KABNNPKE@Wall?5Influence?5Map?$AA@
CONST	SEGMENT
??_C@_0BD@KABNNPKE@Wall?5Influence?5Map?$AA@ DB 'Wall Influence Map', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MPFDMOIL@Path?5Influence?5Map?$AA@
CONST	SEGMENT
??_C@_0BD@MPFDMOIL@Path?5Influence?5Map?$AA@ DB 'Path Influence Map', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFDBFNFB@Medium?5Turret?5Influence?5Map?$AA@
CONST	SEGMENT
??_C@_0BM@FFDBFNFB@Medium?5Turret?5Influence?5Map?$AA@ DB 'Medium Turret '
	DB	'Influence Map', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LIODDAAK@Light?5Turret?5Influence?5Map?$AA@
CONST	SEGMENT
??_C@_0BL@LIODDAAK@Light?5Turret?5Influence?5Map?$AA@ DB 'Light Turret In'
	DB	'fluence Map', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ELAJJFDJ@Heavy?5Turret?5Influence?5Map?$AA@
CONST	SEGMENT
??_C@_0BL@ELAJJFDJ@Heavy?5Turret?5Influence?5Map?$AA@ DB 'Heavy Turret In'
	DB	'fluence Map', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKLOLIMK@Square?5Cost?$AA@
CONST	SEGMENT
??_C@_0M@PKLOLIMK@Square?5Cost?$AA@ DB 'Square Cost', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IFJGMLAN@Base?52?5Influence?5Map?$AA@
CONST	SEGMENT
??_C@_0BF@IFJGMLAN@Base?52?5Influence?5Map?$AA@ DB 'Base 2 Influence Map', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IBHNMNGC@Base?5Influence?5Map?$AA@
CONST	SEGMENT
??_C@_0BD@IBHNMNGC@Base?5Influence?5Map?$AA@ DB 'Base Influence Map', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFKGIEIH@?5L?3?5?$AA@
CONST	SEGMENT
??_C@_04JFKGIEIH@?5L?3?5?$AA@ DB ' L: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHBDCLGJ@?5O?3?5?$AA@
CONST	SEGMENT
??_C@_04IHBDCLGJ@?5O?3?5?$AA@ DB ' O: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PNBOIMLL@Final?5Project?5?9?5Project?5SPARTA?5?9@
CONST	SEGMENT
??_C@_0CG@PNBOIMLL@Final?5Project?5?9?5Project?5SPARTA?5?9@ DB 'Final Pro'
	DB	'ject - Project SPARTA - FPS:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HOOOPNPM@Write?5map?5XML?$AA@
CONST	SEGMENT
??_C@_0O@HOOOPNPM@Write?5map?5XML?$AA@ DB 'Write map XML', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NBOPHIOC@Map?$AA@
CONST	SEGMENT
??_C@_03NBOPHIOC@Map?$AA@ DB 'Map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KLFADJFA@Write?5Settings?$AA@
CONST	SEGMENT
??_C@_0P@KLFADJFA@Write?5Settings?$AA@ DB 'Write Settings', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ODBJHPLI@Reload?5Settings?$AA@
CONST	SEGMENT
??_C@_0BA@ODBJHPLI@Reload?5Settings?$AA@ DB 'Reload Settings', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OBCGGGNI@?5Files?5position?$DN?8410?55?8?5?$AA@
CONST	SEGMENT
??_C@_0BJ@OBCGGGNI@?5Files?5position?$DN?8410?55?8?5?$AA@ DB ' Files posi'
	DB	'tion=''410 5'' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIOAMJFE@Files?$AA@
CONST	SEGMENT
??_C@_05DIOAMJFE@Files?$AA@ DB 'Files', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FEONHGJL@Last?5Calculation?5Time?$AA@
CONST	SEGMENT
??_C@_0BG@FEONHGJL@Last?5Calculation?5Time?$AA@ DB 'Last Calculation Time'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MANJMCAL@Visualise?5Turrets?$AA@
CONST	SEGMENT
??_C@_0BC@MANJMCAL@Visualise?5Turrets?$AA@ DB 'Visualise Turrets', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GOKMAAEO@Place?5Light?5Turret?$AA@
CONST	SEGMENT
??_C@_0BD@GOKMAAEO@Place?5Light?5Turret?$AA@ DB 'Place Light Turret', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHBMJNCN@Place?5Medium?5Turret?$AA@
CONST	SEGMENT
??_C@_0BE@CHBMJNCN@Place?5Medium?5Turret?$AA@ DB 'Place Medium Turret', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ILICLLBG@Place?5Heavy?5Turret?$AA@
CONST	SEGMENT
??_C@_0BD@ILICLLBG@Place?5Heavy?5Turret?$AA@ DB 'Place Heavy Turret', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OPKEOGP@Visualise?5Path?$AA@
CONST	SEGMENT
??_C@_0P@OPKEOGP@Visualise?5Path?$AA@ DB 'Visualise Path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NOOMKGDN@Recalculate?5Path?$AA@
CONST	SEGMENT
??_C@_0BB@NOOMKGDN@Recalculate?5Path?$AA@ DB 'Recalculate Path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NDAFGNJG@Recalculate?5Walls?$AA@
CONST	SEGMENT
??_C@_0BC@NDAFGNJG@Recalculate?5Walls?$AA@ DB 'Recalculate Walls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JIMFFDAA@?5Calculations?5position?$DN?8205?55?8?5?$AA@
CONST	SEGMENT
??_C@_0CA@JIMFFDAA@?5Calculations?5position?$DN?8205?55?8?5?$AA@ DB ' Cal'
	DB	'culations position=''205 5'' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BCBLNKGN@Calculations?$AA@
CONST	SEGMENT
??_C@_0N@BCBLNKGN@Calculations?$AA@ DB 'Calculations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HKLMEJGE@ChokeThreshold?$AA@
CONST	SEGMENT
??_C@_0P@HKLMEJGE@ChokeThreshold?$AA@ DB 'ChokeThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GHPNPPOJ@Maximum?5Path?5Length?$AA@
CONST	SEGMENT
??_C@_0BE@GHPNPPOJ@Maximum?5Path?5Length?$AA@ DB 'Maximum Path Length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BKJMPLKA@min?$DN0?41?5max?$DN0?49?5step?$DN0?41?$AA@
CONST	SEGMENT
??_C@_0BJ@BKJMPLKA@min?$DN0?41?5max?$DN0?49?5step?$DN0?41?$AA@ DB 'min=0.'
	DB	'1 max=0.9 step=0.1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EOIDACPB@Minimum?5Path?5Length?$AA@
CONST	SEGMENT
??_C@_0BE@EOIDACPB@Minimum?5Path?5Length?$AA@ DB 'Minimum Path Length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HEBLKGAH@Light?5Turret?5Range?$AA@
CONST	SEGMENT
??_C@_0BD@HEBLKGAH@Light?5Turret?5Range?$AA@ DB 'Light Turret Range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LFFKHKAN@Medium?5Turret?5Range?$AA@
CONST	SEGMENT
??_C@_0BE@LFFKHKAN@Medium?5Turret?5Range?$AA@ DB 'Medium Turret Range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMBFNPNO@Heavy?5Turret?5Range?$AA@
CONST	SEGMENT
??_C@_0BD@BMBFNPNO@Heavy?5Turret?5Range?$AA@ DB 'Heavy Turret Range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBBONMFG@Base?5Range?$AA@
CONST	SEGMENT
??_C@_0L@NBBONMFG@Base?5Range?$AA@ DB 'Base Range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GCIJCCFE@Wall?5Range?$AA@
CONST	SEGMENT
??_C@_0L@GCIJCCFE@Wall?5Range?$AA@ DB 'Wall Range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JKDJKFPL@AI?5?9?5requires?5recalcualte?$AA@
CONST	SEGMENT
??_C@_0BK@JKDJKFPL@AI?5?9?5requires?5recalcualte?$AA@ DB 'AI - requires r'
	DB	'ecalcualte', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FKPPMPAC@Spline?5Scale?$AA@
CONST	SEGMENT
??_C@_0N@FKPPMPAC@Spline?5Scale?$AA@ DB 'Spline Scale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EPBODBBM@Spline?5Model?$AA@
CONST	SEGMENT
??_C@_0N@EPBODBBM@Spline?5Model?$AA@ DB 'Spline Model', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OIMGCOOI@Node?5Scale?$AA@
CONST	SEGMENT
??_C@_0L@OIMGCOOI@Node?5Scale?$AA@ DB 'Node Scale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PNCHNAPG@Node?5Model?$AA@
CONST	SEGMENT
??_C@_0L@PNCHNAPG@Node?5Model?$AA@ DB 'Node Model', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMLNEAGG@ResolutionY?$AA@
CONST	SEGMENT
??_C@_0M@JMLNEAGG@ResolutionY?$AA@ DB 'ResolutionY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IFKGHBCH@ResolutionX?$AA@
CONST	SEGMENT
??_C@_0M@IFKGHBCH@ResolutionX?$AA@ DB 'ResolutionX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GIBHHGMJ@Graphics?5?9?5requires?5restart?$AA@
CONST	SEGMENT
??_C@_0BM@GIBHHGMJ@Graphics?5?9?5requires?5restart?$AA@ DB 'Graphics - re'
	DB	'quires restart', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MLELINGD@?5Settings?5position?$DN?85?55?8?5?$AA@
CONST	SEGMENT
??_C@_0BK@MLELINGD@?5Settings?5position?$DN?85?55?8?5?$AA@ DB ' Settings '
	DB	'position=''5 5'' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEOHOBEO@Settings?$AA@
CONST	SEGMENT
??_C@_08EEOHOBEO@Settings?$AA@ DB 'Settings', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BMAIPOBA@?$AAA?$AAr?$AAi?$AAa?$AAl?$AA?4?$AAs?$AAp?$AAr?$AAi?$AAt?$AAe?$AAf?$AAo?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BMAIPOBA@?$AAA?$AAr?$AAi?$AAa?$AAl?$AA?4?$AAs?$AAp?$AAr?$AAi?$AAt?$AAe?$AAf?$AAo?$AAn?$AAt?$AA?$AA@ DB 'A'
	DB	00H, 'r', 00H, 'i', 00H, 'a', 00H, 'l', 00H, '.', 00H, 's', 00H
	DB	'p', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'f', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEMGLHJD@Sphere?4x?$AA@
CONST	SEGMENT
??_C@_08EEMGLHJD@Sphere?4x?$AA@ DB 'Sphere.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MAAOBHJP@TrafficCone?4x?$AA@
CONST	SEGMENT
??_C@_0O@MAAOBHJP@TrafficCone?4x?$AA@ DB 'TrafficCone.x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGKAGIBP@Cube?4x?$AA@
CONST	SEGMENT
??_C@_06HGKAGIBP@Cube?4x?$AA@ DB 'Cube.x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FLNEJKFD@bob?$AA@
CONST	SEGMENT
??_C@_03FLNEJKFD@bob?$AA@ DB 'bob', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15KNBIKKIN@?$AA?$CF?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_15KNBIKKIN@?$AA?$CF?$AAd?$AA?$AA@ DB '%', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ DB 'E'
	DB	00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, ' ', 00H, ':', 00H
	DB	' ', 00H, 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'i', 00H, 'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'A', 00H, 't', 00H, 'l', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 0aH
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA DD 020e1H ; `ATL::AtlWinModuleInit'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@ DB 'E'
	DB	00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, ' ', 00H, ':', 00H
	DB	' ', 00H, 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'i', 00H, 'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'C', 00H, 'A', 00H, 't', 00H, 'l'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'u', 00H, 'l', 00H, 'e', 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
CONST	SEGMENT
??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ DB 'c:\pr'
	DB	'ogram files (x86)\microsoft visual studio 12.0\vc\atlmfc\incl'
	DB	'ude\atlbase.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '.', 00H, 'h'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@ DB '_'
	DB	00H, '_', 00H, 'a', 00H, 't', 00H, 'l', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 'd', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT ??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@ DB 'A'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'o', 00H
	DB	'w', 00H, ':', 00H, ' ', 00H, 'h', 00H, 'r', 00H, ' ', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'x', 00H, 0aH, 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
CONST	SEGMENT
??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ DB 'c:\pr'
	DB	'ogram files (x86)\microsoft visual studio 12.0\vc\atlmfc\incl'
	DB	'ude\atlexcept.h', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA DD 041H	; `ATL::AtlThrowImpl'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@
CONST	SEGMENT
??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@ DB 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'd', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@ DB '%', 00H, 'S', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H
	DB	'%', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 'u'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 's'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'i'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm', 00H, 'p'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'v'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o'
	DB	00H, 'l', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'v', 00H, '.', 00H, 'h'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@2@T__m128@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@2@T__m128@@@Z@4JA DD 0631H ; `DirectX::XMStoreFloat4'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BK@FHLBGAOP@?$AAp?$AAD?$AAe?$AAs?$AAt?$AAi?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@FHLBGAOP@?$AAp?$AAD?$AAe?$AAs?$AAt?$AAi?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'p'
	DB	00H, 'D', 00H, 'e', 00H, 's', 00H, 't', 00H, 'i', 00H, 'n', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JE@DMOBBMDE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?5?$AAk@
CONST	SEGMENT
??_C@_1JE@DMOBBMDE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?5?$AAk@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, 'k', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, '\', 00H, '8', 00H, '.', 00H, '1', 00H, '\'
	DB	00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 'u', 00H, 'm', 00H, '\', 00H, 'd', 00H, 'i'
	DB	00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'x', 00H, 'm', 00H
	DB	'a', 00H, 't', 00H, 'h', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 't', 00H, '.', 00H, 'i', 00H, 'n', 00H
	DB	'l', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B	ORG $+16 ; DirectX::g_XMReciprocalTwoPi
_DATA	ENDS
;	COMDAT ?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B	ORG $+16		; DirectX::g_XMTwoPi
_DATA	ENDS
;	COMDAT ?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B	ORG $+16	; DirectX::g_XMReciprocalPi
_DATA	ENDS
;	COMDAT ?g_XMPi@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMPi@DirectX@@3UXMVECTORF32@1@B	ORG $+16		; DirectX::g_XMPi
_DATA	ENDS
;	COMDAT ?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B	ORG $+16		; DirectX::g_XMHalfPi
_DATA	ENDS
;	COMDAT ?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B	ORG $+16	; DirectX::g_XMNegativePi
_DATA	ENDS
;	COMDAT ?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B	ORG $+16	; DirectX::g_XMNegativeTwoPi
_DATA	ENDS
;	COMDAT ?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B	ORG $+16	; DirectX::g_XMPiConstants0
_DATA	ENDS
;	COMDAT ?g_XMTanEstCoefficients@DirectX@@3UXMVECTORF32@1@B
_DATA	SEGMENT
?g_XMTanEstCoefficients@DirectX@@3UXMVECTORF32@1@B DD 0401ef9dbr ; 2.484 ; DirectX::g_XMTanEstCoefficients
	DD	0be482f23r			; -0.195492
	DD	0401de9e6r			; 2.4674
	ORG $+4
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?InitScene@CScene@@QAE_NXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?InitScene@CScene@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?InitScene@CScene@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$13
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CScene@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1CScene@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CScene@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CScene@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CScene@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CScene@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CScene@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CScene@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CScene@@QAE@XZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CScene@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CScene@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CScene@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CScene@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CScene@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CScene@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CScene@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CScene@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CScene@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CScene@@QAE@XZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAtlWinModule@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$0
__ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAtlWinModule@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAtlComModule@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CAtlComModule@ATL@@QAE@XZ$0
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAtlComModule@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
__ehfuncinfo$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
__ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z$0
__ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMPiConstants0$initializer$ DD FLAT:??__Eg_XMPiConstants0@DirectX@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMNegativeTwoPi$initializer$ DD FLAT:??__Eg_XMNegativeTwoPi@DirectX@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMNegativePi$initializer$ DD FLAT:??__Eg_XMNegativePi@DirectX@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMHalfPi$initializer$ DD FLAT:??__Eg_XMHalfPi@DirectX@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMPi$initializer$ DD FLAT:??__Eg_XMPi@DirectX@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMReciprocalPi$initializer$ DD FLAT:??__Eg_XMReciprocalPi@DirectX@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMTwoPi$initializer$ DD FLAT:??__Eg_XMTwoPi@DirectX@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_g_XMReciprocalTwoPi$initializer$ DD FLAT:??__Eg_XMReciprocalTwoPi@DirectX@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceGeneral$initializer$ DD FLAT:??__EatlTraceGeneral@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceCOM$initializer$ DD FLAT:??__EatlTraceCOM@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceQI$initializer$ DD FLAT:??__EatlTraceQI@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceRegistrar$initializer$ DD FLAT:??__EatlTraceRegistrar@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceRefcount$initializer$ DD FLAT:??__EatlTraceRefcount@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceWindowing$initializer$ DD FLAT:??__EatlTraceWindowing@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceControls$initializer$ DD FLAT:??__EatlTraceControls@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceHosting$initializer$ DD FLAT:??__EatlTraceHosting@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceDBClient$initializer$ DD FLAT:??__EatlTraceDBClient@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceDBProvider$initializer$ DD FLAT:??__EatlTraceDBProvider@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSnapin$initializer$ DD FLAT:??__EatlTraceSnapin@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceNotImpl$initializer$ DD FLAT:??__EatlTraceNotImpl@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceAllocation$initializer$ DD FLAT:??__EatlTraceAllocation@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceException$initializer$ DD FLAT:??__EatlTraceException@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceTime$initializer$ DD FLAT:??__EatlTraceTime@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceCache$initializer$ DD FLAT:??__EatlTraceCache@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceStencil$initializer$ DD FLAT:??__EatlTraceStencil@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceString$initializer$ DD FLAT:??__EatlTraceString@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceMap$initializer$ DD FLAT:??__EatlTraceMap@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceUtil$initializer$ DD FLAT:??__EatlTraceUtil@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSecurity$initializer$ DD FLAT:??__EatlTraceSecurity@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceSync$initializer$ DD FLAT:??__EatlTraceSync@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceISAPI$initializer$ DD FLAT:??__EatlTraceISAPI@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
__AtlComModule$initializer$ DD FLAT:??__E_AtlComModule@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
__AtlWinModule$initializer$ DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
	ORG $-16
_XAXIS$initializer$ DD FLAT:??__EXAXIS@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_YAXIS$initializer$ DD FLAT:??__EYAXIS@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ZAXIS$initializer$ DD FLAT:??__EZAXIS@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ORIGIN$initializer$ DD FLAT:??__EORIGIN@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_NO_ROTATION$initializer$ DD FLAT:??__ENO_ROTATION@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__BLACK$initializer$ DD FLAT:??__E_BLACK@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__WHITE$initializer$ DD FLAT:??__E_WHITE@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__RED$initializer$ DD FLAT:??__E_RED@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__MRED$initializer$ DD FLAT:??__E_MRED@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__LRED$initializer$ DD FLAT:??__E_LRED@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__GREEN$initializer$ DD FLAT:??__E_GREEN@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__ORANGE$initializer$ DD FLAT:??__E_ORANGE@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z
_TEXT	SEGMENT
tv129 = -244						; size = 4
tv81 = -244						; size = 4
tv65 = -244						; size = 4
_ppReallocBuf$1 = -44					; size = 4
___atl_condVal$2 = -32					; size = 4
___atl_condVal$3 = -20					; size = 4
___atl_condVal$4 = -8					; size = 4
_ppBuff$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pszFixedBuffer$ = 16					; size = 4
_nFixedBufferLength$ = 20				; size = 4
??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z PROC	; ATL::AtlConvAllocMemory<wchar_t>, COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN29@AtlConvAll:

; 120  : 	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);

	cmp	DWORD PTR _ppBuff$[ebp], 0
	je	SHORT $LN32@AtlConvAll
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN33@AtlConvAll
$LN32@AtlConvAll:
	mov	DWORD PTR tv65[ebp], 0
$LN33@AtlConvAll:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR ___atl_condVal$4[ebp], eax
$LN26@AtlConvAll:
	cmp	DWORD PTR ___atl_condVal$4[ebp], 0
	jne	SHORT $LN25@AtlConvAll
	push	OFFSET ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	120					; 00000078H
	push	OFFSET ??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN25@AtlConvAll
	int	3
$LN25@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN26@AtlConvAll
	cmp	DWORD PTR ___atl_condVal$4[ebp], 0
	jne	SHORT $LN28@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN28@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN29@AtlConvAll
$LN22@AtlConvAll:

; 121  : 	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);

	cmp	DWORD PTR _nLength$[ebp], 0
	jl	SHORT $LN35@AtlConvAll
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN36@AtlConvAll
$LN35@AtlConvAll:
	mov	DWORD PTR tv81[ebp], 0
$LN36@AtlConvAll:
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR ___atl_condVal$3[ebp], eax
$LN19@AtlConvAll:
	cmp	DWORD PTR ___atl_condVal$3[ebp], 0
	jne	SHORT $LN18@AtlConvAll
	push	OFFSET ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	121					; 00000079H
	push	OFFSET ??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN18@AtlConvAll
	int	3
$LN18@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN19@AtlConvAll
	cmp	DWORD PTR ___atl_condVal$3[ebp], 0
	jne	SHORT $LN21@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN21@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN22@AtlConvAll
$LN15@AtlConvAll:

; 122  : 	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

	cmp	DWORD PTR _pszFixedBuffer$[ebp], 0
	je	SHORT $LN38@AtlConvAll
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN39@AtlConvAll
$LN38@AtlConvAll:
	mov	DWORD PTR tv129[ebp], 0
$LN39@AtlConvAll:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR ___atl_condVal$2[ebp], eax
$LN12@AtlConvAll:
	cmp	DWORD PTR ___atl_condVal$2[ebp], 0
	jne	SHORT $LN11@AtlConvAll
	push	OFFSET ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	122					; 0000007aH
	push	OFFSET ??_C@_1KA@BPMCHGPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN11@AtlConvAll
	int	3
$LN11@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN12@AtlConvAll
	cmp	DWORD PTR ___atl_condVal$2[ebp], 0
	jne	SHORT $LN14@AtlConvAll
	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN14@AtlConvAll:
	xor	eax, eax
	jne	SHORT $LN15@AtlConvAll

; 123  : 
; 124  : 	//if buffer malloced, try to realloc.
; 125  : 	if (*ppBuff != pszFixedBuffer)

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _pszFixedBuffer$[ebp]
	je	SHORT $LN8@AtlConvAll

; 126  : 	{
; 127  : 		if( nLength > nFixedBufferLength )

	mov	eax, DWORD PTR _nLength$[ebp]
	cmp	eax, DWORD PTR _nFixedBufferLength$[ebp]
	jle	SHORT $LN7@AtlConvAll

; 128  : 		{
; 129  : 			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );

	push	2
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppBuff$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__recalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ppReallocBuf$1[ebp], eax

; 130  : 			if (ppReallocBuf == NULL) 

	cmp	DWORD PTR _ppReallocBuf$1[ebp], 0
	jne	SHORT $LN6@AtlConvAll

; 131  : 			{
; 132  : 				AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN6@AtlConvAll:

; 133  : 			}
; 134  : 			*ppBuff = ppReallocBuf;

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR _ppReallocBuf$1[ebp]
	mov	DWORD PTR [eax], ecx

; 135  : 		} else

	jmp	SHORT $LN5@AtlConvAll
$LN7@AtlConvAll:

; 136  : 		{
; 137  : 			free(*ppBuff);

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 138  : 			*ppBuff=pszFixedBuffer;

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR _pszFixedBuffer$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@AtlConvAll:

; 139  : 		}
; 140  : 
; 141  : 	} else //Buffer is not currently malloced.

	jmp	SHORT $LN4@AtlConvAll
$LN8@AtlConvAll:

; 142  : 	{
; 143  : 		if( nLength > nFixedBufferLength )

	mov	eax, DWORD PTR _nLength$[ebp]
	cmp	eax, DWORD PTR _nFixedBufferLength$[ebp]
	jle	SHORT $LN3@AtlConvAll

; 144  : 		{
; 145  : 			*ppBuff = static_cast< _CharType* >( calloc(nLength,sizeof( _CharType ) ) );

	push	2
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _ppBuff$[ebp]
	mov	DWORD PTR [ecx], eax

; 146  : 		} else

	jmp	SHORT $LN4@AtlConvAll
$LN3@AtlConvAll:

; 147  : 		{			
; 148  : 			*ppBuff=pszFixedBuffer;

	mov	eax, DWORD PTR _ppBuff$[ebp]
	mov	ecx, DWORD PTR _pszFixedBuffer$[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@AtlConvAll:

; 149  : 		}
; 150  : 	}
; 151  : 
; 152  : 	if (*ppBuff == NULL)

	mov	eax, DWORD PTR _ppBuff$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN31@AtlConvAll

; 153  : 	{
; 154  : 		AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN31@AtlConvAll:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ENDP	; ATL::AtlConvAllocMemory<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
_pszFixedBuffer$ = 12					; size = 4
_nFixedBufferLength$ = 16				; size = 4
??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z PROC		; ATL::AtlConvFreeMemory<wchar_t>, COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 164  : 	(nFixedBufferLength);
; 165  : 	if( pBuff != pszFixedBuffer )

	mov	eax, DWORD PTR _pBuff$[ebp]
	cmp	eax, DWORD PTR _pszFixedBuffer$[ebp]
	je	SHORT $LN2@AtlConvFre

; 166  : 	{
; 167  : 		free( pBuff );

	mov	eax, DWORD PTR _pBuff$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 168  : 	} 	
; 169  : #ifdef _DEBUG
; 170  : 	else

	jmp	SHORT $LN3@AtlConvFre
$LN2@AtlConvFre:

; 171  : 	{		
; 172  : 		memset(pszFixedBuffer,ATLCONV_DEADLAND_FILL,nFixedBufferLength*sizeof(_CharType));

	mov	eax, DWORD PTR _nFixedBufferLength$[ebp]
	shl	eax, 1
	push	eax
	push	254					; 000000feH
	mov	ecx, DWORD PTR _pszFixedBuffer$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN3@AtlConvFre:

; 173  : 	}
; 174  : #endif
; 175  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z ENDP		; ATL::AtlConvFreeMemory<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z
_TEXT	SEGMENT
tv142 = -244						; size = 4
tv84 = -244						; size = 4
_bFailed$ = -44						; size = 4
_nLengthW$ = -32					; size = 4
_nLengthA$ = -20					; size = 4
_this$ = -8						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z PROC		; ATL::CA2WEX<128>::Init, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if (psz == NULL)

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $LN4@Init

; 378  : 		{
; 379  : 			m_psz = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 380  : 			return;

	jmp	$LN6@Init
$LN4@Init:

; 381  : 		}
; 382  : 		int nLengthA = static_cast<int>(strlen( psz ))+1;

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _nLengthA$[ebp], eax

; 383  : 		int nLengthW = nLengthA;

	mov	eax, DWORD PTR _nLengthA$[ebp]
	mov	DWORD PTR _nLengthW$[ebp], eax

; 384  : 
; 385  : 		AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _nLengthW$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ; ATL::AtlConvAllocMemory<wchar_t>
	add	esp, 16					; 00000010H

; 386  : 
; 387  : 		BOOL bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );

	mov	esi, esp
	mov	eax, DWORD PTR _nLengthW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN7@Init
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN8@Init
$LN7@Init:
	mov	DWORD PTR tv84[ebp], 0
$LN8@Init:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR _bFailed$[ebp], eax

; 388  : 		if (bFailed)

	cmp	DWORD PTR _bFailed$[ebp], 0
	je	$LN3@Init

; 389  : 		{
; 390  : 			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 122				; 0000007aH
	jne	$LN3@Init

; 391  : 			{
; 392  : 				nLengthW = ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nLengthW$[ebp], eax

; 393  : ATLPREFAST_SUPPRESS(6102)                
; 394  : 				AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _nLengthW$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ; ATL::AtlConvAllocMemory<wchar_t>
	add	esp, 16					; 00000010H

; 395  : ATLPREFAST_UNSUPPRESS()
; 396  : 				bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );

	mov	esi, esp
	mov	eax, DWORD PTR _nLengthW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN9@Init
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN10@Init
$LN9@Init:
	mov	DWORD PTR tv142[ebp], 0
$LN10@Init:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR _bFailed$[ebp], eax
$LN3@Init:

; 397  : 			}			
; 398  : 		}
; 399  : 		if (bFailed)

	cmp	DWORD PTR _bFailed$[ebp], 0
	je	SHORT $LN6@Init

; 400  : 		{
; 401  : 			AtlThrowLastWin32();

	call	?AtlThrowLastWin32@ATL@@YGXXZ		; ATL::AtlThrowLastWin32
$LN6@Init:

; 402  : 		}		
; 403  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z ENDP		; ATL::CA2WEX<128>::Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ PROC			; ATL::CA2WEX<128>::operator wchar_t *, COMDAT
; _this$ = ecx

; 368  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return( m_psz );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ ENDP			; ATL::CA2WEX<128>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??1?$CA2WEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CA2WEX@$0IA@@ATL@@QAE@XZ PROC			; ATL::CA2WEX<128>::~CA2WEX<128>, COMDAT
; _this$ = ecx

; 363  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z ; ATL::AtlConvFreeMemory<wchar_t>
	add	esp, 12					; 0000000cH

; 365  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CA2WEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CA2WEX<128>::~CA2WEX<128>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_psz$ = 8						; size = 4
??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z PROC			; ATL::CA2WEX<128>::CA2WEX<128>, COMDAT
; _this$ = ecx

; 352  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 353  : 		Init( psz, _AtlGetConversionACP() );

	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z	; ATL::CA2WEX<128>::Init

; 354  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z ENDP			; ATL::CA2WEX<128>::CA2WEX<128>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Source$ = 12						; size = 4
??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z PROC		; strcat_s<100>, COMDAT

; 116  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcat_s, char, _Dest, _In_z_ const char *, _Source)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Source$[ebp]
	push	eax
	push	100					; 00000064H
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	_strcat_s
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z ENDP		; strcat_s<100>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
;	COMDAT ??$_itoa_s@$05@@YAHHAAY05DH@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Radix$ = 16						; size = 4
??$_itoa_s@$05@@YAHHAAY05DH@Z PROC			; _itoa_s<6>, COMDAT

; 480  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Radix$[ebp]
	push	eax
	push	6
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Value$[ebp]
	push	edx
	call	__itoa_s
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_itoa_s@$05@@YAHHAAY05DH@Z ENDP			; _itoa_s<6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Source$ = 12						; size = 4
??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z PROC		; strcpy_s<100>, COMDAT

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Source$[ebp]
	push	eax
	push	100					; 00000064H
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	_strcpy_s
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z ENDP		; strcpy_s<100>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?VisualiseTurrets@CScene@@QAEXXZ
_TEXT	SEGMENT
$T1 = -296						; size = 12
$T2 = -276						; size = 12
$T3 = -256						; size = 12
_i$4 = -44						; size = 4
_i$5 = -32						; size = 4
_i$6 = -20						; size = 4
_this$ = -8						; size = 4
?VisualiseTurrets@CScene@@QAEXXZ PROC			; CScene::VisualiseTurrets, COMDAT
; _this$ = ecx

; 1114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1115 : 	mp_heavyTurretModel.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	call	?Reset@ModelBatch@@QAEXXZ		; ModelBatch::Reset

; 1116 : 	
; 1117 : 	
; 1118 : 	for (uint32_t i = 0; i < mc_map->mi_heavyTurretCount; i++)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN9@VisualiseT
$LN8@VisualiseT:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN9@VisualiseT:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _i$6[ebp]
	cmp	edx, DWORD PTR [ecx+37332]
	jae	$LN7@VisualiseT

; 1119 : 	{
; 1120 : 		mp_heavyTurretModel.AddInstance(
; 1121 : 			DirectX::XMFLOAT3(mc_map->ms_heavyTurrets[i].x, 1.0f, mc_map->ms_heavyTurrets[i].y),
; 1122 : 			0.05f
; 1123 : 			);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	edx, DWORD PTR _i$6[ebp], 20
	cvtsi2ss xmm0, DWORD PTR [ecx+edx+36936]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	edx, DWORD PTR _i$6[ebp], 20
	cvtsi2ss xmm0, DWORD PTR [ecx+edx+36932]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	call	?AddInstance@ModelBatch@@QAEPAUXMMATRIX@DirectX@@UXMFLOAT3@3@M@Z ; ModelBatch::AddInstance

; 1124 : 	}

	jmp	$LN8@VisualiseT
$LN7@VisualiseT:

; 1125 : 
; 1126 : 	mp_mediumTurretModel.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	call	?Reset@ModelBatch@@QAEXXZ		; ModelBatch::Reset

; 1127 : 
; 1128 : 	for (uint32_t i = 0; i < mc_map->mi_mediumTurretCount; i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN6@VisualiseT
$LN5@VisualiseT:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN6@VisualiseT:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _i$5[ebp]
	cmp	edx, DWORD PTR [ecx+38140]
	jae	$LN4@VisualiseT

; 1129 : 	{
; 1130 : 		mp_mediumTurretModel.AddInstance(DirectX::XMFLOAT3(mc_map->ms_mediumTurrets[i].x, 1.0f, mc_map->ms_mediumTurrets[i].y),
; 1131 : 			0.04f
; 1132 : 			);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d23d70a
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	edx, DWORD PTR _i$5[ebp], 20
	cvtsi2ss xmm0, DWORD PTR [ecx+edx+37744]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	edx, DWORD PTR _i$5[ebp], 20
	cvtsi2ss xmm0, DWORD PTR [ecx+edx+37740]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	call	?AddInstance@ModelBatch@@QAEPAUXMMATRIX@DirectX@@UXMFLOAT3@3@M@Z ; ModelBatch::AddInstance

; 1133 : 	}

	jmp	$LN5@VisualiseT
$LN4@VisualiseT:

; 1134 : 
; 1135 : 	mp_lightTurretModel.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388368				; 0005ed10H
	call	?Reset@ModelBatch@@QAEXXZ		; ModelBatch::Reset

; 1136 : 
; 1137 : 	for (uint32_t i = 0; i < mc_map->mi_lightTurretCount; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN3@VisualiseT
$LN2@VisualiseT:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN3@VisualiseT:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _i$4[ebp]
	cmp	edx, DWORD PTR [ecx+37736]
	jae	$LN1@VisualiseT

; 1138 : 	{
; 1139 : 		mp_lightTurretModel.AddInstance(DirectX::XMFLOAT3(mc_map->ms_lightTurrets[i].x, 1.0f, mc_map->ms_lightTurrets[i].y),
; 1140 : 			0.03f
; 1141 : 			);

	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	edx, DWORD PTR _i$4[ebp], 20
	cvtsi2ss xmm0, DWORD PTR [ecx+edx+37340]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	imul	edx, DWORD PTR _i$4[ebp], 20
	cvtsi2ss xmm0, DWORD PTR [ecx+edx+37336]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388368				; 0005ed10H
	call	?AddInstance@ModelBatch@@QAEPAUXMMATRIX@DirectX@@UXMFLOAT3@3@M@Z ; ModelBatch::AddInstance

; 1142 : 	}

	jmp	$LN2@VisualiseT
$LN1@VisualiseT:

; 1143 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?VisualiseTurrets@CScene@@QAEXXZ ENDP			; CScene::VisualiseTurrets
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z
_TEXT	SEGMENT
_rc$ = -92						; size = 16
_wcex$ = -68						; size = 48
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z PROC	; CScene::InitWindow, COMDAT
; _this$ = ecx

; 563  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 	// Register class
; 565  : 	WNDCLASSEX wcex;
; 566  : 	wcex.cbSize = sizeof( WNDCLASSEX );

	mov	DWORD PTR _wcex$[ebp], 48		; 00000030H

; 567  : 	wcex.style = CS_HREDRAW | CS_VREDRAW;

	mov	DWORD PTR _wcex$[ebp+4], 3

; 568  : 	wcex.lpfnWndProc = CScene::WndProc;

	mov	DWORD PTR _wcex$[ebp+8], OFFSET ?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z ; CScene::WndProc

; 569  : 	wcex.cbClsExtra = 0;

	mov	DWORD PTR _wcex$[ebp+12], 0

; 570  : 	wcex.cbWndExtra = 0;

	mov	DWORD PTR _wcex$[ebp+16], 0

; 571  : 	wcex.hInstance = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wcex$[ebp+20], eax

; 572  : 	wcex.hIcon = LoadIcon( hInstance, ( LPCTSTR )IDI_TUTORIAL1 );

	mov	esi, esp
	push	107					; 0000006bH
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadIconW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wcex$[ebp+24], eax

; 573  : 	wcex.hCursor = LoadCursor( NULL, IDC_ARROW );

	mov	esi, esp
	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wcex$[ebp+28], eax

; 574  : 	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );

	mov	DWORD PTR _wcex$[ebp+32], 6

; 575  : 	wcex.lpszMenuName = NULL;

	mov	DWORD PTR _wcex$[ebp+36], 0

; 576  : 	wcex.lpszClassName = L"TutorialWindowClass";

	mov	DWORD PTR _wcex$[ebp+40], OFFSET ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@

; 577  : 	wcex.hIconSm = LoadIcon( wcex.hInstance, ( LPCTSTR )IDI_TUTORIAL1 );

	mov	esi, esp
	push	107					; 0000006bH
	mov	eax, DWORD PTR _wcex$[ebp+20]
	push	eax
	call	DWORD PTR __imp__LoadIconW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wcex$[ebp+44], eax

; 578  : 	if( !RegisterClassEx( &wcex ) )	return false;

	mov	esi, esp
	lea	eax, DWORD PTR _wcex$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassExW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN2@InitWindow
	xor	al, al
	jmp	$LN3@InitWindow
$LN2@InitWindow:

; 579  : 
; 580  : 	// Create window
; 581  : 	HInst = hInstance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [eax+477484], ecx

; 582  : 	
; 583  : 	RECT rc = { 0, 0, mySettings->resolutionX, mySettings->resolutionY };

	mov	DWORD PTR _rc$[ebp], 0
	mov	DWORD PTR _rc$[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _rc$[ebp+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _rc$[ebp+12], edx

; 584  : 	AdjustWindowRect( &rc, WS_OVERLAPPEDWINDOW, FALSE );

	mov	esi, esp
	push	0
	push	13565952				; 00cf0000H
	lea	eax, DWORD PTR _rc$[ebp]
	push	eax
	call	DWORD PTR __imp__AdjustWindowRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 585  : 	HWnd = CreateWindow( L"TutorialWindowClass", L"Dissertation Project", WS_OVERLAPPEDWINDOW,
; 586  : 	                     CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, hInstance, NULL );

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _rc$[ebp+12]
	sub	ecx, DWORD PTR _rc$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _rc$[ebp+8]
	sub	edx, DWORD PTR _rc$[ebp]
	push	edx
	push	-2147483648				; 80000000H
	push	-2147483648				; 80000000H
	push	13565952				; 00cf0000H
	push	OFFSET ??_C@_1CK@FLGJEDAL@?$AAD?$AAi?$AAs?$AAs?$AAe?$AAr?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAP?$AAr?$AAo?$AAj?$AAe?$AAc?$AAt?$AA?$AA@
	push	OFFSET ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExW@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+477488], eax

; 587  : 	if( !HWnd )	return false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+477488], 0
	jne	SHORT $LN1@InitWindow
	xor	al, al
	jmp	SHORT $LN3@InitWindow
$LN1@InitWindow:

; 588  : 
; 589  : 	ShowWindow( HWnd, nCmdShow );

	mov	esi, esp
	mov	eax, DWORD PTR _nCmdShow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477488]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 590  : 
; 591  : 	return true;

	mov	al, 1
$LN3@InitWindow:

; 592  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@InitWindow
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@InitWindow:
	DD	2
	DD	$LN7@InitWindow
$LN7@InitWindow:
	DD	-68					; ffffffbcH
	DD	48					; 00000030H
	DD	$LN5@InitWindow
	DD	-92					; ffffffa4H
	DD	16					; 00000010H
	DD	$LN6@InitWindow
$LN6@InitWindow:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
$LN5@InitWindow:
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z ENDP	; CScene::InitWindow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?RenderScene@CScene@@QAEXXZ
_TEXT	SEGMENT
tv289 = -404						; size = 4
$T1 = -396						; size = 4
$T2 = -384						; size = 64
$T3 = -304						; size = 64
_ClearColor$ = -36					; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?RenderScene@CScene@@QAEXXZ PROC			; CScene::RenderScene, COMDAT
; _this$ = ecx

; 463  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 408				; 00000198H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-408]
	mov	ecx, 102				; 00000066H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 464  : 	// Clear the back buffer - before drawing the geometry clear the entire window to a fixed colour
; 465  : 	float ClearColor[4] = { 0.2f, 0.2f, 0.3f, 1.0f }; // Good idea to match background to ambient colour

	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _ClearColor$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _ClearColor$[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR _ClearColor$[ebp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ClearColor$[ebp+12], xmm0

; 466  : 	mpd3dDeviceContext->ClearRenderTargetView( RenderTargetView, ClearColor );

	mov	esi, esp
	lea	eax, DWORD PTR _ClearColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477476]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452448]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452448]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+200]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 467  : 	mpd3dDeviceContext->ClearDepthStencilView( DepthStencilView, D3D10_CLEAR_DEPTH | D3D10_CLEAR_STENCIL , 1.0f, 0 ); // Clear the depth buffer too

	mov	esi, esp
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477472]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452448]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+452448]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+212]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 468  : 
; 469  : 
; 470  : 	// Pass the camera's matrices to the vertex shader
; 471  : 	ViewMatrixVar->SetMatrix( (float*)&Camera.GetViewMatrix() );

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	?GetViewMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ ; CCamera::GetViewMatrix
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477408]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+112]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 472  : 	ProjMatrixVar->SetMatrix( (float*)&Camera.GetProjectionMatrix() );

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	?GetProjectionMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ ; CCamera::GetProjectionMatrix
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477412]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477412]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+112]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 473  : 
; 474  : 	//pass the camera position
; 475  : 	//V3 temp = XMF3ToFloat3( Camera->GetPosition() );
; 476  : 	//dxCameraPos->SetRawValue( &temp, 0, 12);
; 477  : 
; 478  : 	//pass the lighting colours
; 479  : 	//temp = XMF3ToFloat3( AmbientColour );
; 480  : 	//dxAmbientColour->SetRawValue( &temp, 0, 12  );
; 481  : 
; 482  : 	//---------------------------
; 483  : 	// Render each model
; 484  : 	
; 485  : 	DrawAllObjects(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAllObjects@CScene@@AAEX_N@Z	; CScene::DrawAllObjects

; 486  : 
; 487  : 	mp_openSquares.RenderBatch(WorldMatrixVar, ModelColourVar);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	call	?RenderBatch@ModelBatch@@QAEXPAUID3DX11EffectMatrixVariable@@PAUID3DX11EffectVectorVariable@@@Z ; ModelBatch::RenderBatch

; 488  : 	mp_walls.RenderBatch( WorldMatrixVar, ModelColourVar );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68208				; 00010a70H
	call	?RenderBatch@ModelBatch@@QAEXPAUID3DX11EffectMatrixVariable@@PAUID3DX11EffectVectorVariable@@@Z ; ModelBatch::RenderBatch

; 489  : 	mp_pathModel.RenderBatch(WorldMatrixVar, ModelColourVar);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	call	?RenderBatch@ModelBatch@@QAEXPAUID3DX11EffectMatrixVariable@@PAUID3DX11EffectVectorVariable@@@Z ; ModelBatch::RenderBatch

; 490  : 	mp_splineModel.RenderBatch(WorldMatrixVar, ModelColourVar);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	call	?RenderBatch@ModelBatch@@QAEXPAUID3DX11EffectMatrixVariable@@PAUID3DX11EffectVectorVariable@@@Z ; ModelBatch::RenderBatch

; 491  : 	mp_heavyTurretModel.RenderBatch(WorldMatrixVar, ModelColourVar);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	call	?RenderBatch@ModelBatch@@QAEXPAUID3DX11EffectMatrixVariable@@PAUID3DX11EffectVectorVariable@@@Z ; ModelBatch::RenderBatch

; 492  : 	mp_mediumTurretModel.RenderBatch(WorldMatrixVar, ModelColourVar);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	call	?RenderBatch@ModelBatch@@QAEXPAUID3DX11EffectMatrixVariable@@PAUID3DX11EffectVectorVariable@@@Z ; ModelBatch::RenderBatch

; 493  : 	mp_lightTurretModel.RenderBatch(WorldMatrixVar, ModelColourVar);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388368				; 0005ed10H
	call	?RenderBatch@ModelBatch@@QAEXPAUID3DX11EffectMatrixVariable@@PAUID3DX11EffectVectorVariable@@@Z ; ModelBatch::RenderBatch

; 494  : 
; 495  : 	mpSpriteBatch->Begin();

	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR $T1[ebp], esp
	push	0
	call	??0?$function@$$A6AXXZ@std@@QAE@$$T@Z	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
	mov	DWORD PTR tv289[ebp], eax
	push	0
	push	0
	push	0
	push	0
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movaps	xmm0, XMMWORD PTR ?MatrixIdentity@SpriteBatch@DirectX@@0UXMMATRIX@2@B
	movaps	xmm1, XMMWORD PTR ?MatrixIdentity@SpriteBatch@DirectX@@0UXMMATRIX@2@B+16
	movaps	xmm2, XMMWORD PTR ?MatrixIdentity@SpriteBatch@DirectX@@0UXMMATRIX@2@B+32
	movaps	xmm3, XMMWORD PTR ?MatrixIdentity@SpriteBatch@DirectX@@0UXMMATRIX@2@B+48
	call	?Begin@SpriteBatch@DirectX@@QAQXW4SpriteSortMode@2@PAUID3D11BlendState@@PAUID3D11SamplerState@@PAUID3D11DepthStencilState@@PAUID3D11RasterizerState@@V?$function@$$A6AXXZ@std@@UXMMATRIX@2@@Z ; DirectX::SpriteBatch::Begin

; 496  : 	//mpSpriteFont->DrawString( mpSpriteBatch, L"Hello, world!", DirectX::XMFLOAT2( 500.0f, 500.0f ) );
; 497  : 
; 498  : 	FontRect.bottom = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+452428], 0

; 499  : 	FontRect.right = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+452424], 0

; 500  : 
; 501  : 	if( mb_showBaseIM )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452439]
	test	ecx, ecx
	je	SHORT $LN8@RenderScen

; 502  : 	{
; 503  : 		DisplayText( "Base Influence Map", 0);

	push	0
	push	OFFSET ??_C@_0BD@IBHNMNGC@Base?5Influence?5Map?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayText@CScene@@AAEXQADI@Z		; CScene::DisplayText

; 504  : 		DisplayMapText(BASE_OFFSET);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayMapText@CScene@@AAEXH@Z		; CScene::DisplayMapText
$LN8@RenderScen:

; 505  : 	}
; 506  : 
; 507  : 	if( mb_showBase2IM )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452440]
	test	ecx, ecx
	je	SHORT $LN7@RenderScen

; 508  : 	{
; 509  : 		DisplayText( "Base 2 Influence Map", 0);

	push	0
	push	OFFSET ??_C@_0BF@IFJGMLAN@Base?52?5Influence?5Map?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayText@CScene@@AAEXQADI@Z		; CScene::DisplayText

; 510  : 		DisplayMapText(BASE2_OFFSET);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayMapText@CScene@@AAEXH@Z		; CScene::DisplayMapText
$LN7@RenderScen:

; 511  : 	}
; 512  : 
; 513  : 	if( mb_showCost )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452436]
	test	ecx, ecx
	je	SHORT $LN6@RenderScen

; 514  : 	{
; 515  : 		DisplayText( "Square Cost", 0);

	push	0
	push	OFFSET ??_C@_0M@PKLOLIMK@Square?5Cost?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayText@CScene@@AAEXQADI@Z		; CScene::DisplayText

; 516  : 		DisplayMapText(COST_OFFSET);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayMapText@CScene@@AAEXH@Z		; CScene::DisplayMapText
$LN6@RenderScen:

; 517  : 	}
; 518  : 
; 519  : 	if( mb_showHTIM )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452441]
	test	ecx, ecx
	je	SHORT $LN5@RenderScen

; 520  : 	{
; 521  : 		DisplayText( "Heavy Turret Influence Map", 0 );

	push	0
	push	OFFSET ??_C@_0BL@ELAJJFDJ@Heavy?5Turret?5Influence?5Map?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayText@CScene@@AAEXQADI@Z		; CScene::DisplayText

; 522  : 		DisplayMapText(HEAVY_OFFSET);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayMapText@CScene@@AAEXH@Z		; CScene::DisplayMapText
$LN5@RenderScen:

; 523  : 	}
; 524  : 
; 525  : 	if( mb_showLTIM )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452443]
	test	ecx, ecx
	je	SHORT $LN4@RenderScen

; 526  : 	{
; 527  : 		DisplayText( "Light Turret Influence Map", 0);

	push	0
	push	OFFSET ??_C@_0BL@LIODDAAK@Light?5Turret?5Influence?5Map?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayText@CScene@@AAEXQADI@Z		; CScene::DisplayText

; 528  : 		DisplayMapText(LIGHT_OFFSET);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayMapText@CScene@@AAEXH@Z		; CScene::DisplayMapText
$LN4@RenderScen:

; 529  : 	}
; 530  : 
; 531  : 	if( mb_showMTIM )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452442]
	test	ecx, ecx
	je	SHORT $LN3@RenderScen

; 532  : 	{
; 533  : 		DisplayText( "Medium Turret Influence Map", 0);

	push	0
	push	OFFSET ??_C@_0BM@FFDBFNFB@Medium?5Turret?5Influence?5Map?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayText@CScene@@AAEXQADI@Z		; CScene::DisplayText

; 534  : 		DisplayMapText(MEDIUM_OFFSET);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayMapText@CScene@@AAEXH@Z		; CScene::DisplayMapText
$LN3@RenderScen:

; 535  : 	}
; 536  : 
; 537  : 	if( mb_showPathIM )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452438]
	test	ecx, ecx
	je	SHORT $LN2@RenderScen

; 538  : 	{
; 539  : 		DisplayText( "Path Influence Map", 0 );

	push	0
	push	OFFSET ??_C@_0BD@MPFDMOIL@Path?5Influence?5Map?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayText@CScene@@AAEXQADI@Z		; CScene::DisplayText

; 540  : 		DisplayMapText( PATH_OFFSET);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayMapText@CScene@@AAEXH@Z		; CScene::DisplayMapText
$LN2@RenderScen:

; 541  : 	}
; 542  : 
; 543  : 	if( mb_showWallIM )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452437]
	test	ecx, ecx
	je	SHORT $LN1@RenderScen

; 544  : 	{
; 545  : 		DisplayText( "Wall Influence Map", 0);

	push	0
	push	OFFSET ??_C@_0BD@KABNNPKE@Wall?5Influence?5Map?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayText@CScene@@AAEXQADI@Z		; CScene::DisplayText

; 546  : 		DisplayMapText(WALL_OFFSET);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayMapText@CScene@@AAEXH@Z		; CScene::DisplayMapText
$LN1@RenderScen:

; 547  : 	}
; 548  : 	mpSpriteBatch->End();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?End@SpriteBatch@DirectX@@QAAXXZ	; DirectX::SpriteBatch::End
	add	esp, 4

; 549  : 	TwDraw();

	mov	esi, esp
	call	DWORD PTR __imp__TwDraw@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 550  : 
; 551  : 	//---------------------------
; 552  : 	// Display the Scene
; 553  : 
; 554  : 	// After we've finished drawing to the off-screen back buffer, we "present" it to the front buffer (the screen)
; 555  : 	SwapChain->Present( 0, 0 );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477464]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477464]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+32]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@RenderScen
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
	npad	1
$LN14@RenderScen:
	DD	1
	DD	$LN13@RenderScen
$LN13@RenderScen:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN12@RenderScen
$LN12@RenderScen:
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?RenderScene@CScene@@QAEXXZ ENDP			; CScene::RenderScene
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?VisualisePath@CScene@@QAEXXZ
_TEXT	SEGMENT
$T1 = -312						; size = 12
$T2 = -292						; size = 12
_i$3 = -80						; size = 4
_i$4 = -68						; size = 4
_numSplines$ = -56					; size = 4
_numNodes$ = -44					; size = 4
_splines$ = -32						; size = 4
_nodes$ = -20						; size = 4
_this$ = -8						; size = 4
?VisualisePath@CScene@@QAEXXZ PROC			; CScene::VisualisePath, COMDAT
; _this$ = ecx

; 1083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1084 : 	Coords* nodes;
; 1085 : 	sCoords** splines;
; 1086 : 	uint32_t numNodes, numSplines;
; 1087 : 
; 1088 : 	mc_map->GetPathNodes(numNodes, nodes);

	lea	eax, DWORD PTR _nodes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _numNodes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?GetPathNodes@MapSquare@@QAEXAAIAAPAUCoords@@@Z ; MapSquare::GetPathNodes

; 1089 : 	mc_map->GetPathSplines(numSplines, splines);

	lea	eax, DWORD PTR _splines$[ebp]
	push	eax
	lea	ecx, DWORD PTR _numSplines$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?GetPathSplines@MapSquare@@QAEXAAIAAPAPAUsCoords@@@Z ; MapSquare::GetPathSplines

; 1090 : 
; 1091 : 	mp_pathModel.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	call	?Reset@ModelBatch@@QAEXXZ		; ModelBatch::Reset

; 1092 : 
; 1093 : 	for (uint32_t i = 0; i < numNodes; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN6@VisualiseP
$LN5@VisualiseP:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN6@VisualiseP:
	mov	eax, DWORD PTR _i$4[ebp]
	cmp	eax, DWORD PTR _numNodes$[ebp]
	jae	SHORT $LN4@VisualiseP

; 1094 : 	{
; 1095 : 		mp_pathModel.AddInstance(
; 1096 : 			DirectX::XMFLOAT3(static_cast<float>(nodes[i].x), 1.0f, static_cast<float>(nodes[i].y)),
; 1097 : 			mySettings->nodeScale
; 1098 : 		);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+68]
	movss	DWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$4[ebp], 20
	mov	eax, DWORD PTR _nodes$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+edx+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$4[ebp], 20
	mov	edx, DWORD PTR _nodes$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	call	?AddInstance@ModelBatch@@QAEPAUXMMATRIX@DirectX@@UXMFLOAT3@3@M@Z ; ModelBatch::AddInstance

; 1099 : 	}

	jmp	$LN5@VisualiseP
$LN4@VisualiseP:

; 1100 : 
; 1101 : 	mp_splineModel.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	call	?Reset@ModelBatch@@QAEXXZ		; ModelBatch::Reset

; 1102 : 
; 1103 : 	for (uint32_t i = 0; i < numSplines; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN3@VisualiseP
$LN2@VisualiseP:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN3@VisualiseP:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _numSplines$[ebp]
	jae	SHORT $LN1@VisualiseP

; 1104 : 	{
; 1105 : 		mp_splineModel.AddInstance(
; 1106 : 			DirectX::XMFLOAT3(splines[i]->x, 1.0f, splines[i]->y),
; 1107 : 			mySettings->splineScale
; 1108 : 		);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+132]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _splines$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _splines$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	call	?AddInstance@ModelBatch@@QAEPAUXMMATRIX@DirectX@@UXMFLOAT3@3@M@Z ; ModelBatch::AddInstance

; 1109 : 	}

	jmp	$LN2@VisualiseP
$LN1@VisualiseP:

; 1110 : 	
; 1111 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@VisualiseP
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN14@VisualiseP:
	DD	4
	DD	$LN13@VisualiseP
$LN13@VisualiseP:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN9@VisualiseP
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN10@VisualiseP
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN11@VisualiseP
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN12@VisualiseP
$LN12@VisualiseP:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	83					; 00000053H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN11@VisualiseP:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN10@VisualiseP:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN9@VisualiseP:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
?VisualisePath@CScene@@QAEXXZ ENDP			; CScene::VisualisePath
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?UpdateScene@CScene@@QAEXM@Z
_TEXT	SEGMENT
tv293 = -372						; size = 4
tv275 = -372						; size = 4
tv257 = -372						; size = 4
tv239 = -372						; size = 4
tv221 = -372						; size = 4
tv203 = -372						; size = 4
tv185 = -372						; size = 4
tv167 = -372						; size = 4
_i$1 = -172						; size = 4
_i$2 = -160						; size = 4
_FPS$ = -148						; size = 4
_buffer$ = -136						; size = 6
_caption$ = -120					; size = 100
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_frameTime$ = 8						; size = 4
?UpdateScene@CScene@@QAEXM@Z PROC			; CScene::UpdateScene, COMDAT
; _this$ = ecx

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 93					; 0000005dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 	//Show Framerate
; 231  : 	char caption[100];
; 232  : 	char buffer[6];
; 233  : 	
; 234  : 	//copy in base text
; 235  : 	strcpy_s( caption,  "Final Project - Project SPARTA - FPS:");

	push	OFFSET ??_C@_0CG@PNBOIMLL@Final?5Project?5?9?5Project?5SPARTA?5?9@
	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	call	??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcpy_s<100>
	add	esp, 8

; 236  : 	
; 237  : 	//calculate FPS
; 238  : 	int FPS = int ( 1.0f / frameTime );

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _frameTime$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _FPS$[ebp], eax

; 239  : 	
; 240  : 	//convert to string in base 10 and add to caption
; 241  : 	_itoa_s( FPS,buffer,10 );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _FPS$[ebp]
	push	ecx
	call	??$_itoa_s@$05@@YAHHAAY05DH@Z		; _itoa_s<6>
	add	esp, 12					; 0000000cH

; 242  : 	strcat_s( caption, buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _caption$[ebp]
	push	ecx
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 243  : 	
; 244  : 	//add in object and light counts as above
; 245  : 	strcat_s( caption, " O: " );

	push	OFFSET ??_C@_04IHBDCLGJ@?5O?3?5?$AA@
	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 246  : 	_itoa_s( miNumObjects, buffer, 10 );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+460768]
	push	edx
	call	??$_itoa_s@$05@@YAHHAAY05DH@Z		; _itoa_s<6>
	add	esp, 12					; 0000000cH

; 247  : 	strcat_s( caption, buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _caption$[ebp]
	push	ecx
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 248  : 
; 249  : 	strcat_s( caption, " L: " );

	push	OFFSET ??_C@_04JFKGIEIH@?5L?3?5?$AA@
	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 250  : 	_itoa_s( miNumLights, buffer, 10 );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+460892]
	push	edx
	call	??$_itoa_s@$05@@YAHHAAY05DH@Z		; _itoa_s<6>
	add	esp, 12					; 0000000cH

; 251  : 	strcat_s( caption, buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _caption$[ebp]
	push	ecx
	call	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z	; strcat_s<100>
	add	esp, 8

; 252  : 
; 253  : 	//pass the new caption to the window
; 254  : 	SetWindowTextA( HWnd, caption );

	mov	esi, esp
	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477488]
	push	edx
	call	DWORD PTR __imp__SetWindowTextA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 255  : 
; 256  : 	// Control camera position and update its matrices (view matrix, projection matrix) each frame
; 257  : 	// Don't be deceived into thinking that this is a new method to control models - the same code we used previously is in the camera class
; 258  : 	Camera.Control( frameTime, Key_Up, Key_Down, Key_Left, Key_Right, Key_W, Key_S, Key_A, Key_D );

	push	68					; 00000044H
	push	65					; 00000041H
	push	83					; 00000053H
	push	87					; 00000057H
	push	39					; 00000027H
	push	37					; 00000025H
	push	40					; 00000028H
	push	38					; 00000026H
	push	ecx
	movss	xmm0, DWORD PTR _frameTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z ; CCamera::Control

; 259  : 	Camera.UpdateMatrices();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	?UpdateMatrices@CCamera@@QAEXXZ		; CCamera::UpdateMatrices

; 260  : 	
; 261  : 
; 262  : 	//update all the objects, including calculating the matrix
; 263  : 	for(int i = 0; i < miNumObjects; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN15@UpdateScen
$LN14@UpdateScen:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN15@UpdateScen:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax+460768]
	jge	SHORT $LN13@UpdateScen

; 264  : 	{
; 265  : 		mpObjects[i]->Update(frameTime);

	push	ecx
	movss	xmm0, DWORD PTR _frameTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?Update@CRenderObject@@QAEXM@Z		; CRenderObject::Update

; 266  : 	}

	jmp	SHORT $LN14@UpdateScen
$LN13@UpdateScen:

; 267  : 
; 268  : 	//same for the lights
; 269  : 	for(int i = 0; i < miNumLights; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN12@UpdateScen
$LN11@UpdateScen:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN12@UpdateScen:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+460892]
	jge	SHORT $LN10@UpdateScen

; 270  : 	{
; 271  : 		mpLights[i]->Update(frameTime);

	push	ecx
	movss	xmm0, DWORD PTR _frameTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+460772]
	call	?Update@CLight@@QAEXM@Z			; CLight::Update

; 272  : 	}

	jmp	SHORT $LN11@UpdateScen
$LN10@UpdateScen:

; 273  : 
; 274  : 
; 275  : 	// Allow user to quit with escape key
; 276  : 	if (KeyHit( Key_Escape )) 

	push	27					; 0000001bH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@UpdateScen

; 277  : 	{
; 278  : 		DestroyWindow( HWnd );

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477488]
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@UpdateScen:

; 279  : 	}
; 280  : 
; 281  : 	if (KeyHit( Key_F1 ) )

	push	112					; 00000070H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@UpdateScen

; 282  : 	{
; 283  : 		mb_showCost = !mb_showCost;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452436]
	test	ecx, ecx
	jne	SHORT $LN18@UpdateScen
	mov	DWORD PTR tv167[ebp], 1
	jmp	SHORT $LN19@UpdateScen
$LN18@UpdateScen:
	mov	DWORD PTR tv167[ebp], 0
$LN19@UpdateScen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv167[ebp]
	mov	BYTE PTR [edx+452436], al

; 284  : 		mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 285  : 		mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 286  : 		mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 287  : 		mb_showBase2IM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452440], 0

; 288  : 		mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 289  : 		mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 290  : 		mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0
$LN8@UpdateScen:

; 291  : 	}
; 292  : 
; 293  : 	if (KeyHit( Key_F2 ) )

	push	113					; 00000071H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@UpdateScen

; 294  : 	{
; 295  : 		mb_showCost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452436], 0

; 296  : 		mb_showWallIM = !mb_showWallIM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452437]
	test	ecx, ecx
	jne	SHORT $LN20@UpdateScen
	mov	DWORD PTR tv185[ebp], 1
	jmp	SHORT $LN21@UpdateScen
$LN20@UpdateScen:
	mov	DWORD PTR tv185[ebp], 0
$LN21@UpdateScen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv185[ebp]
	mov	BYTE PTR [edx+452437], al

; 297  : 		mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 298  : 		mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 299  : 		mb_showBase2IM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452440], 0

; 300  : 		mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 301  : 		mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 302  : 		mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0
$LN7@UpdateScen:

; 303  : 	}
; 304  : 
; 305  : 	if (KeyHit( Key_F3 ) )

	push	114					; 00000072H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@UpdateScen

; 306  : 	{
; 307  : 		mb_showCost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452436], 0

; 308  : 		mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 309  : 		mb_showPathIM = !mb_showPathIM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452438]
	test	ecx, ecx
	jne	SHORT $LN22@UpdateScen
	mov	DWORD PTR tv203[ebp], 1
	jmp	SHORT $LN23@UpdateScen
$LN22@UpdateScen:
	mov	DWORD PTR tv203[ebp], 0
$LN23@UpdateScen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv203[ebp]
	mov	BYTE PTR [edx+452438], al

; 310  : 		mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 311  : 		mb_showBase2IM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452440], 0

; 312  : 		mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 313  : 		mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 314  : 		mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0
$LN6@UpdateScen:

; 315  : 	}
; 316  : 
; 317  : 	if (KeyHit( Key_F4 ) )

	push	115					; 00000073H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@UpdateScen

; 318  : 	{
; 319  : 		mb_showCost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452436], 0

; 320  : 		mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 321  : 		mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 322  : 		mb_showBaseIM = !mb_showBaseIM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452439]
	test	ecx, ecx
	jne	SHORT $LN24@UpdateScen
	mov	DWORD PTR tv221[ebp], 1
	jmp	SHORT $LN25@UpdateScen
$LN24@UpdateScen:
	mov	DWORD PTR tv221[ebp], 0
$LN25@UpdateScen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv221[ebp]
	mov	BYTE PTR [edx+452439], al

; 323  : 		mb_showBase2IM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452440], 0

; 324  : 		mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 325  : 		mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 326  : 		mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0
$LN5@UpdateScen:

; 327  : 	}
; 328  : 
; 329  : 	if (KeyHit( Key_F5 ) )

	push	116					; 00000074H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@UpdateScen

; 330  : 	{
; 331  : 		mb_showCost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452436], 0

; 332  : 		mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 333  : 		mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 334  : 		mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 335  : 		mb_showBase2IM = !mb_showBase2IM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452440]
	test	ecx, ecx
	jne	SHORT $LN26@UpdateScen
	mov	DWORD PTR tv239[ebp], 1
	jmp	SHORT $LN27@UpdateScen
$LN26@UpdateScen:
	mov	DWORD PTR tv239[ebp], 0
$LN27@UpdateScen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv239[ebp]
	mov	BYTE PTR [edx+452440], al

; 336  : 		mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 337  : 		mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 338  : 		mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0
$LN4@UpdateScen:

; 339  : 	}
; 340  : 
; 341  : 	if (KeyHit( Key_F6 ) )

	push	117					; 00000075H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@UpdateScen

; 342  : 	{
; 343  : 		mb_showCost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452436], 0

; 344  : 		mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 345  : 		mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 346  : 		mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 347  : 		mb_showBase2IM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452440], 0

; 348  : 		mb_showHTIM = !mb_showHTIM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452441]
	test	ecx, ecx
	jne	SHORT $LN28@UpdateScen
	mov	DWORD PTR tv257[ebp], 1
	jmp	SHORT $LN29@UpdateScen
$LN28@UpdateScen:
	mov	DWORD PTR tv257[ebp], 0
$LN29@UpdateScen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv257[ebp]
	mov	BYTE PTR [edx+452441], al

; 349  : 		mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 350  : 		mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0
$LN3@UpdateScen:

; 351  : 	}
; 352  : 
; 353  : 	if (KeyHit( Key_F7 ) )

	push	118					; 00000076H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@UpdateScen

; 354  : 	{
; 355  : 		mb_showCost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452436], 0

; 356  : 		mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 357  : 		mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 358  : 		mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 359  : 		mb_showBase2IM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452440], 0

; 360  : 		mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 361  : 		mb_showLTIM = !mb_showLTIM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452443]
	test	ecx, ecx
	jne	SHORT $LN30@UpdateScen
	mov	DWORD PTR tv275[ebp], 1
	jmp	SHORT $LN31@UpdateScen
$LN30@UpdateScen:
	mov	DWORD PTR tv275[ebp], 0
$LN31@UpdateScen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv275[ebp]
	mov	BYTE PTR [edx+452443], al

; 362  : 		mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0
$LN2@UpdateScen:

; 363  : 	}
; 364  : 
; 365  : 	if (KeyHit( Key_F8 ) )

	push	119					; 00000077H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@UpdateScen

; 366  : 	{
; 367  : 		mb_showCost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452436], 0

; 368  : 		mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 369  : 		mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 370  : 		mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 371  : 		mb_showBase2IM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452440], 0

; 372  : 		mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 373  : 		mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 374  : 		mb_showMTIM = !mb_showMTIM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+452442]
	test	ecx, ecx
	jne	SHORT $LN32@UpdateScen
	mov	DWORD PTR tv293[ebp], 1
	jmp	SHORT $LN33@UpdateScen
$LN32@UpdateScen:
	mov	DWORD PTR tv293[ebp], 0
$LN33@UpdateScen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv293[ebp]
	mov	BYTE PTR [edx+452442], al
$LN1@UpdateScen:

; 375  : 	}
; 376  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN37@UpdateScen
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN37@UpdateScen:
	DD	2
	DD	$LN36@UpdateScen
$LN36@UpdateScen:
	DD	-120					; ffffff88H
	DD	100					; 00000064H
	DD	$LN34@UpdateScen
	DD	-136					; ffffff78H
	DD	6
	DD	$LN35@UpdateScen
$LN35@UpdateScen:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN34@UpdateScen:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?UpdateScene@CScene@@QAEXM@Z ENDP			; CScene::UpdateScene
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?InitScene@CScene@@QAE_NXZ
_TEXT	SEGMENT
tv498 = -876						; size = 4
tv438 = -876						; size = 4
tv1454 = -872						; size = 8
tv1370 = -872						; size = 8
tv1321 = -872						; size = 8
tv1281 = -872						; size = 8
tv1450 = -860						; size = 4
tv1366 = -860						; size = 4
tv1317 = -860						; size = 4
tv1245 = -860						; size = 4
tv1445 = -856						; size = 8
tv1361 = -856						; size = 8
tv1312 = -856						; size = 8
tv1240 = -856						; size = 8
tv144 = -852						; size = 4
tv95 = -848						; size = 4
tv1441 = -844						; size = 4
tv1357 = -844						; size = 4
tv1308 = -844						; size = 4
tv1236 = -844						; size = 4
tv950 = -844						; size = 4
tv946 = -844						; size = 4
tv942 = -844						; size = 4
tv937 = -844						; size = 4
tv933 = -844						; size = 4
tv929 = -844						; size = 4
tv925 = -844						; size = 4
tv921 = -844						; size = 4
tv596 = -844						; size = 4
tv585 = -844						; size = 4
tv370 = -844						; size = 4
tv282 = -844						; size = 4
$T2 = -836						; size = 12
$T3 = -816						; size = 12
$T4 = -796						; size = 4
$T5 = -784						; size = 4
$T6 = -772						; size = 4
$T7 = -760						; size = 4
$T8 = -748						; size = 4
$T9 = -736						; size = 4
$T10 = -724						; size = 4
$T11 = -712						; size = 4
$T12 = -700						; size = 4
$T13 = -688						; size = 12
$T14 = -668						; size = 4
$T15 = -656						; size = 4
$T16 = -644						; size = 4
$T17 = -632						; size = 12
$T18 = -612						; size = 12
$T19 = -592						; size = 4
$T20 = -580						; size = 4
$T21 = -568						; size = 12
$T22 = -548						; size = 12
$T23 = -528						; size = 4
$T24 = -516						; size = 4
$T25 = -504						; size = 12
$T26 = -484						; size = 12
$T27 = -464						; size = 4
$T28 = -452						; size = 4
$T29 = -440						; size = 4
$T30 = -428						; size = 4
$T31 = -416						; size = 64
$T32 = -336						; size = 64
_result$ = -64						; size = 4
_x$33 = -52						; size = 4
_y$34 = -40						; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?InitScene@CScene@@QAE_NXZ PROC				; CScene::InitScene, COMDAT
; _this$ = ecx

; 39   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InitScene@CScene@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	sub	esp, 872				; 00000368H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-888]
	mov	ecx, 218				; 000000daH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 40   : 	//////////////////
; 41   : 	// Create camera
; 42   : 
; 43   : 	//Camera = new CCamera();
; 44   : 	Camera.SetPosition( DirectX::XMFLOAT3(-15, 20,-40) );

	push	ecx
	movss	xmm0, DWORD PTR __real@c2200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1700000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	?SetPosition@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z ; CCamera::SetPosition

; 45   : 	Camera.SetRotation( DirectX::XMFLOAT3(ToRadians(13.0f), ToRadians(18.0f), 0.0f) ); // ToRadians is a new helper function to convert degrees to radians

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41900000
	movss	DWORD PTR [esp], xmm0
	call	?ToRadians@@YAMM@Z			; ToRadians
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@41500000
	movss	DWORD PTR [esp], xmm0
	call	?ToRadians@@YAMM@Z			; ToRadians
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	?SetRotation@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z ; CCamera::SetRotation

; 46   : 	Camera.SetNearClip( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	?SetNearClip@CCamera@@QAEXM@Z		; CCamera::SetNearClip

; 47   : 
; 48   : 	//load all textures and maps
; 49   : 	miNumMaps = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+476896], 0

; 50   : 
; 51   : 	mc_map = new MapSquare("bob", mySettings);

	push	300320					; 00049520H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN44@InitScene
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	push	OFFSET ??_C@_03FLNEJKFD@bob?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv921[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0MapSquare@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVSettingsManager@@@Z ; MapSquare::MapSquare
	mov	DWORD PTR tv95[ebp], eax
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv144[ebp], edx
	jmp	SHORT $LN45@InitScene
$LN44@InitScene:
	mov	DWORD PTR tv144[ebp], 0
$LN45@InitScene:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+28], edx

; 52   : 
; 53   : 	//caching these locally - does mean more coupling, but seems better than fetching an unchanging variable repeatedly.
; 54   : 	mi_mapHeight = mc_map->GetHeight();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?GetHeight@MapSquare@@QAEIXZ		; MapSquare::GetHeight
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+452456], eax

; 55   : 	mi_mapWidth = mc_map->GetWidth();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?GetWidth@MapSquare@@QAEIXZ		; MapSquare::GetWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+452452], eax

; 56   : 	
; 57   : 	//mp_openSquares = new ModelBatch();
; 58   : 	mp_openSquares.Load( "Cube.x", mTechniques[0], false );

	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv925[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	call	?Load@ModelBatch@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3DX11EffectTechnique@@_N@Z ; ModelBatch::Load

; 59   : 	mp_openSquares.SetColour(_WHITE);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __WHITE
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __WHITE+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __WHITE+8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	call	?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ; ModelBatch::SetColour

; 60   : 	//mp_openSquares.mp_technique = mTechniques[0];
; 61   : 
; 62   : 	//mp_walls = new ModelBatch();
; 63   : 	mp_walls.Load( "Cube.x", mTechniques[0], false );

	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T8[ebp], esp
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv929[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68208				; 00010a70H
	call	?Load@ModelBatch@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3DX11EffectTechnique@@_N@Z ; ModelBatch::Load

; 64   : 	mp_walls.SetColour(_BLACK);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __BLACK
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __BLACK+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __BLACK+8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68208				; 00010a70H
	call	?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ; ModelBatch::SetColour

; 65   : 	//mp_walls.mp_technique = mTechniques[0];
; 66   : 
; 67   : 	mp_pathModel.Load("TrafficCone.x", mTechniques[0], false);

	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T9[ebp], esp
	push	OFFSET ??_C@_0O@MAAOBHJP@TrafficCone?4x?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv933[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	call	?Load@ModelBatch@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3DX11EffectTechnique@@_N@Z ; ModelBatch::Load

; 68   : 	mp_pathModel.SetColour(_ORANGE);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __ORANGE
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __ORANGE+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __ORANGE+8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	call	?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ; ModelBatch::SetColour

; 69   : 	//mp_pathModel.mp_technique = mTechniques[0];
; 70   : 
; 71   : 	mp_splineModel.Load("TrafficCone.x", mTechniques[0], false);

	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T10[ebp], esp
	push	OFFSET ??_C@_0O@MAAOBHJP@TrafficCone?4x?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv937[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	call	?Load@ModelBatch@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3DX11EffectTechnique@@_N@Z ; ModelBatch::Load

; 72   : 	mp_splineModel.SetColour(_ORANGE);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __ORANGE
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __ORANGE+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __ORANGE+8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	call	?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ; ModelBatch::SetColour

; 73   : 	//mp_splineModel.mp_technique = mTechniques[0];
; 74   : 
; 75   : 	mp_chokeModel = new CRenderObject(
; 76   : 		"Sphere.x",
; 77   : 		DirectX::XMFLOAT3(mc_map->ms_chokePoint.x, 2.0f, mc_map->ms_chokePoint.y),
; 78   : 		_RED,
; 79   : 		mTechniques[0],
; 80   : 		NULL
; 81   : 		);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T12[ebp], 0
	je	$LN46@InitScene
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR __RED
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __RED+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __RED+8
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cvtsi2ss xmm0, DWORD PTR [ecx+44]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cvtsi2ss xmm0, DWORD PTR [eax+40]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T13[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0CRenderObject@@QAE@QADUXMFLOAT3@DirectX@@1PAUID3DX11EffectTechnique@@2PAUID3D11ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv282[ebp], eax
	jmp	SHORT $LN47@InitScene
$LN46@InitScene:
	mov	DWORD PTR tv282[ebp], 0
$LN47@InitScene:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR $T11[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR [edx+452408], eax

; 82   : 	mp_chokeModel->GetModel()->SetScale(0.05f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452408]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 83   : 
; 84   : 	mp_heavyTurretModel.Load("Cube.x", mTechniques[0], false);

	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T14[ebp], esp
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv942[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	call	?Load@ModelBatch@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3DX11EffectTechnique@@_N@Z ; ModelBatch::Load

; 85   : 	mp_heavyTurretModel.SetColour(_RED);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __RED
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __RED+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __RED+8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	call	?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ; ModelBatch::SetColour

; 86   : 
; 87   : 	mp_mediumTurretModel.Load("Cube.x", mTechniques[0], false);

	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T15[ebp], esp
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv946[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	call	?Load@ModelBatch@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3DX11EffectTechnique@@_N@Z ; ModelBatch::Load

; 88   : 	mp_mediumTurretModel.SetColour(_MRED);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __MRED
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __MRED+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __MRED+8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	call	?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ; ModelBatch::SetColour

; 89   : 
; 90   : 	mp_lightTurretModel.Load("Cube.x", mTechniques[0], false);

	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T16[ebp], esp
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv950[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388368				; 0005ed10H
	call	?Load@ModelBatch@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3DX11EffectTechnique@@_N@Z ; ModelBatch::Load

; 91   : 	mp_lightTurretModel.SetColour(_LRED);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __LRED
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __LRED+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __LRED+8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388368				; 0005ed10H
	call	?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ; ModelBatch::SetColour

; 92   : 
; 93   : 	for( uint32_t y = 0; y < mi_mapHeight; y++ )

	mov	DWORD PTR _y$34[ebp], 0
	jmp	SHORT $LN41@InitScene
$LN40@InitScene:
	mov	eax, DWORD PTR _y$34[ebp]
	add	eax, 1
	mov	DWORD PTR _y$34[ebp], eax
$LN41@InitScene:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y$34[ebp]
	cmp	ecx, DWORD PTR [eax+452456]
	jae	$LN39@InitScene

; 94   : 	{
; 95   : 		for( uint32_t x = 0; x < mi_mapWidth; x++ )

	mov	DWORD PTR _x$33[ebp], 0
	jmp	SHORT $LN38@InitScene
$LN37@InitScene:
	mov	eax, DWORD PTR _x$33[ebp]
	add	eax, 1
	mov	DWORD PTR _x$33[ebp], eax
$LN38@InitScene:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x$33[ebp]
	cmp	ecx, DWORD PTR [eax+452452]
	jae	$LN36@InitScene

; 96   : 		{
; 97   : 			switch( mc_map->GetCost( x, y ) )

	mov	eax, DWORD PTR _y$34[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$33[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?GetCost@MapSquare@@QAEIII@Z		; MapSquare::GetCost
	mov	DWORD PTR tv370[ebp], eax
	cmp	DWORD PTR tv370[ebp], 3
	ja	$LN34@InitScene
	mov	eax, DWORD PTR tv370[ebp]
	jmp	DWORD PTR $LN71@InitScene[eax*4]
$LN33@InitScene:

; 98   : 			{
; 99   : 				case 0: //walls
; 100  : 					mp_matrixArray[mi_numSquares] = mp_walls.AddInstance( DirectX::XMFLOAT3( static_cast<float>(x), 0.0f, static_cast<float>(y) ), 0.1f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y$34[ebp]
	mov	DWORD PTR tv1236[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1236[ebp]
	mov	ecx, DWORD PTR tv1236[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1240[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1240[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _x$33[ebp]
	mov	DWORD PTR tv1245[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1245[ebp]
	mov	eax, DWORD PTR tv1245[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1281[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1281[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T17[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68208				; 00010a70H
	call	?AddInstance@ModelBatch@@QAEPAUXMMATRIX@DirectX@@UXMFLOAT3@3@M@Z ; ModelBatch::AddInstance
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+176], eax

; 101  : 					break;

	jmp	$LN34@InitScene
$LN32@InitScene:

; 102  : 				case 1: //open
; 103  : 					mp_matrixArray[mi_numSquares] = mp_openSquares.AddInstance( DirectX::XMFLOAT3( static_cast<float>(x), 0.0f, static_cast<float>(y) ), 0.1f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y$34[ebp]
	mov	DWORD PTR tv1308[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1308[ebp]
	mov	ecx, DWORD PTR tv1308[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1312[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1312[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _x$33[ebp]
	mov	DWORD PTR tv1317[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1317[ebp]
	mov	eax, DWORD PTR tv1317[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1321[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1321[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T18[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	call	?AddInstance@ModelBatch@@QAEPAUXMMATRIX@DirectX@@UXMFLOAT3@3@M@Z ; ModelBatch::AddInstance
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+176], eax

; 104  : 					break;

	jmp	$LN34@InitScene
$LN31@InitScene:

; 105  : 				case 2:
; 106  : 					mp_p1StartModel = new CRenderObject( "Cube.x", DirectX::XMFLOAT3( static_cast<float>(x), 0.0f, static_cast<float>(y) ), DirectX::XMFLOAT3( 0.0f, 0.0f, 0.0f ), mTechniques[0], NULL );

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T20[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T20[ebp], 0
	je	$LN48@InitScene
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T21[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _y$34[ebp]
	mov	DWORD PTR tv1357[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1357[ebp]
	mov	edx, DWORD PTR tv1357[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1361[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1361[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$33[ebp]
	mov	DWORD PTR tv1366[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1366[ebp]
	mov	ecx, DWORD PTR tv1366[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1370[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1370[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T22[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T20[ebp]
	call	??0CRenderObject@@QAE@QADUXMFLOAT3@DirectX@@1PAUID3DX11EffectTechnique@@2PAUID3D11ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv438[ebp], eax
	jmp	SHORT $LN49@InitScene
$LN48@InitScene:
	mov	DWORD PTR tv438[ebp], 0
$LN49@InitScene:
	mov	ecx, DWORD PTR tv438[ebp]
	mov	DWORD PTR $T19[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T19[ebp]
	mov	DWORD PTR [edx+452400], eax

; 107  : 					mp_p1StartModel->SetColour( _RED );

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __RED
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __RED+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __RED+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+452400]
	call	?SetColour@CRenderObject@@QAEXUXMFLOAT3@DirectX@@@Z ; CRenderObject::SetColour

; 108  : 					mp_p1StartModel->GetModel()->SetScale(0.1f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452400]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 109  : 					mp_p1StartModel->GetModel()->UpdateMatrix();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452400]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 110  : 					md_p1StartMatrix = mp_p1StartModel->GetModel()->GetWorldMatrix();

	lea	eax, DWORD PTR $T31[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+452400]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?GetWorldMatrix@CModel@@QAE?AUXMMATRIX@DirectX@@XZ ; CModel::GetWorldMatrix
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4XMMATRIX@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMMATRIX::operator=

; 111  : 					mp_matrixArray[mi_numSquares] = &md_p1StartMatrix;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+176], eax

; 112  : 					break;

	jmp	$LN34@InitScene
$LN30@InitScene:

; 113  : 				case 3:
; 114  : 					mp_p2StartModel = new CRenderObject( "Cube.x", DirectX::XMFLOAT3( static_cast<float>(x), 0.0f, static_cast<float>(y) ), DirectX::XMFLOAT3( 0.0f, 0.0f, 0.0f ), mTechniques[0], NULL );

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T24[ebp], 0
	je	$LN50@InitScene
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T25[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _y$34[ebp]
	mov	DWORD PTR tv1441[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1441[ebp]
	mov	edx, DWORD PTR tv1441[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1445[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1445[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$33[ebp]
	mov	DWORD PTR tv1450[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1450[ebp]
	mov	ecx, DWORD PTR tv1450[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1454[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1454[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T26[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0CRenderObject@@QAE@QADUXMFLOAT3@DirectX@@1PAUID3DX11EffectTechnique@@2PAUID3D11ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	DWORD PTR tv498[ebp], eax
	jmp	SHORT $LN51@InitScene
$LN50@InitScene:
	mov	DWORD PTR tv498[ebp], 0
$LN51@InitScene:
	mov	ecx, DWORD PTR tv498[ebp]
	mov	DWORD PTR $T23[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T23[ebp]
	mov	DWORD PTR [edx+452404], eax

; 115  : 					mp_p2StartModel->SetColour( _GREEN );

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR __GREEN
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __GREEN+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __GREEN+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+452404]
	call	?SetColour@CRenderObject@@QAEXUXMFLOAT3@DirectX@@@Z ; CRenderObject::SetColour

; 116  : 					mp_p2StartModel->GetModel()->SetScale( 0.1f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452404]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?SetScale@CModel@@QAEXM@Z		; CModel::SetScale

; 117  : 					mp_p2StartModel->GetModel()->UpdateMatrix();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452404]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 118  : 					md_p2StartMatrix = mp_p2StartModel->GetModel()->GetWorldMatrix();

	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+452404]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?GetWorldMatrix@CModel@@QAE?AUXMMATRIX@DirectX@@XZ ; CModel::GetWorldMatrix
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??4XMMATRIX@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMMATRIX::operator=

; 119  : 					mp_matrixArray[mi_numSquares] = &md_p2StartMatrix;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+176], eax
$LN34@InitScene:

; 120  : 					break;
; 121  : 			}
; 122  : 
; 123  : 			mi_numSquares++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 124  : 		}

	jmp	$LN37@InitScene
$LN36@InitScene:

; 125  : 	}

	jmp	$LN40@InitScene
$LN39@InitScene:

; 126  : 
; 127  : 	mpObjects[0] = mp_p1StartModel;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+452400]
	mov	DWORD PTR [edx+ecx+452768], eax

; 128  : 	mpObjects[1] = mp_p2StartModel;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+452404]
	mov	DWORD PTR [ecx+eax+452768], edx

; 129  : 	mpObjects[2] = mp_chokeModel;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+452408]
	mov	DWORD PTR [ecx+eax+452768], edx

; 130  : 	miNumObjects = 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+460768], 3

; 131  : 
; 132  : 	  ///////////////////////////////////////
; 133  : 	 // Text                              //
; 134  : 	///////////////////////////////////////
; 135  : 
; 136  : 	mpSpriteBatch = new DirectX::SpriteBatch( mpd3dDeviceContext );

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T28[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T28[ebp], 0
	je	SHORT $LN52@InitScene
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452448]
	push	ecx
	mov	ecx, DWORD PTR $T28[ebp]
	call	??0SpriteBatch@DirectX@@QAE@PAUID3D11DeviceContext@@@Z ; DirectX::SpriteBatch::SpriteBatch
	mov	DWORD PTR tv585[ebp], eax
	jmp	SHORT $LN53@InitScene
$LN52@InitScene:
	mov	DWORD PTR tv585[ebp], 0
$LN53@InitScene:
	mov	edx, DWORD PTR tv585[ebp]
	mov	DWORD PTR $T27[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T27[ebp]
	mov	DWORD PTR [eax+20], ecx

; 137  : 	mpSpriteFont = new DirectX::SpriteFont(mpd3dDevice, L"Arial.spritefont");

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T30[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T30[ebp], 0
	je	SHORT $LN54@InitScene
	push	OFFSET ??_C@_1CC@BMAIPOBA@?$AAA?$AAr?$AAi?$AAa?$AAl?$AA?4?$AAs?$AAp?$AAr?$AAi?$AAt?$AAe?$AAf?$AAo?$AAn?$AAt?$AA?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452444]
	push	ecx
	mov	ecx, DWORD PTR $T30[ebp]
	call	??0SpriteFont@DirectX@@QAE@PAUID3D11Device@@PB_W@Z ; DirectX::SpriteFont::SpriteFont
	mov	DWORD PTR tv596[ebp], eax
	jmp	SHORT $LN55@InitScene
$LN54@InitScene:
	mov	DWORD PTR tv596[ebp], 0
$LN55@InitScene:
	mov	edx, DWORD PTR tv596[ebp]
	mov	DWORD PTR $T29[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T29[ebp]
	mov	DWORD PTR [eax+24], ecx

; 138  : 
; 139  : 	mb_showBase2IM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452440], 0

; 140  : 	mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 141  : 	mb_showCost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452436], 0

; 142  : 	mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 143  : 	mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 144  : 	mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0

; 145  : 	mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 146  : 	mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 147  : 
; 148  : 	  ///////////////////////////////////////
; 149  : 	 // Tweak bars                        //
; 150  : 	///////////////////////////////////////
; 151  : 
; 152  : 	int32_t result;
; 153  : 	result = TwInit(TW_DIRECT3D11, mpd3dDevice);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452444]
	push	ecx
	push	4
	call	DWORD PTR __imp__TwInit@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 154  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN29@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN29@InitScene:

; 155  : 	result = TwWindowSize(mySettings->resolutionX, mySettings->resolutionY);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__TwWindowSize@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 156  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN28@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN28@InitScene:

; 157  : 
; 158  : 		
; 159  : 	mpSettingsBar = TwNewBar( "Settings" );

	mov	esi, esp
	push	OFFSET ??_C@_08EEOHOBEO@Settings?$AA@
	call	DWORD PTR __imp__TwNewBar@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 160  : 	TwDefine(" Settings position='5 5' ");

	mov	esi, esp
	push	OFFSET ??_C@_0BK@MLELINGD@?5Settings?5position?$DN?85?55?8?5?$AA@
	call	DWORD PTR __imp__TwDefine@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 161  : 	result = TwAddSeparator( mpSettingsBar, "Graphics - requires restart", "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BM@GIBHHGMJ@Graphics?5?9?5requires?5restart?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__TwAddSeparator@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 162  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN27@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN27@InitScene:

; 163  : 	result = TwAddVarRW( mpSettingsBar, "ResolutionX", TW_TYPE_UINT32, &mySettings->resolutionX, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0M@IFKGHBCH@ResolutionX?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 164  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN26@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN26@InitScene:

; 165  : 	result = TwAddVarRW( mpSettingsBar, "ResolutionY", TW_TYPE_UINT32, &mySettings->resolutionY, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0M@JMLNEAGG@ResolutionY?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 166  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN25@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN25@InitScene:

; 167  : 	result = TwAddVarRW(mpSettingsBar, "Node Model", TW_TYPE_CHAR, &mySettings->nodeModel, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	push	ecx
	push	5
	push	OFFSET ??_C@_0L@PNCHNAPG@Node?5Model?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 168  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN24@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN24@InitScene:

; 169  : 	result = TwAddVarRW(mpSettingsBar, "Node Scale", TW_TYPE_FLOAT, &mySettings->nodeScale, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 68					; 00000044H
	push	ecx
	push	12					; 0000000cH
	push	OFFSET ??_C@_0L@OIMGCOOI@Node?5Scale?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 170  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN23@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN23@InitScene:

; 171  : 	result = TwAddVarRW(mpSettingsBar, "Spline Model", TW_TYPE_CHAR, &mySettings->splineModel, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 72					; 00000048H
	push	ecx
	push	5
	push	OFFSET ??_C@_0N@EPBODBBM@Spline?5Model?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 172  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN22@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN22@InitScene:

; 173  : 	result = TwAddVarRW(mpSettingsBar, "Spline Scale", TW_TYPE_FLOAT, &mySettings->splineScale, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 132				; 00000084H
	push	ecx
	push	12					; 0000000cH
	push	OFFSET ??_C@_0N@FKPPMPAC@Spline?5Scale?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 174  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN21@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN21@InitScene:

; 175  : 	result = TwAddSeparator(mpSettingsBar, "AI - requires recalcualte", "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BK@JKDJKFPL@AI?5?9?5requires?5recalcualte?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__TwAddSeparator@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 176  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN20@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN20@InitScene:

; 177  : 	result = TwAddVarRW( mpSettingsBar, "Wall Range", TW_TYPE_UINT32, &mySettings->wallRange, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 140				; 0000008cH
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0L@GCIJCCFE@Wall?5Range?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 178  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN19@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN19@InitScene:

; 179  : 	result = TwAddVarRW( mpSettingsBar, "Base Range", TW_TYPE_UINT32, &mySettings->baseRange, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 144				; 00000090H
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0L@NBBONMFG@Base?5Range?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 180  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN18@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN18@InitScene:

; 181  : 	result = TwAddVarRW( mpSettingsBar, "Heavy Turret Range", TW_TYPE_UINT32, &mySettings->HTRange, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 156				; 0000009cH
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0BD@BMBFNPNO@Heavy?5Turret?5Range?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 182  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN17@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN17@InitScene:

; 183  : 	result = TwAddVarRW( mpSettingsBar, "Medium Turret Range", TW_TYPE_UINT32, &mySettings->MTRange, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 152				; 00000098H
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0BE@LFFKHKAN@Medium?5Turret?5Range?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 184  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN16@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN16@InitScene:

; 185  : 	result = TwAddVarRW( mpSettingsBar, "Light Turret Range", TW_TYPE_UINT32, &mySettings->LTRange, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 148				; 00000094H
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0BD@HEBLKGAH@Light?5Turret?5Range?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 186  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN15@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN15@InitScene:

; 187  : 	result = TwAddVarRW(mpSettingsBar, "Minimum Path Length", TW_TYPE_UINT32, &mySettings->MinPathLength, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 160				; 000000a0H
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0BE@EOIDACPB@Minimum?5Path?5Length?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 188  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN14@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN14@InitScene:

; 189  : 	result = TwAddVarRW(mpSettingsBar, "Maximum Path Length", TW_TYPE_FLOAT, &mySettings->MaxPathLength, "min=0.1 max=0.9 step=0.1");

	mov	esi, esp
	push	OFFSET ??_C@_0BJ@BKJMPLKA@min?$DN0?41?5max?$DN0?49?5step?$DN0?41?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 164				; 000000a4H
	push	ecx
	push	12					; 0000000cH
	push	OFFSET ??_C@_0BE@GHPNPPOJ@Maximum?5Path?5Length?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 190  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN13@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN13@InitScene:

; 191  : 	result = TwAddVarRW(mpSettingsBar, "ChokeThreshold", TW_TYPE_UINT32, &mySettings->ChokeThreshold, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 168				; 000000a8H
	push	ecx
	push	11					; 0000000bH
	push	OFFSET ??_C@_0P@HKLMEJGE@ChokeThreshold?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__TwAddVarRW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 192  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN12@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN12@InitScene:

; 193  : 
; 194  : 	mpCalculationsBar = TwNewBar("Calculations");

	mov	esi, esp
	push	OFFSET ??_C@_0N@BCBLNKGN@Calculations?$AA@
	call	DWORD PTR __imp__TwNewBar@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 195  : 	TwDefine( " Calculations position='205 5' " );

	mov	esi, esp
	push	OFFSET ??_C@_0CA@JIMFFDAA@?5Calculations?5position?$DN?8205?55?8?5?$AA@
	call	DWORD PTR __imp__TwDefine@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 196  : 	result = TwAddButton(mpCalculationsBar, "Recalculate Walls", CalculateWallIM, mc_map, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ?CalculateWallIM@@YGXPAX@Z	; CalculateWallIM
	push	OFFSET ??_C@_0BC@NDAFGNJG@Recalculate?5Walls?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 197  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN11@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN11@InitScene:

; 198  : 	result = TwAddButton( mpCalculationsBar, "Recalculate Path", CalculatePath, mc_map, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ?CalculatePath@@YGXPAX@Z		; CalculatePath
	push	OFFSET ??_C@_0BB@NOOMKGDN@Recalculate?5Path?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 199  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN10@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN10@InitScene:

; 200  : 	result = TwAddButton(mpCalculationsBar, "Visualise Path", TWVisualisePath, mp_self, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ?TWVisualisePath@@YGXPAX@Z	; TWVisualisePath
	push	OFFSET ??_C@_0P@OPKEOGP@Visualise?5Path?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 201  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN9@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN9@InitScene:

; 202  : 	result = TwAddButton(mpCalculationsBar, "Place Heavy Turret", TwPlaceHeavyTurret, mc_map, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ?TwPlaceHeavyTurret@@YGXPAX@Z	; TwPlaceHeavyTurret
	push	OFFSET ??_C@_0BD@ILICLLBG@Place?5Heavy?5Turret?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 203  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN8@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN8@InitScene:

; 204  : 	result = TwAddButton(mpCalculationsBar, "Place Medium Turret", TwPlaceMediumTurret, mc_map, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ?TwPlaceMediumTurret@@YGXPAX@Z	; TwPlaceMediumTurret
	push	OFFSET ??_C@_0BE@CHBMJNCN@Place?5Medium?5Turret?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 205  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN7@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN7@InitScene:

; 206  : 	result = TwAddButton(mpCalculationsBar, "Place Light Turret", TwPlaceLightTurret, mc_map, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ?TwPlaceLightTurret@@YGXPAX@Z	; TwPlaceLightTurret
	push	OFFSET ??_C@_0BD@GOKMAAEO@Place?5Light?5Turret?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 207  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN6@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN6@InitScene:

; 208  : 	result = TwAddButton(mpCalculationsBar, "Visualise Turrets", TwVisualiseTurrets, mp_self, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ?TwVisualiseTurrets@@YGXPAX@Z	; TwVisualiseTurrets
	push	OFFSET ??_C@_0BC@MANJMCAL@Visualise?5Turrets?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 209  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN5@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN5@InitScene:

; 210  : 	result = TwAddVarRO(mpCalculationsBar, "Last Calculation Time", TW_TYPE_FLOAT, &mc_map->mf_calcTime, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 38152				; 00009508H
	push	ecx
	push	12					; 0000000cH
	push	OFFSET ??_C@_0BG@FEONHGJL@Last?5Calculation?5Time?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__TwAddVarRO@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 211  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN4@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN4@InitScene:

; 212  : 
; 213  : 
; 214  : 	mpFileBar = TwNewBar("Files");

	mov	esi, esp
	push	OFFSET ??_C@_05DIOAMJFE@Files?$AA@
	call	DWORD PTR __imp__TwNewBar@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 215  : 	TwDefine( " Files position='410 5' " );

	mov	esi, esp
	push	OFFSET ??_C@_0BJ@OBCGGGNI@?5Files?5position?$DN?8410?55?8?5?$AA@
	call	DWORD PTR __imp__TwDefine@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 216  : 	result = TwAddButton(mpFileBar, "Reload Settings", ReloadSettings, mySettings, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ?ReloadSettings@@YGXPAX@Z	; ReloadSettings
	push	OFFSET ??_C@_0BA@ODBJHPLI@Reload?5Settings?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 217  : 	TweakError( result )

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN3@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	$LN42@InitScene
$LN3@InitScene:

; 218  : 	result = TwAddButton( mpFileBar, "Write Settings", WriteSettings, mySettings, "" );

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ?WriteSettings@@YGXPAX@Z		; WriteSettings
	push	OFFSET ??_C@_0P@KLFADJFA@Write?5Settings?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 219  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	SHORT $LN42@InitScene
$LN2@InitScene:

; 220  : 	result = TwAddSeparator(mpFileBar, "Map", "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_03NBOPHIOC@Map?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR __imp__TwAddSeparator@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 221  : 	TweakError(result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN1@InitScene
	mov	esi, esp
	call	DWORD PTR __imp__TwGetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	al, al
	jmp	SHORT $LN42@InitScene
$LN1@InitScene:

; 222  : 	result = TwAddButton(mpFileBar, "Write map XML", WriteMapXML, mc_map, "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ?WriteMapXML@@YGXPAX@Z		; WriteMapXML
	push	OFFSET ??_C@_0O@HOOOPNPM@Write?5map?5XML?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR __imp__TwAddButton@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 223  : 	return true;

	mov	al, 1
$LN42@InitScene:

; 224  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
	npad	1
$LN71@InitScene:
	DD	$LN33@InitScene
	DD	$LN32@InitScene
	DD	$LN31@InitScene
	DD	$LN30@InitScene
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$6:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$10:
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$11:
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$12:
	mov	eax, DWORD PTR $T28[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$13:
	mov	eax, DWORD PTR $T30[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InitScene@CScene@@QAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-888]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitScene@CScene@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitScene@CScene@@QAE_NXZ ENDP				; CScene::InitScene
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?LoadEffectFile@CScene@@QAE_NXZ
_TEXT	SEGMENT
tv169 = -208						; size = 4
tv154 = -208						; size = 4
tv139 = -208						; size = 4
tv92 = -208						; size = 4
_this$ = -8						; size = 4
?LoadEffectFile@CScene@@QAE_NXZ PROC			; CScene::LoadEffectFile, COMDAT
; _this$ = ecx

; 931  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 932  : 	if( !LoadTechnique() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadTechnique@CScene@@AAE_NXZ		; CScene::LoadTechnique
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@LoadEffect

; 933  : 	{
; 934  : 		return false; 

	xor	al, al
	jmp	$LN2@LoadEffect
$LN1@LoadEffect:

; 935  : 	}
; 936  : 	
; 937  : 	// Now we can select techniques from the compiled effect file
; 938  : 	// Regular techniques for the main scene
; 939  : 	//mTechniques[0] = NULL;
; 940  : 	mTechniques[ 0]	= Effect->GetTechniqueByName( "SingleColour" );

	mov	esi, esp
	push	OFFSET ??_C@_0N@BOAANELO@SingleColour?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476916]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+476916]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+56]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+476920], eax

; 941  : 	miNumTechniques = 5;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+477160], 5

; 942  : 	
; 943  : 	// Create special variables to allow us to access global variables in the shaders from C++
; 944  : 	WorldMatrixVar		= Effect->GetVariableByName( "WorldMatrix" )->AsMatrix();

	mov	esi, esp
	push	OFFSET ??_C@_0M@JIFPIELG@WorldMatrix?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476916]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+476916]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv92[ebp], eax
	mov	eax, DWORD PTR tv92[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+477404], eax

; 945  : 	ViewMatrixVar		= Effect->GetVariableByName( "ViewMatrix"  )->AsMatrix();

	mov	esi, esp
	push	OFFSET ??_C@_0L@BCBAMPKD@ViewMatrix?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476916]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+476916]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv139[ebp], eax
	mov	eax, DWORD PTR tv139[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv139[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+477408], eax

; 946  : 	ProjMatrixVar		= Effect->GetVariableByName( "ProjMatrix"  )->AsMatrix();

	mov	esi, esp
	push	OFFSET ??_C@_0L@FHHLNBJL@ProjMatrix?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476916]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+476916]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv154[ebp], eax
	mov	eax, DWORD PTR tv154[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv154[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+477412], eax

; 947  : 
; 948  : 	// We access the texture variable in the shader in the same way as we have before for matrices, light data etc.
; 949  : 	// Only difference is that this variable is a "Shader Resource"
; 950  : 	//DiffuseMapVar = Effect->GetVariableByName( "DiffuseMap" )->AsShaderResource();
; 951  : 	//NormalMapVar = Effect->GetVariableByName( "NormalMap" )->AsShaderResource();
; 952  : 
; 953  : 	//Camera Position
; 954  : 	//dxCameraPos = Effect->GetVariableByName( "cameraPos" )->AsVector();
; 955  : 
; 956  : 	// Other shader variables
; 957  : 	ModelColourVar = Effect->GetVariableByName( "ModelColour"  )->AsVector();

	mov	esi, esp
	push	OFFSET ??_C@_0M@FMIDCGNI@ModelColour?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476916]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+476916]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR tv169[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+477428], eax

; 958  : 
; 959  : 	//Lighting Values
; 960  : 	//dxLightPosA = Effect->GetVariableByName( "lightPos" )->AsVector();
; 961  : 	//dxLightColourA = Effect->GetVariableByName( "lightColour" )->AsVector();
; 962  : 	//dxLightBrightnessA = Effect->GetVariableByName( "lightBright" )->AsVector();
; 963  : 	
; 964  : 	//dxAmbientColour = Effect->GetVariableByName( "ambientColour" )->AsVector();
; 965  : 
; 966  : 	//dxWiggle = Effect->GetVariableByName( "wiggle" )->AsScalar();
; 967  : 	//dxOutlineThickness = Effect->GetVariableByName( "OutlineThickness" )->AsScalar();
; 968  : 
; 969  : 	//ClipPlaneVar      = Effect->GetVariableByName( "ClipPlane"      )->AsVector();
; 970  : 
; 971  : 	return true;

	mov	al, 1
$LN2@LoadEffect:

; 972  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadEffectFile@CScene@@QAE_NXZ ENDP			; CScene::LoadEffectFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?ReleaseResources@CScene@@QAEXXZ
_TEXT	SEGMENT
tv94 = -292						; size = 4
tv83 = -292						; size = 4
$T1 = -284						; size = 4
$T2 = -272						; size = 4
$T3 = -260						; size = 4
$T4 = -248						; size = 4
_i$5 = -44						; size = 4
_i$6 = -32						; size = 4
_i$7 = -20						; size = 4
_this$ = -8						; size = 4
?ReleaseResources@CScene@@QAEXXZ PROC			; CScene::ReleaseResources, COMDAT
; _this$ = ecx

; 772  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 773  : 	// The D3D setup and preparation of the geometry created several objects that use up memory (e.g. textures, vertex/index buffers etc.)
; 774  : 	// Each object that allocates memory (or hardware resources) needs to be "released" when we exit the program
; 775  : 	// There is similar code in every D3D program, but the list of objects that need to be released depends on what was created
; 776  : 	// Test each variable to see if it exists before deletion
; 777  : 	if( mpd3dDeviceContext )     mpd3dDeviceContext->ClearState();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+452448], 0
	je	SHORT $LN17@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452448]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452448]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+440]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@ReleaseRes:

; 778  : 
; 779  : 	//delete Camera;
; 780  : 
; 781  : 	for(int i = 0; i < miNumObjects; i++)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN16@ReleaseRes
$LN15@ReleaseRes:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN16@ReleaseRes:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$7[ebp]
	cmp	ecx, DWORD PTR [eax+460768]
	jge	SHORT $LN14@ReleaseRes

; 782  : 	{
; 783  : 		delete mpObjects[i];

	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+452768]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN20@ReleaseRes
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GCRenderObject@@QAEPAXI@Z
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN21@ReleaseRes
$LN20@ReleaseRes:
	mov	DWORD PTR tv83[ebp], 0
$LN21@ReleaseRes:

; 784  : 	}

	jmp	SHORT $LN15@ReleaseRes
$LN14@ReleaseRes:

; 785  : 
; 786  : 	for(int i = 0; i < miNumLights; i++)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN13@ReleaseRes
$LN12@ReleaseRes:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN13@ReleaseRes:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$6[ebp]
	cmp	ecx, DWORD PTR [eax+460892]
	jge	SHORT $LN11@ReleaseRes

; 787  : 	{
; 788  : 		delete mpLights[i];

	mov	eax, DWORD PTR _i$6[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+460772]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN22@ReleaseRes
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GCLight@@QAEPAXI@Z
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN23@ReleaseRes
$LN22@ReleaseRes:
	mov	DWORD PTR tv94[ebp], 0
$LN23@ReleaseRes:

; 789  : 	}

	jmp	SHORT $LN12@ReleaseRes
$LN11@ReleaseRes:

; 790  : 	
; 791  : 	for(int i = 0; i < miNumMaps; i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN10@ReleaseRes
$LN9@ReleaseRes:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN10@ReleaseRes:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$5[ebp]
	cmp	ecx, DWORD PTR [eax+476896]
	jge	SHORT $LN8@ReleaseRes

; 792  : 	{
; 793  : 		if ( mpMaps[i] )

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+460896], 0
	je	SHORT $LN7@ReleaseRes

; 794  : 			mpMaps[i]->Release();

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+460896]
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+460896]
	mov	ecx, DWORD PTR [edx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@ReleaseRes:

; 795  : 	}

	jmp	SHORT $LN9@ReleaseRes
$LN8@ReleaseRes:

; 796  : 
; 797  : 	if( Effect )           Effect->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+476916], 0
	je	SHORT $LN6@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476916]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+476916]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@ReleaseRes:

; 798  : 	if( DepthStencilView ) DepthStencilView->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+477472], 0
	je	SHORT $LN5@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477472]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477472]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@ReleaseRes:

; 799  : 	if( RenderTargetView ) RenderTargetView->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+477476], 0
	je	SHORT $LN4@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477476]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477476]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@ReleaseRes:

; 800  : 	if( DepthStencil )     DepthStencil->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+477468], 0
	je	SHORT $LN3@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477468]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477468]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@ReleaseRes:

; 801  : 	if( SwapChain )        SwapChain->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+477464], 0
	je	SHORT $LN2@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477464]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477464]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@ReleaseRes:

; 802  : 	if( mpd3dDevice )     mpd3dDevice->Release();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+452444], 0
	je	SHORT $LN1@ReleaseRes
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452444]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452444]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@ReleaseRes:

; 803  : 	TwTerminate();

	mov	esi, esp
	call	DWORD PTR __imp__TwTerminate@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 804  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ReleaseResources@CScene@@QAEXXZ ENDP			; CScene::ReleaseResources
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?InitDevice@CScene@@QAE_NXZ
_TEXT	SEGMENT
_vp$ = -280						; size = 24
_descDSV$ = -248					; size = 24
_descDepth$ = -216					; size = 44
_pBackBuffer$ = -164					; size = 4
_featureLevels$ = -152					; size = 28
_sd$ = -116						; size = 60
_rc$ = -48						; size = 16
_hr$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?InitDevice@CScene@@QAE_NXZ PROC			; CScene::InitDevice, COMDAT
; _this$ = ecx

; 644  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 476				; 000001dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-476]
	mov	ecx, 119				; 00000077H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 645  : 	// Many DirectX functions return a "HRESULT" variable to indicate success or failure. Microsoft code often uses
; 646  : 	// the FAILED macro to test this variable, you'll see it throughout the code - it's fairly self explanatory.
; 647  : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 648  : 
; 649  : 
; 650  : 	////////////////////////////////
; 651  : 	// Initialise Direct3D
; 652  : 
; 653  : 	// Calculate the visible area the window we are using - the "client rectangle" refered to in the first function is the 
; 654  : 	// size of the interior of the window, i.e. excluding the frame and title
; 655  : 	RECT rc;
; 656  : 	GetClientRect( HWnd, &rc );

	mov	esi, esp
	lea	eax, DWORD PTR _rc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477488]
	push	edx
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 657  : 	mViewportWidth = rc.right - rc.left;

	mov	eax, DWORD PTR _rc$[ebp+8]
	sub	eax, DWORD PTR _rc$[ebp]
	mov	DWORD PTR ?mViewportWidth@CScene@@0HA, eax ; CScene::mViewportWidth

; 658  : 	mViewportHeight = rc.bottom - rc.top;

	mov	eax, DWORD PTR _rc$[ebp+12]
	sub	eax, DWORD PTR _rc$[ebp+4]
	mov	DWORD PTR ?mViewportHeight@CScene@@0HA, eax ; CScene::mViewportHeight

; 659  : 
; 660  : 
; 661  : 	// Create a Direct3D device (i.e. initialise D3D), and create a swap-chain (create a back buffer to render to)
; 662  : 	DXGI_SWAP_CHAIN_DESC sd;         // Structure to contain all the information needed
; 663  : 	ZeroMemory( &sd, sizeof( sd ) ); // Clear the structure to 0 - common Microsoft practice, not really good style

	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _sd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 664  : 	sd.BufferCount = 1;

	mov	DWORD PTR _sd$[ebp+40], 1

; 665  : 	sd.BufferDesc.Width = mViewportWidth;             // Target window size

	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	mov	DWORD PTR _sd$[ebp], eax

; 666  : 	sd.BufferDesc.Height = mViewportHeight;           // --"--

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	mov	DWORD PTR _sd$[ebp+4], eax

; 667  : 	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // Pixel format of target window

	mov	DWORD PTR _sd$[ebp+16], 28		; 0000001cH

; 668  : 	sd.BufferDesc.RefreshRate.Numerator = 60;         // Refresh rate of monitor

	mov	DWORD PTR _sd$[ebp+8], 60		; 0000003cH

; 669  : 	sd.BufferDesc.RefreshRate.Denominator = 1;         // --"--

	mov	DWORD PTR _sd$[ebp+12], 1

; 670  : 	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

	mov	DWORD PTR _sd$[ebp+36], 32		; 00000020H

; 671  : 	sd.SampleDesc.Count = 1;

	mov	DWORD PTR _sd$[ebp+28], 1

; 672  : 	sd.SampleDesc.Quality = 0;

	mov	DWORD PTR _sd$[ebp+32], 0

; 673  : 	sd.OutputWindow = HWnd;                          // Target window

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477488]
	mov	DWORD PTR _sd$[ebp+44], ecx

; 674  : 	sd.Windowed = TRUE; // Whether to render in a window (TRUE) or go fullscreen (FALSE)

	mov	DWORD PTR _sd$[ebp+48], 1

; 675  : 
; 676  : 	D3D_FEATURE_LEVEL featureLevels[] = 
; 677  :     {
; 678  :         D3D_FEATURE_LEVEL_11_1,
; 679  :         D3D_FEATURE_LEVEL_11_0,
; 680  :         D3D_FEATURE_LEVEL_10_1,
; 681  :         D3D_FEATURE_LEVEL_10_0,
; 682  :         D3D_FEATURE_LEVEL_9_3,
; 683  :         D3D_FEATURE_LEVEL_9_2,
; 684  :         D3D_FEATURE_LEVEL_9_1
; 685  :     };

	mov	DWORD PTR _featureLevels$[ebp], 45312	; 0000b100H
	mov	DWORD PTR _featureLevels$[ebp+4], 45056	; 0000b000H
	mov	DWORD PTR _featureLevels$[ebp+8], 41216	; 0000a100H
	mov	DWORD PTR _featureLevels$[ebp+12], 40960 ; 0000a000H
	mov	DWORD PTR _featureLevels$[ebp+16], 37632 ; 00009300H
	mov	DWORD PTR _featureLevels$[ebp+20], 37376 ; 00009200H
	mov	DWORD PTR _featureLevels$[ebp+24], 37120 ; 00009100H

; 686  : 	//D3D_FEATURE_LEVEL fLevel;
; 687  : 
; 688  : 	/*hr = D3D11CreateDeviceAndSwapChain( 
; 689  : 		NULL,						//Adaptor - Use default
; 690  : 		D3D_DRIVER_TYPE_HARDWARE,	//Driver Type - Hardware, always hardware. 
; 691  : 		0,							//Software rasteriser. Yeah right. Null because we are using hardware.
; 692  : 		2,							//Build flags (2 = debug)
; 693  : 		featureLevels,				//feature levels (see above)
; 694  : 		7,							//number of feature levels
; 695  : 		D3D11_SDK_VERSION,			//SDK version
; 696  : 		&sd,						//SwapChainDesc
; 697  : 		&SwapChain,					//SwapChain
; 698  : 		&mpd3dDevice,				//Device
; 699  : 		&fLevel,					//chosen feature level
; 700  : 		&mpd3dDeviceContext			//Device context
; 701  : 		);		*/	
; 702  : 
; 703  : 	hr = D3D11CreateDeviceAndSwapChain( NULL, D3D_DRIVER_TYPE_HARDWARE, 0, 2, 0, 0, D3D11_SDK_VERSION, &sd, &SwapChain, &mpd3dDevice, NULL, &mpd3dDeviceContext ); //D3D11_CREATE_DEVICE_DEBUG

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 452448				; 0006e760H
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452444				; 0006e75cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 477464				; 00074918H
	push	edx
	lea	eax, DWORD PTR _sd$[ebp]
	push	eax
	push	7
	push	0
	push	0
	push	2
	push	0
	push	1
	push	0
	call	_D3D11CreateDeviceAndSwapChain@48
	mov	DWORD PTR _hr$[ebp], eax

; 704  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN5@InitDevice:

; 705  : 
; 706  : 
; 707  : 	// Specify the render target as the back-buffer - this is an advanced topic. This code almost always occurs in the standard D3D setup
; 708  : 	ID3D11Texture2D* pBackBuffer;
; 709  : 	hr = SwapChain->GetBuffer( 0, __uuidof( ID3D11Texture2D ), ( LPVOID* )&pBackBuffer );

	mov	esi, esp
	lea	eax, DWORD PTR _pBackBuffer$[ebp]
	push	eax
	push	OFFSET __GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477464]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477464]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 710  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN4@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN4@InitDevice:

; 711  : 	hr = mpd3dDevice->CreateRenderTargetView( pBackBuffer, NULL, &RenderTargetView );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 477476				; 00074924H
	mov	esi, esp
	push	eax
	push	0
	mov	ecx, DWORD PTR _pBackBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452444]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+452444]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+36]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 712  : 	pBackBuffer->Release();

	mov	eax, DWORD PTR _pBackBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pBackBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 713  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN3@InitDevice:

; 714  : 
; 715  : 
; 716  : 	// Create a texture (bitmap) to use for a depth buffer
; 717  : 	D3D11_TEXTURE2D_DESC descDepth;
; 718  : 	descDepth.Width = mViewportWidth;

	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	mov	DWORD PTR _descDepth$[ebp], eax

; 719  : 	descDepth.Height = mViewportHeight;

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	mov	DWORD PTR _descDepth$[ebp+4], eax

; 720  : 	descDepth.MipLevels = 1;

	mov	DWORD PTR _descDepth$[ebp+8], 1

; 721  : 	descDepth.ArraySize = 1;

	mov	DWORD PTR _descDepth$[ebp+12], 1

; 722  : 	//descDepth.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;		// 24 bits for depth, 8 for stencil - more memory efficient
; 723  : 	descDepth.Format = DXGI_FORMAT_R32_TYPELESS;

	mov	DWORD PTR _descDepth$[ebp+16], 39	; 00000027H

; 724  : 	//descDepth.Format = DXGI_FORMAT_D32_FLOAT;				// 32 bit float depth only 
; 725  : 	//descDepth.Format = DXGI_FORMAT_D32_FLOAT_S8X24_UINT;	// 32 bit depth + 8 for stencil, 24 unused bytes - more precise depth buffer
; 726  : 	descDepth.SampleDesc.Count = 1;

	mov	DWORD PTR _descDepth$[ebp+20], 1

; 727  : 	descDepth.SampleDesc.Quality = 0;

	mov	DWORD PTR _descDepth$[ebp+24], 0

; 728  : 	descDepth.Usage = D3D11_USAGE_DEFAULT;

	mov	DWORD PTR _descDepth$[ebp+28], 0

; 729  : 	descDepth.BindFlags = D3D11_BIND_DEPTH_STENCIL;

	mov	DWORD PTR _descDepth$[ebp+32], 64	; 00000040H

; 730  : 	descDepth.CPUAccessFlags = 0;

	mov	DWORD PTR _descDepth$[ebp+36], 0

; 731  : 	descDepth.MiscFlags = 0;

	mov	DWORD PTR _descDepth$[ebp+40], 0

; 732  : 	hr = mpd3dDevice->CreateTexture2D( &descDepth, NULL, &DepthStencil );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 477468				; 0007491cH
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR _descDepth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452444]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+452444]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+20]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 733  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN2@InitDevice:

; 734  : 
; 735  : 	// Create the depth stencil view, i.e. indicate that the texture just created is to be used as a depth buffer
; 736  : 	D3D11_DEPTH_STENCIL_VIEW_DESC descDSV;
; 737  : 	//descDSV.Format = descDepth.Format;
; 738  : 	descDSV.Format = DXGI_FORMAT_D32_FLOAT;

	mov	DWORD PTR _descDSV$[ebp], 40		; 00000028H

; 739  : 	descDSV.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;

	mov	DWORD PTR _descDSV$[ebp+4], 3

; 740  : 	descDSV.Texture2D.MipSlice = 0;

	mov	DWORD PTR _descDSV$[ebp+12], 0

; 741  : 	descDSV.Flags = 0;

	mov	DWORD PTR _descDSV$[ebp+8], 0

; 742  : 	hr = mpd3dDevice->CreateDepthStencilView( DepthStencil, &descDSV, &DepthStencilView );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 477472				; 00074920H
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _descDSV$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477468]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+452444]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452444]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 743  : 	if( FAILED( hr ) ) return false;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@InitDevice
	xor	al, al
	jmp	$LN6@InitDevice
$LN1@InitDevice:

; 744  : 
; 745  : 	// Select the back buffer and depth buffer to use for rendering now
; 746  : 	mpd3dDeviceContext->OMSetRenderTargets( 1, &RenderTargetView, DepthStencilView );

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477472]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 477476				; 00074924H
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452448]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452448]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+132]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 747  : 
; 748  : 
; 749  : 	// Setup the viewport - defines which part of the window we will render to, almost always the whole window
; 750  : 	D3D11_VIEWPORT vp;
; 751  : 	vp.Width = static_cast<float>(mViewportWidth);

	cvtsi2ss xmm0, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	movss	DWORD PTR _vp$[ebp+8], xmm0

; 752  : 	vp.Height = static_cast<float>(mViewportHeight);

	cvtsi2ss xmm0, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	movss	DWORD PTR _vp$[ebp+12], xmm0

; 753  : 	vp.MinDepth = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vp$[ebp+16], xmm0

; 754  : 	vp.MaxDepth = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vp$[ebp+20], xmm0

; 755  : 	vp.TopLeftX = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vp$[ebp], xmm0

; 756  : 	vp.TopLeftY = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vp$[ebp+4], xmm0

; 757  : 	mpd3dDeviceContext->RSSetViewports( 1, &vp );

	mov	esi, esp
	lea	eax, DWORD PTR _vp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+452448]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452448]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+176]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 758  : 
; 759  : 	CCamera::SetViewport( mViewportWidth, mViewportHeight );

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	push	eax
	mov	ecx, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	push	ecx
	call	?SetViewport@CCamera@@SAXHH@Z		; CCamera::SetViewport
	add	esp, 8

; 760  : 	
; 761  : 	CModel::SetDevice( mpd3dDevice );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452444]
	push	ecx
	call	?SetDevice@CModel@@SAXPAUID3D11Device@@@Z ; CModel::SetDevice
	add	esp, 4

; 762  : 	CModel::SetDeviceContext( mpd3dDeviceContext );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452448]
	push	ecx
	call	?SetDeviceContext@CModel@@SAXPAUID3D11DeviceContext@@@Z ; CModel::SetDeviceContext
	add	esp, 4

; 763  : 
; 764  : 	//test->SetDevice( mpd3dDevice );
; 765  : 
; 766  : 	return true;

	mov	al, 1
$LN6@InitDevice:

; 767  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@InitDevice
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 476				; 000001dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN16@InitDevice:
	DD	7
	DD	$LN15@InitDevice
$LN15@InitDevice:
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN8@InitDevice
	DD	-116					; ffffff8cH
	DD	60					; 0000003cH
	DD	$LN9@InitDevice
	DD	-152					; ffffff68H
	DD	28					; 0000001cH
	DD	$LN10@InitDevice
	DD	-164					; ffffff5cH
	DD	4
	DD	$LN11@InitDevice
	DD	-216					; ffffff28H
	DD	44					; 0000002cH
	DD	$LN12@InitDevice
	DD	-248					; ffffff08H
	DD	24					; 00000018H
	DD	$LN13@InitDevice
	DD	-280					; fffffee8H
	DD	24					; 00000018H
	DD	$LN14@InitDevice
$LN14@InitDevice:
	DB	118					; 00000076H
	DB	112					; 00000070H
	DB	0
$LN13@InitDevice:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	68					; 00000044H
	DB	83					; 00000053H
	DB	86					; 00000056H
	DB	0
$LN12@InitDevice:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN11@InitDevice:
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN10@InitDevice:
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	115					; 00000073H
	DB	0
$LN9@InitDevice:
	DB	115					; 00000073H
	DB	100					; 00000064H
	DB	0
$LN8@InitDevice:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
?InitDevice@CScene@@QAE_NXZ ENDP			; CScene::InitDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ??1CScene@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CScene@@QAE@XZ PROC					; CScene::~CScene, COMDAT
; _this$ = ecx

; 30   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CScene@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 31   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388368				; 0005ed10H
	call	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	call	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	call	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	call	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	call	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68208				; 00010a70H
	call	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	call	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CScene@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??1CScene@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68208				; 00010a70H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??1CScene@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??1CScene@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??1CScene@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??1CScene@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__ehhandler$??1CScene@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CScene@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CScene@@QAE@XZ ENDP					; CScene::~CScene
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ??0CScene@@QAE@XZ
_TEXT	SEGMENT
$T2 = -272						; size = 12
$T3 = -252						; size = 12
$T4 = -232						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CScene@@QAE@XZ PROC					; CScene::CScene, COMDAT
; _this$ = ecx

; 6    : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CScene@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0XMMATRIX@DirectX@@QAE@XZ		; DirectX::XMMATRIX::XMMATRIX
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0XMMATRIX@DirectX@@QAE@XZ		; DirectX::XMMATRIX::XMMATRIX
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	call	??0ModelBatch@@QAE@XZ			; ModelBatch::ModelBatch
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68208				; 00010a70H
	call	??0ModelBatch@@QAE@XZ			; ModelBatch::ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	call	??0ModelBatch@@QAE@XZ			; ModelBatch::ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	call	??0ModelBatch@@QAE@XZ			; ModelBatch::ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	call	??0ModelBatch@@QAE@XZ			; ModelBatch::ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	call	??0ModelBatch@@QAE@XZ			; ModelBatch::ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388368				; 0005ed10H
	call	??0ModelBatch@@QAE@XZ			; ModelBatch::ModelBatch
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	ecx
	movss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f490fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	??0CCamera@@QAE@UXMFLOAT3@DirectX@@0MMM@Z ; CCamera::CCamera
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 476900				; 000746e4H
	call	??0XMFLOAT3@DirectX@@QAE@XZ		; DirectX::XMFLOAT3::XMFLOAT3

; 7    : 	//set counters to 0
; 8    : 	miNumObjects = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+460768], 0

; 9    : 	miNumLights = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+460892], 0

; 10   : 	miNumMaps = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+476896], 0

; 11   : 
; 12   : 	//set the ambient colour for the scene
; 13   : 	AmbientColour = DirectX::XMFLOAT3( 0.2f, 0.2f, 0.8f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 476900				; 000746e4H
	call	??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT3::operator=

; 14   : 
; 15   : 	//set the controlled object to the mirror
; 16   : 	mControlObject = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+476912], 0

; 17   : 	
; 18   : 	mi_numSquares = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 19   : 
; 20   : 	mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 21   : 	mb_showWallIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452437], 0

; 22   : 	mb_showPathIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452438], 0

; 23   : 	mb_showBaseIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452439], 0

; 24   : 	mb_showHTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452441], 0

; 25   : 	mb_showLTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452443], 0

; 26   : 	mb_showMTIM = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452442], 0

; 27   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CScene@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??0CScene@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68208				; 00010a70H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??0CScene@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132240				; 00020490H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??0CScene@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196272				; 0002feb0H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??0CScene@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260304				; 0003f8d0H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??0CScene@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 324336				; 0004f2f0H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__unwindfunclet$??0CScene@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388368				; 0005ed10H
	jmp	??1ModelBatch@@QAE@XZ			; ModelBatch::~ModelBatch
__ehhandler$??0CScene@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CScene@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CScene@@QAE@XZ ENDP					; CScene::CScene
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?LoadTechnique@CScene@@AAE_NXZ
_TEXT	SEGMENT
tv151 = -588						; size = 4
$T1 = -580						; size = 260
_bufferSize$ = -120					; size = 4
_bufferPointer$ = -108					; size = 4
_SHADER_RELEASE$ = -96					; size = 4
_SHADER_DEBUG$ = -84					; size = 4
_flags2$ = -72						; size = 4
_dwShaderFlags$ = -60					; size = 4
_pErrors$ = -48						; size = 4
_pEffectBlob$ = -36					; size = 4
_hr$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?LoadTechnique@CScene@@AAE_NXZ PROC			; CScene::LoadTechnique, COMDAT
; _this$ = ecx

; 886  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 588				; 0000024cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-588]
	mov	ecx, 147				; 00000093H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 	HRESULT hr;
; 888  : 	ID3DBlob* pEffectBlob;
; 889  : 	ID3DBlob* pErrors; // This strangely typed variable collects any errors when compiling the effect file
; 890  : 	DWORD dwShaderFlags = D3D10_SHADER_ENABLE_STRICTNESS; // These "flags" are used to set the compiler options

	mov	DWORD PTR _dwShaderFlags$[ebp], 2048	; 00000800H

; 891  : 	DWORD flags2 = D3DCOMPILE_DEBUG | D3DCOMPILE_WARNINGS_ARE_ERRORS | D3DCOMPILE_ENABLE_BACKWARDS_COMPATIBILITY;

	mov	DWORD PTR _flags2$[ebp], 266241		; 00041001H

; 892  : 
; 893  : 	//Compile Technique file
; 894  : 	hr = D3DX11CompileFromFile(
; 895  : 		L"./Shaders/Technique.fx",
; 896  : 		NULL,
; 897  : 		NULL,
; 898  : 		NULL,
; 899  : 		"fx_5_0",
; 900  : 		dwShaderFlags,
; 901  : 		0,
; 902  : 		NULL,
; 903  : 		&pEffectBlob,
; 904  : 		&pErrors,
; 905  : 		&hr
; 906  : 		);

	lea	eax, DWORD PTR _hr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pErrors$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pEffectBlob$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _dwShaderFlags$[ebp]
	push	eax
	push	OFFSET ??_C@_06KIJENJAF@fx_5_0?$AA@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_1CO@GFEFGPPD@?$AA?4?$AA?1?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AAs?$AA?1?$AAT?$AAe?$AAc?$AAh?$AAn?$AAi?$AAq?$AAu?$AAe?$AA?4?$AAf?$AAx?$AA?$AA@
	call	_D3DX11CompileFromFileW@44
	mov	DWORD PTR _hr$[ebp], eax

; 907  : 
; 908  : 	if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN4@LoadTechni

; 909  : 	{
; 910  : 		if( pErrors != 0 )  MessageBox( NULL, CA2CT( reinterpret_cast<char*>(pErrors->GetBufferPointer()) ), L"Error", MB_OK ); // Compiler error: display error message

	cmp	DWORD PTR _pErrors$[ebp], 0
	je	SHORT $LN3@LoadTechni
	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	mov	eax, DWORD PTR _pErrors$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edi, esp
	mov	edx, DWORD PTR _pErrors$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z	; ATL::CA2WEX<128>::CA2WEX<128>
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR tv151[ebp]
	call	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ	; ATL::CA2WEX<128>::operator wchar_t *
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ		; ATL::CA2WEX<128>::~CA2WEX<128>
	jmp	SHORT $LN2@LoadTechni
$LN3@LoadTechni:

; 911  : 		else               MessageBox( NULL, L"Error loading Vertex Shader FX file. Ensure your FX file is in the same folder as this executable.", L"Error", MB_OK );  // No error message - probably file not found

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1MG@ICKGNNNA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@LoadTechni:

; 912  : 		return false;

	xor	al, al
	jmp	$LN5@LoadTechni
$LN4@LoadTechni:

; 913  : 	}
; 914  : 
; 915  : 	uint32_t SHADER_DEBUG = 1;

	mov	DWORD PTR _SHADER_DEBUG$[ebp], 1

; 916  : 	uint32_t SHADER_RELEASE = 0;

	mov	DWORD PTR _SHADER_RELEASE$[ebp], 0

; 917  : 	LPVOID bufferPointer = pEffectBlob->GetBufferPointer();

	mov	eax, DWORD PTR _pEffectBlob$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pEffectBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bufferPointer$[ebp], eax

; 918  : 	SIZE_T bufferSize = pEffectBlob->GetBufferSize();

	mov	eax, DWORD PTR _pEffectBlob$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pEffectBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bufferSize$[ebp], eax

; 919  : 	hr = D3DX11CreateEffectFromMemory( bufferPointer, bufferSize, 0, mpd3dDevice, &Effect );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 476916				; 000746f4H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+452444]
	push	edx
	push	0
	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bufferPointer$[ebp]
	push	ecx
	call	_D3DX11CreateEffectFromMemory@20
	mov	DWORD PTR _hr$[ebp], eax

; 920  : 
; 921  : 	if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@LoadTechni

; 922  : 	{
; 923  : 		MessageBox( NULL, L"Error creating effects", L"Error", MB_OK );

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1CO@BFKLJCMH@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAe?$AAf?$AAf?$AAe?$AAc?$AAt?$AAs?$AA?$AA@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 924  : 		return false;

	xor	al, al
	jmp	SHORT $LN5@LoadTechni
$LN1@LoadTechni:

; 925  : 	}
; 926  : 
; 927  : 	return true;

	mov	al, 1
$LN5@LoadTechni:

; 928  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@LoadTechni
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 588				; 0000024cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@LoadTechni:
	DD	3
	DD	$LN11@LoadTechni
$LN11@LoadTechni:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN8@LoadTechni
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN9@LoadTechni
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN10@LoadTechni
$LN10@LoadTechni:
	DB	112					; 00000070H
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
$LN9@LoadTechni:
	DB	112					; 00000070H
	DB	69					; 00000045H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$LN8@LoadTechni:
	DB	104					; 00000068H
	DB	114					; 00000072H
	DB	0
?LoadTechnique@CScene@@AAE_NXZ ENDP			; CScene::LoadTechnique
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?LoadShaders@CScene@@AAE_NXZ
_TEXT	SEGMENT
tv257 = -1332						; size = 4
tv255 = -1332						; size = 4
tv253 = -1332						; size = 4
tv251 = -1332						; size = 4
$T1 = -1324						; size = 260
$T2 = -1056						; size = 260
$T3 = -788						; size = 260
$T4 = -520						; size = 260
_hr$ = -60						; size = 4
_dwShaderFlags$ = -48					; size = 4
_pErrors$ = -36						; size = 4
_pEffectBlob$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?LoadShaders@CScene@@AAE_NXZ PROC			; CScene::LoadShaders, COMDAT
; _this$ = ecx

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1332				; 00000534H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1332]
	mov	ecx, 333				; 0000014dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 816  : 	ID3DBlob* pEffectBlob;
; 817  : 	ID3DBlob* pErrors; // This strangely typed variable collects any errors when compiling the effect file
; 818  : 	DWORD dwShaderFlags = D3D10_SHADER_ENABLE_STRICTNESS; // These "flags" are used to set the compiler options

	mov	DWORD PTR _dwShaderFlags$[ebp], 2048	; 00000800H

; 819  : 
; 820  : 	//compile shaders individually
; 821  : 	HRESULT hr; 
; 822  : 	hr = D3DX11CompileFromFile(
; 823  : 		L"VertexShader.hlsl",
; 824  : 		NULL,
; 825  : 		NULL,
; 826  : 		NULL,
; 827  : 		"fx_5_0",
; 828  : 		dwShaderFlags,
; 829  : 		0,
; 830  : 		NULL,
; 831  : 		&pEffectBlob,
; 832  : 		&pErrors,
; 833  : 		&hr
; 834  : 		);

	lea	eax, DWORD PTR _hr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pErrors$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pEffectBlob$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _dwShaderFlags$[ebp]
	push	eax
	push	OFFSET ??_C@_06KIJENJAF@fx_5_0?$AA@
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_1CE@EDOLOMPE@?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AAh?$AAl?$AAs?$AAl?$AA?$AA@
	call	_D3DX11CompileFromFileW@44
	mov	DWORD PTR _hr$[ebp], eax

; 835  : 
; 836  : 	if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN12@LoadShader

; 837  : 	{
; 838  : 		if( pErrors != 0 )  MessageBox( NULL, CA2CT( reinterpret_cast<char*>(pErrors->GetBufferPointer()) ), L"Error", MB_OK ); // Compiler error: display error message

	cmp	DWORD PTR _pErrors$[ebp], 0
	je	SHORT $LN11@LoadShader
	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	mov	eax, DWORD PTR _pErrors$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edi, esp
	mov	edx, DWORD PTR _pErrors$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z	; ATL::CA2WEX<128>::CA2WEX<128>
	mov	DWORD PTR tv251[ebp], eax
	mov	ecx, DWORD PTR tv251[ebp]
	call	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ	; ATL::CA2WEX<128>::operator wchar_t *
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ		; ATL::CA2WEX<128>::~CA2WEX<128>
	jmp	SHORT $LN10@LoadShader
$LN11@LoadShader:

; 839  : 		else               MessageBox( NULL, L"Error loading Vertex Shader FX file. Ensure your FX file is in the same folder as this executable.", L"Error", MB_OK );  // No error message - probably file not found

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1MG@ICKGNNNA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@LoadShader:

; 840  : 		return false;

	xor	al, al
	jmp	$LN13@LoadShader
$LN12@LoadShader:

; 841  : 	}
; 842  : 
; 843  : 	hr = mpd3dDevice->CreateVertexShader( pEffectBlob->GetBufferPointer(), pEffectBlob->GetBufferSize(), NULL, &mp_VertexShader[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+477284]
	mov	esi, esp
	push	eax
	push	0
	mov	ecx, DWORD PTR _pEffectBlob$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edi, esp
	mov	eax, DWORD PTR _pEffectBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+16]
	call	ecx
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	edx, DWORD PTR _pEffectBlob$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edi, esp
	mov	ecx, DWORD PTR _pEffectBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+12]
	call	edx
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452444]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452444]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 844  : 
; 845  : 	if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN9@LoadShader

; 846  : 	{
; 847  : 		if( pErrors != 0 )  MessageBox( NULL, CA2CT( reinterpret_cast<char*>(pErrors->GetBufferPointer()) ), L"Error", MB_OK ); // Compiler error: display error message

	cmp	DWORD PTR _pErrors$[ebp], 0
	je	SHORT $LN8@LoadShader
	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	mov	eax, DWORD PTR _pErrors$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edi, esp
	mov	edx, DWORD PTR _pErrors$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z	; ATL::CA2WEX<128>::CA2WEX<128>
	mov	DWORD PTR tv253[ebp], eax
	mov	ecx, DWORD PTR tv253[ebp]
	call	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ	; ATL::CA2WEX<128>::operator wchar_t *
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ		; ATL::CA2WEX<128>::~CA2WEX<128>
	jmp	SHORT $LN7@LoadShader
$LN8@LoadShader:

; 848  : 		else               MessageBox( NULL, L"Error creating Vertex Shader.", L"Error", MB_OK );  // No error message - probably file not found

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1DM@NILNGIMC@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AA?$AA@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@LoadShader:

; 849  : 		return false;

	xor	al, al
	jmp	$LN13@LoadShader
$LN9@LoadShader:

; 850  : 	}
; 851  : 
; 852  : 	hr = D3DX11CompileFromFile(
; 853  : 		L"PixelShader.hlsl",
; 854  : 		NULL,
; 855  : 		NULL,
; 856  : 		"main",
; 857  : 		"fx_5_0",
; 858  : 		dwShaderFlags,
; 859  : 		0,
; 860  : 		NULL,
; 861  : 		&pEffectBlob,
; 862  : 		&pErrors,
; 863  : 		&hr
; 864  : 		);

	lea	eax, DWORD PTR _hr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pErrors$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pEffectBlob$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _dwShaderFlags$[ebp]
	push	eax
	push	OFFSET ??_C@_06KIJENJAF@fx_5_0?$AA@
	push	OFFSET ??_C@_04GHJNJNPO@main?$AA@
	push	0
	push	0
	push	OFFSET ??_C@_1CC@NFHKBANH@?$AAP?$AAi?$AAx?$AAe?$AAl?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?4?$AAh?$AAl?$AAs?$AAl?$AA?$AA@
	call	_D3DX11CompileFromFileW@44
	mov	DWORD PTR _hr$[ebp], eax

; 865  : 
; 866  : 	if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN6@LoadShader

; 867  : 	{
; 868  : 		if( pErrors != 0 )  MessageBox( NULL, CA2CT( reinterpret_cast<char*>(pErrors->GetBufferPointer()) ), L"Error", MB_OK ); // Compiler error: display error message

	cmp	DWORD PTR _pErrors$[ebp], 0
	je	SHORT $LN5@LoadShader
	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	mov	eax, DWORD PTR _pErrors$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edi, esp
	mov	edx, DWORD PTR _pErrors$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z	; ATL::CA2WEX<128>::CA2WEX<128>
	mov	DWORD PTR tv255[ebp], eax
	mov	ecx, DWORD PTR tv255[ebp]
	call	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ	; ATL::CA2WEX<128>::operator wchar_t *
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ		; ATL::CA2WEX<128>::~CA2WEX<128>
	jmp	SHORT $LN4@LoadShader
$LN5@LoadShader:

; 869  : 		else               MessageBox( NULL, L"Error loading Pixel Shader FX file. Ensure your FX file is in the same folder as this executable.", L"Error", MB_OK );  // No error message - probably file not found

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1ME@MANEMGEF@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAi?$AAx?$AAe?$AAl?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@LoadShader:

; 870  : 		return false;

	xor	al, al
	jmp	$LN13@LoadShader
$LN6@LoadShader:

; 871  : 	}
; 872  : 
; 873  : 	hr = mpd3dDevice->CreatePixelShader( pEffectBlob->GetBufferPointer(), pEffectBlob->GetBufferSize(), NULL, &mp_PixelShader[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+477164]
	mov	esi, esp
	push	eax
	push	0
	mov	ecx, DWORD PTR _pEffectBlob$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edi, esp
	mov	eax, DWORD PTR _pEffectBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+16]
	call	ecx
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	edx, DWORD PTR _pEffectBlob$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edi, esp
	mov	ecx, DWORD PTR _pEffectBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+12]
	call	edx
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452444]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452444]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+60]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 874  : 
; 875  : 
; 876  : 	if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN3@LoadShader

; 877  : 	{
; 878  : 		if( pErrors != 0 )  MessageBox( NULL, CA2CT( reinterpret_cast<char*>(pErrors->GetBufferPointer()) ), L"Error", MB_OK ); // Compiler error: display error message

	cmp	DWORD PTR _pErrors$[ebp], 0
	je	SHORT $LN2@LoadShader
	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	mov	eax, DWORD PTR _pErrors$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edi, esp
	mov	edx, DWORD PTR _pErrors$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z	; ATL::CA2WEX<128>::CA2WEX<128>
	mov	DWORD PTR tv257[ebp], eax
	mov	ecx, DWORD PTR tv257[ebp]
	call	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ	; ATL::CA2WEX<128>::operator wchar_t *
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ		; ATL::CA2WEX<128>::~CA2WEX<128>
	jmp	SHORT $LN1@LoadShader
$LN2@LoadShader:

; 879  : 		else               MessageBox( NULL, L"Error Creating Pixel Shader", L"Error", MB_OK );  // No error message - probably file not found

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1DI@GKGJLLII@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAi?$AAx?$AAe?$AAl?$AA?5?$AAS?$AAh?$AAa?$AAd?$AAe?$AAr?$AA?$AA@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@LoadShader:

; 880  : 		return false;

	xor	al, al
	jmp	SHORT $LN13@LoadShader
$LN3@LoadShader:

; 881  : 	}
; 882  : 	return true;

	mov	al, 1
$LN13@LoadShader:

; 883  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@LoadShader
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1332				; 00000534H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN23@LoadShader:
	DD	3
	DD	$LN22@LoadShader
$LN22@LoadShader:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN19@LoadShader
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN20@LoadShader
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN21@LoadShader
$LN21@LoadShader:
	DB	104					; 00000068H
	DB	114					; 00000072H
	DB	0
$LN20@LoadShader:
	DB	112					; 00000070H
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
$LN19@LoadShader:
	DB	112					; 00000070H
	DB	69					; 00000045H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
?LoadShaders@CScene@@AAE_NXZ ENDP			; CScene::LoadShaders
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?DisplayText@CScene@@AAEXQADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_text$ = 8						; size = 4
_line$ = 12						; size = 4
?DisplayText@CScene@@AAEXQADI@Z PROC			; CScene::DisplayText, COMDAT
; _this$ = ecx

; 1044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 
; 1046 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?DisplayText@CScene@@AAEXQADI@Z ENDP			; CScene::DisplayText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?DisplayMapText@CScene@@AAEXH@Z
_TEXT	SEGMENT
$T1 = -352						; size = 8
$T2 = -336						; size = 8
$T3 = -320						; size = 16
_buffer$4 = -104					; size = 12
_i$5 = -84						; size = 4
_pixel$ = -72						; size = 8
_world$ = -56						; size = 12
_matrixTemp$ = -36					; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_offset$ = 8						; size = 4
?DisplayMapText@CScene@@AAEXH@Z PROC			; CScene::DisplayMapText, COMDAT
; _this$ = ecx

; 1049 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-360]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1050 : 
; 1051 : 	DirectX::XMFLOAT4 matrixTemp;

	lea	ecx, DWORD PTR _matrixTemp$[ebp]
	call	??0XMFLOAT4@DirectX@@QAE@XZ		; DirectX::XMFLOAT4::XMFLOAT4

; 1052 : 	DirectX::XMFLOAT3 world;

	lea	ecx, DWORD PTR _world$[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@XZ		; DirectX::XMFLOAT3::XMFLOAT3

; 1053 : 	DirectX::XMFLOAT2 pixel;

	lea	ecx, DWORD PTR _pixel$[ebp]
	call	??0XMFLOAT2@DirectX@@QAE@XZ		; DirectX::XMFLOAT2::XMFLOAT2

; 1054 : 	for(int i = 0; i < mi_numSquares; i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN3@DisplayMap
$LN2@DisplayMap:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN3@DisplayMap:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$5[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jae	$LN1@DisplayMap

; 1055 : 	{	
; 1056 : 		//DirectX::XMFLOAT3 world = DirectX::XMFLOAT3(md_mapMatrix[i]._41, md_mapMatrix[i]._42, md_mapMatrix[i]._43);
; 1057 : 		
; 1058 : 		
; 1059 : 		//DirectX::XMStoreFloat4x4( &matrixTemp, md_mapMatrix[i] );
; 1060 : 		DirectX::XMStoreFloat4(&matrixTemp, mp_matrixArray[i]->r[3] );

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+176]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	movups	xmm0, XMMWORD PTR [edx+ecx]
	lea	ecx, DWORD PTR _matrixTemp$[ebp]
	call	?XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@1@T__m128@@@Z ; DirectX::XMStoreFloat4

; 1061 : 		world.x = matrixTemp.x;

	movss	xmm0, DWORD PTR _matrixTemp$[ebp]
	movss	DWORD PTR _world$[ebp], xmm0

; 1062 : 		world.y = matrixTemp.y;

	movss	xmm0, DWORD PTR _matrixTemp$[ebp+4]
	movss	DWORD PTR _world$[ebp+4], xmm0

; 1063 : 		world.z = matrixTemp.z;

	movss	xmm0, DWORD PTR _matrixTemp$[ebp+8]
	movss	DWORD PTR _world$[ebp+8], xmm0

; 1064 : 
; 1065 : 		Camera.PixelFromWorldPt(&pixel, world);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _world$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _world$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _world$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	lea	edx, DWORD PTR _pixel$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452464				; 0006e770H
	call	?PixelFromWorldPt@CCamera@@QAE_NPAUXMFLOAT2@DirectX@@UXMFLOAT3@3@@Z ; CCamera::PixelFromWorldPt

; 1066 : 		wchar_t buffer[6];
; 1067 : 		//_itoa_s( mc_map->GetValueByOffset(i%mi_mapWidth,i/mi_mapWidth, offset), temp, 10 );
; 1068 : 		swprintf( buffer, 6, L"%d", mc_map->GetValueByOffset( i%mi_mapWidth, i / mi_mapWidth, offset ) );

	mov	eax, DWORD PTR _offset$[ebx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$5[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+452452]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$5[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+452452]
	push	edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?GetValueByOffset@MapSquare@@QAEIIIH@Z	; MapSquare::GetValueByOffset
	push	eax
	push	OFFSET ??_C@_15KNBIKKIN@?$AA?$CF?$AAd?$AA?$AA@
	push	6
	lea	eax, DWORD PTR _buffer$4[ebp]
	push	eax
	call	_swprintf
	add	esp, 16					; 00000010H

; 1069 : 		mpSpriteFont->DrawString(
; 1070 : 			mpSpriteBatch,						//Font
; 1071 : 			buffer,								//Text
; 1072 : 			pixel,								//Position
; 1073 : 			DirectX::Colors::Red,				//Colour
; 1074 : 			0.0f,								//Rotation
; 1075 : 			DirectX::XMFLOAT2( 0.0f, 0.0f ),	//origin
; 1076 : 			DirectX::XMFLOAT2( 0.5f, 0.5f )		//scale
; 1077 : 			);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0XMFLOAT2@DirectX@@QAE@MM@Z		; DirectX::XMFLOAT2::XMFLOAT2
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0XMFLOAT2@DirectX@@QAE@MM@Z		; DirectX::XMFLOAT2::XMFLOAT2
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, OFFSET ?Red@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::Red
	call	??BXMVECTORF32@DirectX@@QBE?AT__m128@@XZ ; DirectX::XMVECTORF32::operator __m128
	movups	xmm0, XMMWORD PTR [eax]
	lea	ecx, DWORD PTR _pixel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$4[ebp]
	push	edx
	movss	xmm2, DWORD PTR __real@00000000
	movss	xmm1, DWORD PTR __real@00000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	call	?DrawString@SpriteFont@DirectX@@QAQXPAVSpriteBatch@2@PB_WABUXMFLOAT2@2@T__m128@@M22W4SpriteEffects@2@M@Z ; DirectX::SpriteFont::DrawString

; 1078 : 	}

	jmp	$LN2@DisplayMap
$LN1@DisplayMap:

; 1079 : 	
; 1080 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@DisplayMap
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
	npad	2
$LN11@DisplayMap:
	DD	4
	DD	$LN10@DisplayMap
$LN10@DisplayMap:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN6@DisplayMap
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN7@DisplayMap
	DD	-72					; ffffffb8H
	DD	8
	DD	$LN8@DisplayMap
	DD	-104					; ffffff98H
	DD	12					; 0000000cH
	DD	$LN9@DisplayMap
$LN9@DisplayMap:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN8@DisplayMap:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	0
$LN7@DisplayMap:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	0
$LN6@DisplayMap:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
?DisplayMapText@CScene@@AAEXH@Z ENDP			; CScene::DisplayMapText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?DrawAllObjects@CScene@@AAEX_N@Z
_TEXT	SEGMENT
$T1 = -400						; size = 64
$T2 = -328						; size = 12
$T3 = -308						; size = 12
$T4 = -288						; size = 12
_i$5 = -68						; size = 4
_temp$6 = -56						; size = 12
_i$7 = -36						; size = 4
_i$8 = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_mirror$ = 8						; size = 1
?DrawAllObjects@CScene@@AAEX_N@Z PROC			; CScene::DrawAllObjects, COMDAT
; _this$ = ecx

; 416  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 408				; 00000198H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-408]
	mov	ecx, 102				; 00000066H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 417  : 	//
; 418  : 	// Solid objects
; 419  : 	//
; 420  : 	for(int i = 0; i < miNumObjects; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN13@DrawAllObj
$LN12@DrawAllObj:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN13@DrawAllObj:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$8[ebp]
	cmp	ecx, DWORD PTR [eax+460768]
	jge	SHORT $LN11@DrawAllObj

; 421  : 	{
; 422  : 		if( !mpObjects[i]->IsTransparent() )

	mov	eax, DWORD PTR _i$8[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?IsTransparent@CRenderObject@@QAE_NXZ	; CRenderObject::IsTransparent
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@DrawAllObj

; 423  : 		{
; 424  : 			DrawObject(i, mirror);

	movzx	eax, BYTE PTR _mirror$[ebx]
	push	eax
	mov	ecx, DWORD PTR _i$8[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawObject@CScene@@AAEXH_N@Z		; CScene::DrawObject
$LN10@DrawAllObj:

; 425  : 		}
; 426  : 	}

	jmp	SHORT $LN12@DrawAllObj
$LN11@DrawAllObj:

; 427  : 
; 428  : 	//
; 429  : 	// Light objects
; 430  : 	//
; 431  : 
; 432  : 
; 433  : 	for(int i = 0; i < miNumLights; i++)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN9@DrawAllObj
$LN8@DrawAllObj:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN9@DrawAllObj:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$7[ebp]
	cmp	ecx, DWORD PTR [eax+460892]
	jge	$LN7@DrawAllObj

; 434  : 	{
; 435  : 		WorldMatrixVar->SetMatrix( (float*)mpLights[i]->GetModel()->GetWorldMatrix().r );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$7[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+460772]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?GetWorldMatrix@CModel@@QAE?AUXMMATRIX@DirectX@@XZ ; CModel::GetWorldMatrix
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477404]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+112]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 436  : 		V3 temp = XMF3ToFloat3(mpLights[i]->GetColourV() );

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$7[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+460772]
	call	?GetColourV@CLight@@QAE?AUXMFLOAT3@DirectX@@XZ ; CLight::GetColourV
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	?XMF3ToFloat3@@YA?AUV3@@UXMFLOAT3@DirectX@@@Z ; XMF3ToFloat3
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp+8], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _temp$6[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR _temp$6[ebp+4], ecx
	mov	edx, DWORD PTR $T2[ebp+8]
	mov	DWORD PTR _temp$6[ebp+8], edx

; 437  : 		ModelColourVar->SetRawValue(&temp, 0, 12 );

	mov	esi, esp
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR _temp$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477428]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+104]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 438  : 		if( mirror )

	movzx	eax, BYTE PTR _mirror$[ebx]
	test	eax, eax
	je	SHORT $LN6@DrawAllObj

; 439  : 		{
; 440  : 			mpLights[i]->GetModel()->Render( mTechniquesMirror[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+477040]
	push	eax
	mov	ecx, DWORD PTR _i$7[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+460772]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?Render@CModel@@QAEXPAUID3DX11EffectTechnique@@@Z ; CModel::Render

; 441  : 		}
; 442  : 		else

	jmp	SHORT $LN5@DrawAllObj
$LN6@DrawAllObj:

; 443  : 		{
; 444  : 			mpLights[i]->GetModel()->Render( mTechniques[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+476920]
	push	eax
	mov	ecx, DWORD PTR _i$7[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+460772]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?Render@CModel@@QAEXPAUID3DX11EffectTechnique@@@Z ; CModel::Render
$LN5@DrawAllObj:

; 445  : 		}
; 446  : 	}

	jmp	$LN8@DrawAllObj
$LN7@DrawAllObj:

; 447  : 
; 448  : 	//
; 449  : 	// Transparent objects
; 450  : 	//
; 451  : 
; 452  : 	for(int i = 1; i < miNumObjects; i++)

	mov	DWORD PTR _i$5[ebp], 1
	jmp	SHORT $LN4@DrawAllObj
$LN3@DrawAllObj:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN4@DrawAllObj:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$5[ebp]
	cmp	ecx, DWORD PTR [eax+460768]
	jge	SHORT $LN14@DrawAllObj

; 453  : 	{
; 454  : 		if( mpObjects[i]->IsTransparent() )

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?IsTransparent@CRenderObject@@QAE_NXZ	; CRenderObject::IsTransparent
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@DrawAllObj

; 455  : 		{
; 456  : 			DrawObject(i, mirror);

	movzx	eax, BYTE PTR _mirror$[ebx]
	push	eax
	mov	ecx, DWORD PTR _i$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawObject@CScene@@AAEXH_N@Z		; CScene::DrawObject
$LN1@DrawAllObj:

; 457  : 		}
; 458  : 	}

	jmp	SHORT $LN3@DrawAllObj
$LN14@DrawAllObj:

; 459  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@DrawAllObj
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
	npad	3
$LN18@DrawAllObj:
	DD	1
	DD	$LN17@DrawAllObj
$LN17@DrawAllObj:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN16@DrawAllObj
$LN16@DrawAllObj:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
?DrawAllObjects@CScene@@AAEX_N@Z ENDP			; CScene::DrawAllObjects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?DrawObject@CScene@@AAEXH_N@Z
_TEXT	SEGMENT
$T1 = -324						; size = 12
$T2 = -304						; size = 64
_f3$ = -32						; size = 12
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_i$ = 8							; size = 4
_mirror$ = 12						; size = 1
?DrawObject@CScene@@AAEXH_N@Z PROC			; CScene::DrawObject, COMDAT
; _this$ = ecx

; 380  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 
; 382  : 	//outline thickness
; 383  : 	//float thickness = mpObjects[i]->GetOutlineThickness();
; 384  : 	//dxOutlineThickness->SetRawValue( &thickness, 0, 4);
; 385  : 
; 386  : 	//pass the matrix
; 387  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[i]->GetModel()->GetWorldMatrix().r );

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+452768]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?GetWorldMatrix@CModel@@QAE?AUXMMATRIX@DirectX@@XZ ; CModel::GetWorldMatrix
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477404]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477404]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+112]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 388  : 	
; 389  : 	//pass the textures and maps, if there are any. 
; 390  : 	if( mpObjects[i]->GetTexture() != nullptr )

	mov	eax, DWORD PTR _i$[ebx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?GetTexture@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ ; CRenderObject::GetTexture
	test	eax, eax
	je	SHORT $LN3@DrawObject

; 391  : 	{
; 392  : 		DiffuseMapVar->SetResource( mpObjects[i]->GetTexture() );

	mov	eax, DWORD PTR _i$[ebx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?GetTexture@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ ; CRenderObject::GetTexture
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477420]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477420]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+112]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@DrawObject:

; 393  : 	}
; 394  : 	if( mpObjects[i]->GetNormalMap() != nullptr )

	mov	eax, DWORD PTR _i$[ebx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?GetNormalMap@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ ; CRenderObject::GetNormalMap
	test	eax, eax
	je	SHORT $LN2@DrawObject

; 395  : 	{
; 396  : 		NormalMapVar->SetResource( mpObjects[i]->GetNormalMap() );

	mov	eax, DWORD PTR _i$[ebx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?GetNormalMap@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ ; CRenderObject::GetNormalMap
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477424]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477424]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+112]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@DrawObject:

; 397  : 	}
; 398  : 
; 399  : 	//pass the model colour - used for untextured models, texture colour change and outline colour in cell shading
; 400  : 	DirectX::XMFLOAT3 f3 = mpObjects[i]->GetColourV();

	lea	eax, DWORD PTR _f3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+452768]
	call	?GetColourV@CRenderObject@@QAE?AUXMFLOAT3@DirectX@@XZ ; CRenderObject::GetColourV

; 401  : 	//V3 temp = XMF3ToFloat3( f3 );
; 402  : 	ModelColourVar->SetRawValue( (float*)&f3, 0, 12 );

	mov	esi, esp
	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR _f3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477428]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+477428]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+104]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 403  : 	
; 404  : 	//if the object is lit, pass over the 12 closest lights. 
; 405  : 	if( mpObjects[i]->IsLit() )

	mov	eax, DWORD PTR _i$[ebx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?IsLit@CRenderObject@@QAE_NXZ		; CRenderObject::IsLit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@DrawObject

; 406  : 	{
; 407  : 		SetLights( mpObjects[i]->GetModel()->GetPosition(), mpLights, miNumLights);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+460892]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 460772				; 000707e4H
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+452768]
	call	?GetModel@CRenderObject@@QAEPAVCModel@@XZ ; CRenderObject::GetModel
	mov	ecx, eax
	call	?GetPosition@CModel@@QAE?AUXMFLOAT3@DirectX@@XZ ; CModel::GetPosition
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLights@CScene@@AAEXUXMFLOAT3@DirectX@@QAPAVCLight@@H@Z ; CScene::SetLights
$LN1@DrawObject:

; 408  : 	}
; 409  : 
; 410  : 	// choose how to render the model based on where we are rendering it. 
; 411  : 	mpObjects[i]->Render();

	mov	eax, DWORD PTR _i$[ebx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+452768]
	call	?Render@CRenderObject@@QAEXXZ		; CRenderObject::Render

; 412  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@DrawObject
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	8
	npad	2
$LN8@DrawObject:
	DD	1
	DD	$LN7@DrawObject
$LN7@DrawObject:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN6@DrawObject
$LN6@DrawObject:
	DB	102					; 00000066H
	DB	51					; 00000033H
	DB	0
?DrawObject@CScene@@AAEXH_N@Z ENDP			; CScene::DrawObject
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv70 = -308						; size = 4
_rc$1 = -108						; size = 16
_hdc$ = -84						; size = 4
_ps$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z PROC		; CScene::WndProc, COMDAT

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 599  : 	PAINTSTRUCT ps;
; 600  : 	HDC hdc;
; 601  : 	if( TwEventWin( hWnd, message, wParam, lParam ) ) // send event message to AntTweakBar

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__TwEventWin@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN9@WndProc

; 602  : 		return 0; // event has been handled by AntTweakBar

	xor	eax, eax
	jmp	$LN10@WndProc
$LN9@WndProc:

; 603  : 	switch( message )

	mov	eax, DWORD PTR _message$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 15			; 0000000fH
	ja	SHORT $LN12@WndProc
	cmp	DWORD PTR tv70[ebp], 15			; 0000000fH
	je	SHORT $LN6@WndProc
	cmp	DWORD PTR tv70[ebp], 2
	je	SHORT $LN5@WndProc
	cmp	DWORD PTR tv70[ebp], 5
	je	$LN2@WndProc
	jmp	$LN1@WndProc
$LN12@WndProc:
	cmp	DWORD PTR tv70[ebp], 256		; 00000100H
	je	SHORT $LN4@WndProc
	cmp	DWORD PTR tv70[ebp], 257		; 00000101H
	je	SHORT $LN3@WndProc
	jmp	$LN1@WndProc
$LN6@WndProc:

; 604  : 	{
; 605  : 		case WM_PAINT:
; 606  : 			hdc = BeginPaint( hWnd, &ps );

	mov	esi, esp
	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__BeginPaint@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hdc$[ebp], eax

; 607  : 			EndPaint( hWnd, &ps );

	mov	esi, esp
	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndPaint@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 608  : 			break;

	jmp	$LN7@WndProc
$LN5@WndProc:

; 609  : 
; 610  : 		case WM_DESTROY:
; 611  : 			PostQuitMessage( 0 );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__PostQuitMessage@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 612  : 			break;

	jmp	$LN7@WndProc
$LN4@WndProc:

; 613  : 
; 614  : 		// These windows messages (WM_KEYXXXX) can be used to get keyboard input to the window
; 615  : 		// This application has added some simple functions (not DirectX) to process these messages (all in Input.cpp/h)
; 616  : 		case WM_KEYDOWN:
; 617  : 			KeyDownEvent( static_cast<EKeyState>(wParam) );

	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	?KeyDownEvent@@YAXW4EKeyState@@@Z	; KeyDownEvent
	add	esp, 4

; 618  : 			break;

	jmp	SHORT $LN7@WndProc
$LN3@WndProc:

; 619  : 
; 620  : 		case WM_KEYUP:
; 621  : 			KeyUpEvent( static_cast<EKeyState>(wParam) );

	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	?KeyUpEvent@@YAXW4EKeyState@@@Z		; KeyUpEvent
	add	esp, 4

; 622  : 			break;

	jmp	SHORT $LN7@WndProc
$LN2@WndProc:

; 623  : 		// catch window resize
; 624  : 		case WM_SIZE:
; 625  : 			RECT rc;
; 626  : 			GetClientRect( hWnd, &rc );

	mov	esi, esp
	lea	eax, DWORD PTR _rc$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 627  : 			mViewportWidth = rc.right - rc.left;

	mov	eax, DWORD PTR _rc$1[ebp+8]
	sub	eax, DWORD PTR _rc$1[ebp]
	mov	DWORD PTR ?mViewportWidth@CScene@@0HA, eax ; CScene::mViewportWidth

; 628  : 			mViewportHeight = rc.bottom - rc.top;

	mov	eax, DWORD PTR _rc$1[ebp+12]
	sub	eax, DWORD PTR _rc$1[ebp+4]
	mov	DWORD PTR ?mViewportHeight@CScene@@0HA, eax ; CScene::mViewportHeight

; 629  : 			// pass to camera
; 630  : 			CCamera::SetViewport( mViewportWidth, mViewportHeight );

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	push	eax
	mov	ecx, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	push	ecx
	call	?SetViewport@CCamera@@SAXHH@Z		; CCamera::SetViewport
	add	esp, 8

; 631  : 			break;

	jmp	SHORT $LN7@WndProc
$LN1@WndProc:

; 632  : 		default:
; 633  : 			return DefWindowProc( hWnd, message, wParam, lParam );

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcW@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN10@WndProc
$LN7@WndProc:

; 634  : 	}
; 635  : 
; 636  : 	return 0;

	xor	eax, eax
$LN10@WndProc:

; 637  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@WndProc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN16@WndProc:
	DD	2
	DD	$LN15@WndProc
$LN15@WndProc:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN13@WndProc
	DD	-108					; ffffff94H
	DD	16					; 00000010H
	DD	$LN14@WndProc
$LN14@WndProc:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
$LN13@WndProc:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	0
?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z ENDP		; CScene::WndProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?compareLights@CScene@@CAHPBX0@Z
_TEXT	SEGMENT
_y$ = -20						; size = 4
_x$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?compareLights@CScene@@CAHPBX0@Z PROC			; CScene::compareLights, COMDAT

; 986  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 987  : 	LightIndex* x = (LightIndex*)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 988  : 	LightIndex* y = (LightIndex*)b;

	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 989  : 	return int(x->distance - y->distance);

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	cvttss2si eax, xmm0

; 990  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?compareLights@CScene@@CAHPBX0@Z ENDP			; CScene::compareLights
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\scene.cpp
;	COMDAT ?SetLights@CScene@@AAEXUXMFLOAT3@DirectX@@QAPAVCLight@@H@Z
_TEXT	SEGMENT
tv316 = -1388						; size = 4
tv449 = -1384						; size = 4
tv310 = -1380						; size = 4
tv447 = -1376						; size = 4
tv304 = -1372						; size = 4
$T1 = -1364						; size = 12
$T2 = -1344						; size = 12
$T3 = -1324						; size = 12
$T4 = -1304						; size = 16
$T5 = -1280						; size = 12
$T6 = -1260						; size = 12
$T7 = -1240						; size = 16
$T8 = -1216						; size = 16
$T9 = -1192						; size = 12
$T10 = -1172						; size = 12
_temp$11 = -960						; size = 12
_c$12 = -940						; size = 4
_i$13 = -928						; size = 4
_bright$ = -916						; size = 192
_colours$ = -716					; size = 192
_positions$ = -516					; size = 192
_count$ = -316						; size = 4
_i$14 = -304						; size = 4
_vLight$ = -292						; size = 12
_i$15 = -272						; size = 4
_indexes$ = -260					; size = 240
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 12
_lightsSource$ = 20					; size = 4
_lightCount$ = 24					; size = 4
?SetLights@CScene@@AAEXUXMFLOAT3@DirectX@@QAPAVCLight@@H@Z PROC ; CScene::SetLights, COMDAT
; _this$ = ecx

; 994  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1388				; 0000056cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1388]
	mov	ecx, 347				; 0000015bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 	LightIndex indexes[MAX_LIGHTS];
; 996  : 
; 997  : 	for(int i = 0; i < MAX_LIGHTS; i++)

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN11@SetLights
$LN10@SetLights:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN11@SetLights:
	cmp	DWORD PTR _i$15[ebp], 30		; 0000001eH
	jge	SHORT $LN9@SetLights

; 998  : 	{
; 999  : 		indexes[i].distance = 777777777.0f;

	mov	eax, DWORD PTR _i$15[ebp]
	movss	xmm0, DWORD PTR __real@4e396fca
	movss	DWORD PTR _indexes$[ebp+eax*8+4], xmm0

; 1000 : 	}

	jmp	SHORT $LN10@SetLights
$LN9@SetLights:

; 1001 : 
; 1002 : 	DirectX::XMFLOAT3 vLight;

	lea	ecx, DWORD PTR _vLight$[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@XZ		; DirectX::XMFLOAT3::XMFLOAT3

; 1003 : 	for(int i = 0; i < lightCount; i++)

	mov	DWORD PTR _i$14[ebp], 0
	jmp	SHORT $LN8@SetLights
$LN7@SetLights:
	mov	eax, DWORD PTR _i$14[ebp]
	add	eax, 1
	mov	DWORD PTR _i$14[ebp], eax
$LN8@SetLights:
	mov	eax, DWORD PTR _i$14[ebp]
	cmp	eax, DWORD PTR _lightCount$[ebp]
	jge	$LN6@SetLights

; 1004 : 	{
; 1005 : 		indexes[i].index = i;

	mov	eax, DWORD PTR _i$14[ebp]
	mov	ecx, DWORD PTR _i$14[ebp]
	mov	DWORD PTR _indexes$[ebp+eax*8], ecx

; 1006 : 		vLight = lightsSource[i]->GetModel()->GetPosition();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$14[ebp]
	mov	edx, DWORD PTR _lightsSource$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?GetPosition@CModel@@QAE?AUXMFLOAT3@DirectX@@XZ ; CModel::GetPosition
	push	eax
	lea	ecx, DWORD PTR _vLight$[ebp]
	call	??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT3::operator=

; 1007 : 		indexes[i].distance = square(vLight.x - source.x) + square (vLight.y - source.y) + square(vLight.z - source.z);

	movss	xmm0, DWORD PTR _vLight$[ebp]
	subss	xmm0, DWORD PTR _source$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?square@@YAMM@Z				; square
	add	esp, 4
	fstp	DWORD PTR tv304[ebp]
	movss	xmm0, DWORD PTR tv304[ebp]
	movss	xmm1, DWORD PTR _vLight$[ebp+4]
	subss	xmm1, DWORD PTR _source$[ebp+4]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv447[ebp], xmm0
	call	?square@@YAMM@Z				; square
	add	esp, 4
	fstp	DWORD PTR tv310[ebp]
	movss	xmm0, DWORD PTR tv447[ebp]
	addss	xmm0, DWORD PTR tv310[ebp]
	movss	xmm1, DWORD PTR _vLight$[ebp+8]
	subss	xmm1, DWORD PTR _source$[ebp+8]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv449[ebp], xmm0
	call	?square@@YAMM@Z				; square
	add	esp, 4
	fstp	DWORD PTR tv316[ebp]
	movss	xmm0, DWORD PTR tv449[ebp]
	addss	xmm0, DWORD PTR tv316[ebp]
	mov	eax, DWORD PTR _i$14[ebp]
	movss	DWORD PTR _indexes$[ebp+eax*8+4], xmm0

; 1008 : 	}

	jmp	$LN7@SetLights
$LN6@SetLights:

; 1009 : 
; 1010 : 	qsort( (void*) indexes, MAX_LIGHTS, sizeof(LightIndex), &CScene::compareLights);

	push	OFFSET ?compareLights@CScene@@CAHPBX0@Z	; CScene::compareLights
	push	8
	push	30					; 0000001eH
	lea	eax, DWORD PTR _indexes$[ebp]
	push	eax
	call	_qsort
	add	esp, 16					; 00000010H

; 1011 : 
; 1012 : 	int count;
; 1013 : 	
; 1014 : 	if( lightCount < MAX_SHADER_LIGHTS )

	cmp	DWORD PTR _lightCount$[ebp], 12		; 0000000cH
	jge	SHORT $LN5@SetLights

; 1015 : 	{
; 1016 : 		count = lightCount;

	mov	eax, DWORD PTR _lightCount$[ebp]
	mov	DWORD PTR _count$[ebp], eax

; 1017 : 	}
; 1018 : 	else

	jmp	SHORT $LN4@SetLights
$LN5@SetLights:

; 1019 : 	{
; 1020 : 		count = MAX_SHADER_LIGHTS;

	mov	DWORD PTR _count$[ebp], 12		; 0000000cH
$LN4@SetLights:

; 1021 : 	}
; 1022 : 
; 1023 : 	DirectX::XMFLOAT4 positions[MAX_SHADER_LIGHTS];

	push	OFFSET ??0XMFLOAT4@DirectX@@QAE@XZ	; DirectX::XMFLOAT4::XMFLOAT4
	push	12					; 0000000cH
	push	16					; 00000010H
	lea	eax, DWORD PTR _positions$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 1024 : 	DirectX::XMFLOAT4 colours[MAX_SHADER_LIGHTS];

	push	OFFSET ??0XMFLOAT4@DirectX@@QAE@XZ	; DirectX::XMFLOAT4::XMFLOAT4
	push	12					; 0000000cH
	push	16					; 00000010H
	lea	eax, DWORD PTR _colours$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 1025 : 	DirectX::XMFLOAT4 bright[MAX_SHADER_LIGHTS];

	push	OFFSET ??0XMFLOAT4@DirectX@@QAE@XZ	; DirectX::XMFLOAT4::XMFLOAT4
	push	12					; 0000000cH
	push	16					; 00000010H
	lea	eax, DWORD PTR _bright$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 1026 : 	
; 1027 : 	for(int i = 0; i < count; i++)

	mov	DWORD PTR _i$13[ebp], 0
	jmp	SHORT $LN3@SetLights
$LN2@SetLights:
	mov	eax, DWORD PTR _i$13[ebp]
	add	eax, 1
	mov	DWORD PTR _i$13[ebp], eax
$LN3@SetLights:
	mov	eax, DWORD PTR _i$13[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN1@SetLights

; 1028 : 	{
; 1029 : 		int c = indexes[i].index;

	mov	eax, DWORD PTR _i$13[ebp]
	mov	ecx, DWORD PTR _indexes$[ebp+eax*8]
	mov	DWORD PTR _c$12[ebp], ecx

; 1030 : 		V3 temp = XMF3ToFloat3( mpLights[c]->GetModel()->GetPosition() );

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$12[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+460772]
	call	?GetModel@CLight@@QAEPAVCModel@@XZ	; CLight::GetModel
	mov	ecx, eax
	call	?GetPosition@CModel@@QAE?AUXMFLOAT3@DirectX@@XZ ; CModel::GetPosition
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?XMF3ToFloat3@@YA?AUV3@@UXMFLOAT3@DirectX@@@Z ; XMF3ToFloat3
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T9[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T9[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T9[ebp+8], edx
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR _temp$11[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR _temp$11[ebp+4], ecx
	mov	edx, DWORD PTR $T9[ebp+8]
	mov	DWORD PTR _temp$11[ebp+8], edx

; 1031 : 		positions[i] = DirectX::XMFLOAT4 (temp.x, temp.y, temp.z, 0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _temp$11[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _temp$11[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _temp$11[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0XMFLOAT4@DirectX@@QAE@MMMM@Z		; DirectX::XMFLOAT4::XMFLOAT4
	push	eax
	mov	eax, DWORD PTR _i$13[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _positions$[ebp+eax]
	call	??4XMFLOAT4@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT4::operator=

; 1032 : 
; 1033 : 		temp = XMF3ToFloat3( mpLights[c]->GetColourV() );

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$12[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+460772]
	call	?GetColourV@CLight@@QAE?AUXMFLOAT3@DirectX@@XZ ; CLight::GetColourV
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	?XMF3ToFloat3@@YA?AUV3@@UXMFLOAT3@DirectX@@@Z ; XMF3ToFloat3
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T10[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T10[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T10[ebp+8], edx
	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR _temp$11[ebp], eax
	mov	ecx, DWORD PTR $T10[ebp+4]
	mov	DWORD PTR _temp$11[ebp+4], ecx
	mov	edx, DWORD PTR $T10[ebp+8]
	mov	DWORD PTR _temp$11[ebp+8], edx

; 1034 : 		colours[i] = DirectX::XMFLOAT4 (temp.x, temp.y, temp.z, 0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _temp$11[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _temp$11[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _temp$11[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0XMFLOAT4@DirectX@@QAE@MMMM@Z		; DirectX::XMFLOAT4::XMFLOAT4
	push	eax
	mov	eax, DWORD PTR _i$13[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _colours$[ebp+eax]
	call	??4XMFLOAT4@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT4::operator=

; 1035 : 		bright[i] = DirectX::XMFLOAT4( mpLights[c]->GetBrightness(), 0, 0, 0 );   // vector 4 for packing, remaining variables would be useful for light type and angle. 

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _c$12[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+460772]
	call	?GetBrightness@CLight@@QAEMXZ		; CLight::GetBrightness
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0XMFLOAT4@DirectX@@QAE@MMMM@Z		; DirectX::XMFLOAT4::XMFLOAT4
	push	eax
	mov	edx, DWORD PTR _i$13[ebp]
	shl	edx, 4
	lea	ecx, DWORD PTR _bright$[ebp+edx]
	call	??4XMFLOAT4@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT4::operator=

; 1036 : 	}

	jmp	$LN2@SetLights
$LN1@SetLights:

; 1037 : 
; 1038 : 	dxLightPosA->SetRawValue( positions, 0, 16 * count );

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 4
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR _positions$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477432]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477432]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+104]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1039 : 	dxLightColourA->SetRawValue( colours, 0, 16 * count );

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 4
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR _colours$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477440]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477440]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+104]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1040 : 	dxLightBrightnessA->SetRawValue( bright, 0, 16 * count );

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 4
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR _bright$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+477448]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+477448]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+104]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1041 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@SetLights
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1388				; 0000056cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN21@SetLights:
	DD	6
	DD	$LN20@SetLights
$LN20@SetLights:
	DD	-260					; fffffefcH
	DD	240					; 000000f0H
	DD	$LN14@SetLights
	DD	-292					; fffffedcH
	DD	12					; 0000000cH
	DD	$LN15@SetLights
	DD	-516					; fffffdfcH
	DD	192					; 000000c0H
	DD	$LN16@SetLights
	DD	-716					; fffffd34H
	DD	192					; 000000c0H
	DD	$LN17@SetLights
	DD	-916					; fffffc6cH
	DD	192					; 000000c0H
	DD	$LN18@SetLights
	DD	-960					; fffffc40H
	DD	12					; 0000000cH
	DD	$LN19@SetLights
$LN19@SetLights:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN18@SetLights:
	DB	98					; 00000062H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	0
$LN17@SetLights:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
$LN16@SetLights:
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
$LN15@SetLights:
	DB	118					; 00000076H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	0
$LN14@SetLights:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
?SetLights@CScene@@AAEXUXMFLOAT3@DirectX@@QAPAVCLight@@H@Z ENDP ; CScene::SetLights
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\modelbatch.h
;	COMDAT ?Reset@ModelBatch@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Reset@ModelBatch@@QAEXXZ PROC				; ModelBatch::Reset, COMDAT
; _this$ = ecx

; 28   : 	void Reset(){ mi_count = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64016], 0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@ModelBatch@@QAEXXZ ENDP				; ModelBatch::Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\modelbatch.h
;	COMDAT ?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_colour$ = 8						; size = 12
?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z PROC	; ModelBatch::SetColour, COMDAT
; _this$ = ecx

; 18   : 	void SetColour(DirectX::XMFLOAT3 colour){ md_colour = colour;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR _colour$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT3::operator=
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetColour@ModelBatch@@QAEXUXMFLOAT3@DirectX@@@Z ENDP	; ModelBatch::SetColour
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCRenderObject@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCRenderObject@@QAEPAXI@Z PROC			; CRenderObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CRenderObject@@QAE@XZ		; CRenderObject::~CRenderObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCRenderObject@@QAEPAXI@Z ENDP			; CRenderObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\renderobject.h
;	COMDAT ?Render@CRenderObject@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Render@CRenderObject@@QAEXXZ PROC			; CRenderObject::Render, COMDAT
; _this$ = ecx

; 85   : 	void Render() { mModel->Render( mTechnique ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?Render@CModel@@QAEXPAUID3DX11EffectTechnique@@@Z ; CModel::Render
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Render@CRenderObject@@QAEXXZ ENDP			; CRenderObject::Render
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\renderobject.h
;	COMDAT ?IsTransparent@CRenderObject@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsTransparent@CRenderObject@@QAE_NXZ PROC		; CRenderObject::IsTransparent, COMDAT
; _this$ = ecx

; 80   : 	bool IsTransparent() { return mIsTransparent; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+33]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTransparent@CRenderObject@@QAE_NXZ ENDP		; CRenderObject::IsTransparent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\renderobject.h
;	COMDAT ?IsLit@CRenderObject@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsLit@CRenderObject@@QAE_NXZ PROC			; CRenderObject::IsLit, COMDAT
; _this$ = ecx

; 75   : 	bool IsLit() { return mIsLit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+32]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLit@CRenderObject@@QAE_NXZ ENDP			; CRenderObject::IsLit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\renderobject.h
;	COMDAT ?GetNormalMap@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNormalMap@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ PROC ; CRenderObject::GetNormalMap, COMDAT
; _this$ = ecx

; 72   : 	ID3D10ShaderResourceView* GetNormalMap() { return mNormMap; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNormalMap@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ ENDP ; CRenderObject::GetNormalMap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\renderobject.h
;	COMDAT ?GetTexture@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetTexture@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ PROC ; CRenderObject::GetTexture, COMDAT
; _this$ = ecx

; 69   : 	ID3D10ShaderResourceView* GetTexture() { return mTexture; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTexture@CRenderObject@@QAEPAUID3D11ShaderResourceView@@XZ ENDP ; CRenderObject::GetTexture
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\renderobject.h
;	COMDAT ?GetColourV@CRenderObject@@QAE?AUXMFLOAT3@DirectX@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetColourV@CRenderObject@@QAE?AUXMFLOAT3@DirectX@@XZ PROC ; CRenderObject::GetColourV, COMDAT
; _this$ = ecx

; 58   : 	DirectX::XMFLOAT3 GetColourV(){ return DirectX::XMFLOAT3( mr, mg, mb ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetColourV@CRenderObject@@QAE?AUXMFLOAT3@DirectX@@XZ ENDP ; CRenderObject::GetColourV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\renderobject.h
;	COMDAT ?GetModel@CRenderObject@@QAEPAVCModel@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetModel@CRenderObject@@QAEPAVCModel@@XZ PROC		; CRenderObject::GetModel, COMDAT
; _this$ = ecx

; 53   : 	CModel* GetModel() { return mModel; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CRenderObject@@QAEPAVCModel@@XZ ENDP		; CRenderObject::GetModel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCLight@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCLight@@QAEPAXI@Z PROC				; CLight::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CLight@@QAE@XZ			; CLight::~CLight
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCLight@@QAEPAXI@Z ENDP				; CLight::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\light.h
;	COMDAT ?GetBrightness@CLight@@QAEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBrightness@CLight@@QAEMXZ PROC			; CLight::GetBrightness, COMDAT
; _this$ = ecx

; 69   : 	float GetBrightness() { return mBrightness; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBrightness@CLight@@QAEMXZ ENDP			; CLight::GetBrightness
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\light.h
;	COMDAT ?GetModel@CLight@@QAEPAVCModel@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetModel@CLight@@QAEPAVCModel@@XZ PROC			; CLight::GetModel, COMDAT
; _this$ = ecx

; 66   : 	CModel* GetModel() { return mModel; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CLight@@QAEPAVCModel@@XZ ENDP			; CLight::GetModel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\light.h
;	COMDAT ?GetColourV@CLight@@QAE?AUXMFLOAT3@DirectX@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetColourV@CLight@@QAE?AUXMFLOAT3@DirectX@@XZ PROC	; CLight::GetColourV, COMDAT
; _this$ = ecx

; 55   : 	DirectX::XMFLOAT3 GetColourV(){ return DirectX::XMFLOAT3( mr, mg, mb ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetColourV@CLight@@QAE?AUXMFLOAT3@DirectX@@XZ ENDP	; CLight::GetColourV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\mapsquare.h
;	COMDAT ?GetPathSplines@MapSquare@@QAEXAAIAAPAPAUsCoords@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_numSplines$ = 8					; size = 4
_splines$ = 12						; size = 4
?GetPathSplines@MapSquare@@QAEXAAIAAPAPAUsCoords@@@Z PROC ; MapSquare::GetPathSplines, COMDAT
; _this$ = ecx

; 148  : 	void GetPathSplines(uint32_t &numSplines, sCoords** &splines){ numSplines = mi_splineCount; splines = ms_pathSplines; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _numSplines$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36928]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20544				; 00005040H
	mov	ecx, DWORD PTR _splines$[ebp]
	mov	DWORD PTR [ecx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetPathSplines@MapSquare@@QAEXAAIAAPAPAUsCoords@@@Z ENDP ; MapSquare::GetPathSplines
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\mapsquare.h
;	COMDAT ?GetPathNodes@MapSquare@@QAEXAAIAAPAUCoords@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_numNodes$ = 8						; size = 4
_nodes$ = 12						; size = 4
?GetPathNodes@MapSquare@@QAEXAAIAAPAUCoords@@@Z PROC	; MapSquare::GetPathNodes, COMDAT
; _this$ = ecx

; 146  : 	void GetPathNodes(uint32_t &numNodes, Coords* &nodes){ numNodes = mi_nodeCount; nodes = ms_path; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _numNodes$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20540]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _nodes$[ebp]
	mov	DWORD PTR [ecx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetPathNodes@MapSquare@@QAEXAAIAAPAUCoords@@@Z ENDP	; MapSquare::GetPathNodes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\mapsquare.h
;	COMDAT ?GetHeight@MapSquare@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetHeight@MapSquare@@QAEIXZ PROC			; MapSquare::GetHeight, COMDAT
; _this$ = ecx

; 130  : 	UINT32 GetHeight() { return mi_mapHeight; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300300]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHeight@MapSquare@@QAEIXZ ENDP			; MapSquare::GetHeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\mapsquare.h
;	COMDAT ?GetWidth@MapSquare@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWidth@MapSquare@@QAEIXZ PROC			; MapSquare::GetWidth, COMDAT
; _this$ = ecx

; 128  : 	UINT32 GetWidth() { return mi_mapWidth; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300304]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWidth@MapSquare@@QAEIXZ ENDP			; MapSquare::GetWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\mapsquare.h
;	COMDAT ?GetValueByOffset@MapSquare@@QAEIIIH@Z
_TEXT	SEGMENT
_target$ = -20						; size = 4
_this$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_offset$ = 16						; size = 4
?GetValueByOffset@MapSquare@@QAEIIIH@Z PROC		; MapSquare::GetValueByOffset, COMDAT
; _this$ = ecx

; 108  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 		UINT32* target = (UINT32*) mv_nodes[x][y];

	mov	eax, DWORD PTR _x$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+38156]
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _target$[ebp], ecx

; 110  : 		target += offset;

	mov	eax, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _target$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _target$[ebp], edx

; 111  : 		return *target;

	mov	eax, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [eax]

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetValueByOffset@MapSquare@@QAEIIIH@Z ENDP		; MapSquare::GetValueByOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\mapsquare.h
;	COMDAT ?GetCost@MapSquare@@QAEIII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetCost@MapSquare@@QAEIII@Z PROC			; MapSquare::GetCost, COMDAT
; _this$ = ecx

; 99   : 	UINT32 GetCost( UINT32 x, UINT32 y )	{ return mv_nodes[x][y]->cost; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _x$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+38156]
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetCost@MapSquare@@QAEIII@Z ENDP			; MapSquare::GetCost
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\camera.h
;	COMDAT ?SetNearClip@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nearClip$ = 8						; size = 4
?SetNearClip@CCamera@@QAEXM@Z PROC			; CCamera::SetNearClip, COMDAT
; _this$ = ecx

; 112  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 		m_NearClip = nearClip;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _nearClip$[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 114  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNearClip@CCamera@@QAEXM@Z ENDP			; CCamera::SetNearClip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\camera.h
;	COMDAT ?SetRotation@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rotation$ = 8						; size = 12
?SetRotation@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z PROC	; CCamera::SetRotation, COMDAT
; _this$ = ecx

; 104  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		m_Rotation = rotation;

	lea	eax, DWORD PTR _rotation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT3::operator=

; 106  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetRotation@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z ENDP	; CCamera::SetRotation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\camera.h
;	COMDAT ?SetPosition@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 12
?SetPosition@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z PROC	; CCamera::SetPosition, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		m_Position = position;

	lea	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT3::operator=

; 102  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetPosition@CCamera@@QAEXUXMFLOAT3@DirectX@@@Z ENDP	; CCamera::SetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\camera.h
;	COMDAT ?GetProjectionMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetProjectionMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ PROC ; CCamera::GetProjectionMatrix, COMDAT
; _this$ = ecx

; 76   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 		return m_ProjMatrix;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 176				; 000000b0H
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetProjectionMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ ENDP ; CCamera::GetProjectionMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\camera.h
;	COMDAT ?GetViewMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetViewMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ PROC	; CCamera::GetViewMatrix, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 		return m_ViewMatrix;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 112				; 00000070H
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 74   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetViewMatrix@CCamera@@QAE?AUXMMATRIX@DirectX@@XZ ENDP	; CCamera::GetViewMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\camera.h
;	COMDAT ?SetViewport@CCamera@@SAXHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?SetViewport@CCamera@@SAXHH@Z PROC			; CCamera::SetViewport, COMDAT

; 49   : 	static void SetViewport( int width, int height ) { mViewportWidth = width; mViewportHeight = height; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR ?mViewportWidth@CCamera@@0HA, eax ; CCamera::mViewportWidth
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR ?mViewportHeight@CCamera@@0HA, eax ; CCamera::mViewportHeight
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetViewport@CCamera@@SAXHH@Z ENDP			; CCamera::SetViewport
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\model.h
;	COMDAT ?SetScale@CModel@@QAEXM@Z
_TEXT	SEGMENT
$T1 = -220						; size = 12
_this$ = -8						; size = 4
_scale$ = 8						; size = 4
?SetScale@CModel@@QAEXM@Z PROC				; CModel::SetScale, COMDAT
; _this$ = ecx

; 150  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 		m_Scale = DirectX::XMFLOAT3( scale, scale, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z	; DirectX::XMFLOAT3::operator=

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale@CModel@@QAEXM@Z ENDP				; CModel::SetScale
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\model.h
;	COMDAT ?GetWorldMatrix@CModel@@QAE?AUXMMATRIX@DirectX@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetWorldMatrix@CModel@@QAE?AUXMMATRIX@DirectX@@XZ PROC	; CModel::GetWorldMatrix, COMDAT
; _this$ = ecx

; 131  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		return m_WorldMatrix;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 48					; 00000030H
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 133  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetWorldMatrix@CModel@@QAE?AUXMMATRIX@DirectX@@XZ ENDP	; CModel::GetWorldMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\model.h
;	COMDAT ?GetPosition@CModel@@QAE?AUXMFLOAT3@DirectX@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPosition@CModel@@QAE?AUXMFLOAT3@DirectX@@XZ PROC	; CModel::GetPosition, COMDAT
; _this$ = ecx

; 118  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 		return m_Position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 120  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPosition@CModel@@QAE?AUXMFLOAT3@DirectX@@XZ ENDP	; CModel::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\model.h
;	COMDAT ?SetDeviceContext@CModel@@SAXPAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_newDevCont$ = 8					; size = 4
?SetDeviceContext@CModel@@SAXPAUID3D11DeviceContext@@@Z PROC ; CModel::SetDeviceContext, COMDAT

; 98   : 	static void SetDeviceContext(ID3D11DeviceContext* newDevCont) { mp_d3dDeviceContext = newDevCont; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _newDevCont$[ebp]
	mov	DWORD PTR ?mp_d3dDeviceContext@CModel@@0PAUID3D11DeviceContext@@A, eax ; CModel::mp_d3dDeviceContext
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetDeviceContext@CModel@@SAXPAUID3D11DeviceContext@@@Z ENDP ; CModel::SetDeviceContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\model.h
;	COMDAT ?SetDevice@CModel@@SAXPAUID3D11Device@@@Z
_TEXT	SEGMENT
_newDevice$ = 8						; size = 4
?SetDevice@CModel@@SAXPAUID3D11Device@@@Z PROC		; CModel::SetDevice, COMDAT

; 97   : 	static void SetDevice(ID3D11Device* newDevice) { mpd3dDev = newDevice; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _newDevice$[ebp]
	mov	DWORD PTR ?mpd3dDev@CModel@@0PAUID3D11Device@@A, eax ; CModel::mpd3dDev
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetDevice@CModel@@SAXPAUID3D11Device@@@Z ENDP		; CModel::SetDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ?square@@YAMM@Z
_TEXT	SEGMENT
tv67 = -196						; size = 4
_x$ = 8							; size = 4
?square@@YAMM@Z PROC					; square, COMDAT

; 107  : inline float square (float x) { return x * x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR tv67[ebp], xmm0
	fld	DWORD PTR tv67[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?square@@YAMM@Z ENDP					; square
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ?ToRadians@@YAMM@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
_deg$ = 8						; size = 4
?ToRadians@@YAMM@Z PROC					; ToRadians, COMDAT

; 105  : inline float ToRadians( float deg ) { return deg * (float)D3DX_PI / 180.0f ; }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _deg$[ebp]
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ToRadians@@YAMM@Z ENDP					; ToRadians
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__E_ORANGE@@YAXXZ
text$di	SEGMENT
??__E_ORANGE@@YAXXZ PROC				; `dynamic initializer for '_ORANGE'', COMDAT

; 84   : const DirectX::XMFLOAT3 _ORANGE = DirectX::XMFLOAT3(1.0f, 0.5f, 0.1f);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET __ORANGE
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_ORANGE@@YAXXZ ENDP				; `dynamic initializer for '_ORANGE''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__E_GREEN@@YAXXZ
text$di	SEGMENT
??__E_GREEN@@YAXXZ PROC					; `dynamic initializer for '_GREEN'', COMDAT

; 83   : const DirectX::XMFLOAT3 _GREEN = DirectX::XMFLOAT3( 0.0f, 0.8f, 0.0f );

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET __GREEN
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_GREEN@@YAXXZ ENDP					; `dynamic initializer for '_GREEN''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__E_LRED@@YAXXZ
text$di	SEGMENT
??__E_LRED@@YAXXZ PROC					; `dynamic initializer for '_LRED'', COMDAT

; 82   : const DirectX::XMFLOAT3 _LRED = DirectX::XMFLOAT3( 0.8f, 0.6f, 0.6f);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET __LRED
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_LRED@@YAXXZ ENDP					; `dynamic initializer for '_LRED''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__E_MRED@@YAXXZ
text$di	SEGMENT
??__E_MRED@@YAXXZ PROC					; `dynamic initializer for '_MRED'', COMDAT

; 81   : const DirectX::XMFLOAT3 _MRED = DirectX::XMFLOAT3( 0.8f, 0.3f, 0.3f);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET __MRED
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_MRED@@YAXXZ ENDP					; `dynamic initializer for '_MRED''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__E_RED@@YAXXZ
text$di	SEGMENT
??__E_RED@@YAXXZ PROC					; `dynamic initializer for '_RED'', COMDAT

; 80   : const DirectX::XMFLOAT3 _RED = DirectX::XMFLOAT3( 0.8f, 0.0f, 0.0f );

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET __RED
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_RED@@YAXXZ ENDP					; `dynamic initializer for '_RED''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__E_WHITE@@YAXXZ
text$di	SEGMENT
??__E_WHITE@@YAXXZ PROC					; `dynamic initializer for '_WHITE'', COMDAT

; 79   : const DirectX::XMFLOAT3 _WHITE = DirectX::XMFLOAT3( 1.0f, 1.0f, 1.0f );

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET __WHITE
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_WHITE@@YAXXZ ENDP					; `dynamic initializer for '_WHITE''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__E_BLACK@@YAXXZ
text$di	SEGMENT
??__E_BLACK@@YAXXZ PROC					; `dynamic initializer for '_BLACK'', COMDAT

; 78   : const DirectX::XMFLOAT3 _BLACK = DirectX::XMFLOAT3( 0.0f, 0.0f, 0.0f );

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET __BLACK
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_BLACK@@YAXXZ ENDP					; `dynamic initializer for '_BLACK''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__ENO_ROTATION@@YAXXZ
text$di	SEGMENT
??__ENO_ROTATION@@YAXXZ PROC				; `dynamic initializer for 'NO_ROTATION'', COMDAT

; 76   : const DirectX::XMFLOAT3 NO_ROTATION = DirectX::XMFLOAT3( 0.0f, 0.0f, 0.0f );

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET _NO_ROTATION
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__ENO_ROTATION@@YAXXZ ENDP				; `dynamic initializer for 'NO_ROTATION''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__EORIGIN@@YAXXZ
text$di	SEGMENT
??__EORIGIN@@YAXXZ PROC					; `dynamic initializer for 'ORIGIN'', COMDAT

; 75   : const DirectX::XMFLOAT3 ORIGIN = DirectX::XMFLOAT3(0.0f,0.0f,0.0f);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET _ORIGIN
	call	??0XMFLOAT3@DirectX@@QAE@MMM@Z		; DirectX::XMFLOAT3::XMFLOAT3
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EORIGIN@@YAXXZ ENDP					; `dynamic initializer for 'ORIGIN''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__EZAXIS@@YAXXZ
text$di	SEGMENT
$T1 = -224						; size = 16
??__EZAXIS@@YAXXZ PROC					; `dynamic initializer for 'ZAXIS'', COMDAT

; 73   : const DirectX::XMVECTOR ZAXIS = DirectX::XMVectorSet(0.0f,0.0f,1.0f,1.0f);

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@00000000
	movss	xmm0, DWORD PTR __real@00000000
	call	?XMVectorSet@DirectX@@YQ?AT__m128@@MMMM@Z ; DirectX::XMVectorSet
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	movaps	XMMWORD PTR _ZAXIS, xmm0
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
??__EZAXIS@@YAXXZ ENDP					; `dynamic initializer for 'ZAXIS''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__EYAXIS@@YAXXZ
text$di	SEGMENT
$T1 = -224						; size = 16
??__EYAXIS@@YAXXZ PROC					; `dynamic initializer for 'YAXIS'', COMDAT

; 72   : const DirectX::XMVECTOR YAXIS = DirectX::XMVectorSet(0.0f,1.0f,0.0f,1.0f);

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@00000000
	movss	xmm1, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR __real@00000000
	call	?XMVectorSet@DirectX@@YQ?AT__m128@@MMMM@Z ; DirectX::XMVectorSet
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	movaps	XMMWORD PTR _YAXIS, xmm0
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
??__EYAXIS@@YAXXZ ENDP					; `dynamic initializer for 'YAXIS''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\sparta2.0\uclan-sparta\defines.h
;	COMDAT ??__EXAXIS@@YAXXZ
text$di	SEGMENT
$T1 = -224						; size = 16
??__EXAXIS@@YAXXZ PROC					; `dynamic initializer for 'XAXIS'', COMDAT

; 71   : const DirectX::XMVECTOR XAXIS = DirectX::XMVectorSet(1.0f,0.0f,0.0f,1.0f);

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@00000000
	movss	xmm1, DWORD PTR __real@00000000
	movss	xmm0, DWORD PTR __real@3f800000
	call	?XMVectorSet@DirectX@@YQ?AT__m128@@MMMM@Z ; DirectX::XMVectorSet
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	movaps	XMMWORD PTR _XAXIS, xmm0
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
??__EXAXIS@@YAXXZ ENDP					; `dynamic initializer for 'XAXIS''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 615  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 616  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 617  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 618  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 619  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	eax, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 610  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 602  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 585  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 586  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 587  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 589  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 579  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	eax, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 566  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 558  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 355  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 337  : 		{	// get category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 332  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 333  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 334  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 300  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 246  : 		{	// get category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 248  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 241  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 243  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 178  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 393  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	esi, esp
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 386  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 379  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 652  : 	{	// get system_category

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 653  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 642  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 643  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 545  : 	{	// test iterator for non-singularity, const pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 546  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 547  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN2@Debug_poin:

; 548  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2294 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2296 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2289 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2291 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Ptr$3 = -20						; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2273 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$3[ebp], ecx

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2279 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$3[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$3[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2285 : 		_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2286 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2260 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2261 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2262 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -208						; size = 4
tv129 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2243 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2244 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	eax, BYTE PTR __Trim$[ebp]
	test	eax, eax
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2251 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2253 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2238 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -288						; size = 4
tv203 = -288						; size = 4
tv204 = -284						; size = 4
tv202 = -284						; size = 4
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Ptr$ = -48						; size = 4
__Newres$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2203 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $LN5@Copy

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR __Newres$[ebp], ecx

; 2210 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2211 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	edx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2216 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 2218 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2222 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2223 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2224 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2229 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2231 : 		this->_Myres = _Newres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2232 : 		_Eos(_Oldlen);

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2233 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@Copy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN23@Copy:
	DD	1
	DD	$LN22@Copy
$LN22@Copy:
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN20@Copy
$LN20@Copy:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -221						; size = 1
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1758 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv75[ebp], eax
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1761 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1753 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1755 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -32					; size = 4
__Ptr$2 = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1344 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1347 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], ecx

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	sub	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$2[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	push	edx
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1352 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1353 : 			}
; 1354 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1355 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1336 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1337 : 		_Eos(_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1338 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1339 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 		_DEBUG_POINTER(_Ptr);

	push	1168					; 00000490H
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1170 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN3@assign

; 1151 : 			_DEBUG_POINTER(_Ptr);

	push	1151					; 0000047fH
	push	OFFSET ??_C@_1IO@JLPDPDPD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN3@assign:

; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN4@assign
$LN2@assign:

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1161 : 			_Eos(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1162 : 			}
; 1163 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN4@assign:

; 1164 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1131 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1132 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1133 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1134 : 			_Num = _Count;	// trim _Num to size

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
$LN4@assign:

; 1135 : 
; 1136 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1138 : 		else if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1142 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1143 : 			}
; 1144 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1145 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 781  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 782  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 684  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 672  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 675  : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 676  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 678  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 679  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 663  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 666  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 668  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 669  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 649  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 650  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 651  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 643  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 646  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base12@std@@QAE@XZ	; std::_Container_base12::~_Container_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 517  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 521  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 510  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 514  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 492  : 	_String_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 495  : 		_Myres = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 496  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 885  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 736  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 613  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2821 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET ??__F_AtlWinModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlWinModule''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2805 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2806 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A ; ATL::_AtlBaseModule
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2807 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2800 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2801 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2802 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2786 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2787 : 	{
; 2788 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2789 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
	mov	DWORD PTR _hr$[ebp], eax

; 2790 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@CAtlWinMod

; 2791 : 		{
; 2792 : 			ATLASSERT(0);

	xor	eax, eax
	jne	SHORT $LN4@CAtlWinMod
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	2792					; 00000ae8H
	push	OFFSET ??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@CAtlWinMod
	int	3
$LN4@CAtlWinMod:

; 2793 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2794 : 			cbSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@CAtlWinMod:

; 2795 : 			return;
; 2796 : 		}
; 2797 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	??1CAtlComModule@ATL@@QAE@XZ		; ATL::CAtlComModule::~CAtlComModule
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2565 : __declspec(selectany) CAtlComModule _AtlComModule;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	??0CAtlComModule@ATL@@QAE@XZ		; ATL::CAtlComModule::CAtlComModule
	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_factory$1 = -44					; size = 4
_pCache$2 = -32						; size = 4
_ppEntry$3 = -20					; size = 4
_this$ = -8						; size = 4
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2462 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2463 : 		if (cbSize == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN6@Term

; 2464 : 			return;

	jmp	$LN7@Term
$LN6@Term:

; 2465 : 
; 2466 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ppEntry$3[ebp], ecx
	jmp	SHORT $LN5@Term
$LN4@Term:
	mov	eax, DWORD PTR _ppEntry$3[ebp]
	add	eax, 4
	mov	DWORD PTR _ppEntry$3[ebp], eax
$LN5@Term:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ppEntry$3[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN3@Term

; 2467 : 		{
; 2468 : 			if (*ppEntry != NULL)

	mov	eax, DWORD PTR _ppEntry$3[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Term

; 2469 : 			{
; 2470 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

	mov	eax, DWORD PTR _ppEntry$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _pCache$2[ebp], edx

; 2471 : 				
; 2472 : 				if (pCache->pCF != NULL)

	mov	eax, DWORD PTR _pCache$2[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Term

; 2473 : 				{
; 2474 : 					// Decode factory pointer if it's not null
; 2475 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

	mov	esi, esp
	mov	eax, DWORD PTR _pCache$2[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__DecodePointer@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _factory$1[ebp], eax

; 2476 : 					_Analysis_assume_(factory != nullptr);
; 2477 : 					factory->Release();					

	mov	eax, DWORD PTR _factory$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _factory$1[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2478 : 					pCache->pCF = NULL;

	mov	eax, DWORD PTR _pCache$2[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Term:

; 2479 : 				}				
; 2480 : 			}
; 2481 : 		}

	jmp	SHORT $LN4@Term
$LN3@Term:

; 2482 : 		m_csObjMap.Term();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 2483 : 		// Set to 0 to indicate that this function has been called
; 2484 : 		// At this point no one should be concerned about cbsize
; 2485 : 		// having the correct value
; 2486 : 		cbSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN7@Term:

; 2487 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2456 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlComModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2457 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2458 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CAtlComModule@ATL@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2435 : 	CAtlComModule() throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_COM_MODULE70@ATL@@QAE@XZ

; 2436 : 	{
; 2437 : 		cbSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2438 : 
; 2439 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], OFFSET ___ImageBase

; 2440 : 
; 2441 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], OFFSET ___pobjMapEntryFirst+4

; 2442 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], OFFSET ___pobjMapEntryLast

; 2443 : 
; 2444 : 		if (FAILED(m_csObjMap.Init()))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Init@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Init
	test	eax, eax
	jge	SHORT $LN1@CAtlComMod

; 2445 : 		{
; 2446 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));

	push	OFFSET ??_C@_1IA@KEEOONGN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
	push	0
	mov	ecx, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
	call	??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<2,0>::operator unsigned int
	push	eax
	push	2446					; 0000098eH
	push	OFFSET ??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 2447 : 			ATLASSERT(0);

	xor	eax, eax
	jne	SHORT $LN4@CAtlComMod
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	2447					; 0000098fH
	push	OFFSET ??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@CAtlComMod
	int	3
$LN4@CAtlComMod:

; 2448 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2449 : 			return;

	jmp	SHORT $LN2@CAtlComMod
$LN1@CAtlComMod:

; 2450 : 		}
; 2451 : 		// Set cbSize on success.
; 2452 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 40			; 00000028H
$LN2@CAtlComMod:

; 2453 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7673 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7674 : 	if (pWinModule == NULL)

	cmp	DWORD PTR _pWinModule$[ebp], 0
	jne	SHORT $LN6@AtlWinModu

; 7675 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN7@AtlWinModu
$LN6@AtlWinModu:

; 7676 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@AtlWinModu

; 7677 : 		return S_OK;

	xor	eax, eax
	jmp	SHORT $LN7@AtlWinModu
$LN5@AtlWinModu:

; 7678 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 44			; 0000002cH
	je	SHORT $LN4@AtlWinModu

; 7679 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	SHORT $LN7@AtlWinModu
$LN4@AtlWinModu:

; 7680 : 
; 7681 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@AtlWinModu
$LN2@AtlWinModu:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@AtlWinModu:
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
	cmp	DWORD PTR _i$1[ebp], eax
	jge	SHORT $LN1@AtlWinModu

; 7682 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	esi, esp
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax]
	push	edx
	call	DWORD PTR __imp__UnregisterClassW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN2@AtlWinModu
$LN1@AtlWinModu:

; 7683 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 7684 : 	pWinModule->m_csWindowCreate.Term();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 4
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 7685 : 	pWinModule->cbSize = 0;

	mov	eax, DWORD PTR _pWinModule$[ebp]
	mov	DWORD PTR [eax], 0

; 7686 : 	return S_OK;

	xor	eax, eax
$LN7@AtlWinModu:

; 7687 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_hr$ = -8						; size = 4
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 8418 : 	if (pWinModule == NULL)

	cmp	DWORD PTR _pWinModule$[ebp], 0
	jne	SHORT $LN3@AtlWinModu

; 8419 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN4@AtlWinModu
$LN3@AtlWinModu:

; 8420 : 
; 8421 : 	// check only in the DLL
; 8422 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 44			; 0000002cH
	je	SHORT $LN2@AtlWinModu

; 8423 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN4@AtlWinModu
$LN2@AtlWinModu:

; 8424 : 
; 8425 : 	pWinModule->m_pCreateWndList = NULL;

	mov	eax, DWORD PTR _pWinModule$[ebp]
	mov	DWORD PTR [eax+28], 0

; 8426 : 
; 8427 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 4
	call	?Init@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Init
	mov	DWORD PTR _hr$[ebp], eax

; 8428 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@AtlWinModu

; 8429 : 	{
; 8430 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));

	push	OFFSET ??_C@_1IG@OPJAFKJH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?3?$AA?5?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AA?5?$AAc?$AAr?$AAi@
	push	0
	mov	ecx, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
	call	??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<32,0>::operator unsigned int
	push	eax
	mov	eax, DWORD PTR ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0FA@ODGKGNGJ@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 8431 : 		ATLASSERT(0);

	xor	eax, eax
	jne	SHORT $LN1@AtlWinModu
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@2@@Z@4JA
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET ??_C@_1KA@ELJIHIAD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN1@AtlWinModu
	int	3
$LN1@AtlWinModu:

; 8432 : 	}
; 8433 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$LN4@AtlWinModu:

; 8434 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::~CComCriticalSection
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::~CComCriticalSection
__ehhandler$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::~CComCriticalSection
__ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 230  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN5@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN6@operator
$LN5@operator:
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	231					; 000000e7H
	push	OFFSET ??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:

; 232  : 		if(nIndex < 0 || nIndex >= m_nSize)

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN2@operator
$LN1@operator:

; 233  : 		{
; 234  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN2@operator:

; 235  : 		}
; 236  : 		return m_aT[nIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]
$LN4@operator:

; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 209  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@RemoveAll

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@RemoveAll
$LN2@RemoveAll:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@RemoveAll:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN1@RemoveAll

; 213  : 				m_aT[i].~T();

	jmp	SHORT $LN2@RemoveAll
$LN1@RemoveAll:

; 214  : 			free(m_aT);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 215  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@RemoveAll:

; 216  : 		}
; 217  : 		m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 218  : 		m_nAllocSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 219  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		return m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 305  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 120  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 121  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::~CComCriticalSection
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 274  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 275  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 276  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		DeleteCriticalSection(&m_sec);

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 141  : 		return S_OK;

	xor	eax, eax

; 142  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_hRes$ = -20						; size = 4
_this$ = -8						; size = 4
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 128  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		HRESULT hRes = S_OK;

	mov	DWORD PTR _hRes$[ebp], 0

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@Init

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	mov	DWORD PTR _hRes$[ebp], eax
$LN1@Init:

; 133  : 		}
; 134  : 
; 135  : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]

; 136  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 108  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	{
; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 111  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 70   : 	#if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 71   : 		// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	mov	esi, esp
	mov	eax, DWORD PTR _Flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwSpinCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCriticalSection$[ebp]
	push	edx
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 	#else
; 74   : 		UNREFERENCED_PARAMETER(Flags);
; 75   : 
; 76   : 		// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 77   : 		return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 78   : 	#endif
; 79   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
_dwError$ = -8						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC			; ATL::AtlThrowLastWin32, COMDAT

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 85   : 	DWORD dwError = ::GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$[ebp], eax

; 86   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

	mov	eax, DWORD PTR _dwError$[ebp]
	push	eax
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	push	eax
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN2@AtlThrowLa:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T1 = -228						; size = 8
$T2 = -212						; size = 4
$T3 = -200						; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	push	OFFSET ??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@
	push	0
	mov	ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
	call	??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )
; 69   : 	{
; 70   : 		AfxThrowMemoryException();
; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );
; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CAtlException@ATL@@QAE@J@Z		; ATL::CAtlException::CAtlException
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	push	OFFSET __TI1?AVCAtlException@ATL@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8
$LN2@AtlThrowIm:

; 78   : #endif
; 79   : };

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 44   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [eax], ecx

; 45   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _dwExceptionFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwExceptionCode$[ebp]
	push	ecx
	call	DWORD PTR __imp__RaiseException@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 32   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ PROC		; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 385  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 386  : 		va_list ptr; va_start(ptr, pszFmt);

	lea	eax, DWORD PTR _pszFmt$[ebp+4]
	mov	DWORD PTR _ptr$[ebp], eax

; 387  : 		ATL::CTrace::TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z	; ATL::CTrace::TraceV
	add	esp, 24					; 00000018H

; 388  : 		va_end(ptr);

	mov	DWORD PTR _ptr$[ebp], 0

; 389  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 361  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszFileName$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nLineNo$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 362  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nBytes$ = -20						; size = 4
_this$ = -8						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 470  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 471  : 		size_t nBytes=0;

	mov	DWORD PTR _nBytes$[ebp], 0

; 472  : 		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))

	push	2
	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nBytes$[ebp]
	push	ecx
	call	??$AtlMultiply@I@ATL@@YAJPAIII@Z	; ATL::AtlMultiply<unsigned int>
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN1@Allocate

; 473  : 		{
; 474  : 			return false;

	xor	al, al
	jmp	SHORT $LN2@Allocate
$LN1@Allocate:

; 475  : 		}
; 476  : 		return AllocateBytes(nBytes);

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
$LN2@Allocate:

; 477  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Allocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN6@Allocate:
	DD	1
	DD	$LN5@Allocate
$LN5@Allocate:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@Allocate
$LN4@Allocate:
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 449  : 	CHeapPtr() throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>

; 450  : 	{
; 451  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		Allocator::Free(m_pData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 424  : 		m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 425  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 396  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 397  : 		ATLASSERT(m_pData == NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@AllocateBy
	push	OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	397					; 0000018dH
	push	OFFSET ??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN4@AllocateBy
	int	3
$LN4@AllocateBy:

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 399  : 		if (m_pData == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@AllocateBy

; 400  : 			return false;

	xor	al, al
	jmp	SHORT $LN2@AllocateBy
$LN1@AllocateBy:

; 401  : 
; 402  : 		return true;

	mov	al, 1
$LN2@AllocateBy:

; 403  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *, COMDAT
; _this$ = ecx

; 378  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 379  : 		return m_pData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 380  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 364  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 365  : 		Free();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free

; 366  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 351  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 352  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z
_TEXT	SEGMENT
_pszCategory$ = 8					; size = 4
_nCategory$ = 12					; size = 4
?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z PROC		; ATL::CTrace::RegisterCategory, COMDAT

; 300  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 301  : 		if (pszCategory == nullptr)

	cmp	DWORD PTR _pszCategory$[ebp], 0
	jne	SHORT $LN2@RegisterCa

; 302  : 		{
; 303  : 			return;

	jmp	SHORT $LN3@RegisterCa
$LN2@RegisterCa:

; 304  : 		}
; 305  : 
; 306  : 		if (m_nLastCategory >= MaxCategoryArray) 

	cmp	DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 32 ; ATL::CTrace::m_nLastCategory, 00000020H
	jb	SHORT $LN1@RegisterCa

; 307  : 		{
; 308  : 			ATLASSERT(false && "Too many categories defined");

	xor	eax, eax
	jne	SHORT $LN5@RegisterCa
	push	OFFSET ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	308					; 00000134H
	push	OFFSET ??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN5@RegisterCa
	int	3
$LN5@RegisterCa:

; 309  : 			return;

	jmp	SHORT $LN3@RegisterCa
$LN1@RegisterCa:

; 310  : 		}
; 311  : 
; 312  : 		m_nMap[m_nLastCategory].nCategory = nCategory;

	imul	eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
	mov	ecx, DWORD PTR _nCategory$[ebp]
	mov	DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax], ecx

; 313  : #ifdef _UNICODE
; 314  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, pszCategory);

	mov	eax, DWORD PTR _pszCategory$[ebp]
	push	eax
	push	127					; 0000007fH
	imul	ecx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
	add	ecx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
	push	ecx
	call	_wcscpy_s
	add	esp, 12					; 0000000cH

; 315  : #else
; 316  : 		wchar_t buffer[MaxLengthOfCategoryName] = { 0 };	
; 317  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%S", pszCategory);
; 318  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, buffer);
; 319  : #endif
; 320  : 	
; 321  : 		m_nLastCategory++;

	mov	eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
	add	eax, 1
	mov	DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, eax ; ATL::CTrace::m_nLastCategory
$LN3@RegisterCa:

; 322  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ENDP		; ATL::CTrace::RegisterCategory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
_TEXT	SEGMENT
_wszBuf$ = -32						; size = 4
_cchNeeded$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszFmt$ = 24						; size = 4
_args$ = 28						; size = 4
?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 277  : 		int cchNeeded = _vscwprintf(pwszFmt, args);

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pwszFmt$[ebp]
	push	ecx
	call	__vscwprintf
	add	esp, 8
	mov	DWORD PTR _cchNeeded$[ebp], eax

; 278  : 		if (cchNeeded < 0)

	cmp	DWORD PTR _cchNeeded$[ebp], 0
	jge	SHORT $LN3@TraceV

; 279  : 		{
; 280  : 			return;

	jmp	$LN4@TraceV
$LN3@TraceV:

; 281  : 		}
; 282  : 
; 283  : 		CHeapPtr<wchar_t> wszBuf;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 284  : 		if (!wszBuf.Allocate(cchNeeded + 1))

	mov	eax, DWORD PTR _cchNeeded$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@TraceV

; 285  : 		{
; 286  : 			return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	$LN4@TraceV
$LN2@TraceV:

; 287  : 		}
; 288  : 
; 289  : 		wszBuf[0] = '\0';

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	mov	ecx, 2
	imul	edx, ecx, 0
	xor	ecx, ecx
	mov	WORD PTR [eax+edx], cx

; 290  : 
; 291  : 		if (_vsnwprintf_s(wszBuf, cchNeeded + 1, cchNeeded, pwszFmt, args) == -1)

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pwszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cchNeeded$[ebp]
	push	edx
	mov	eax, DWORD PTR _cchNeeded$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	push	eax
	call	__vsnwprintf_s
	add	esp, 20					; 00000014H
	cmp	eax, -1
	jne	SHORT $LN1@TraceV

; 292  : 		{
; 293  : 			return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	SHORT $LN4@TraceV
$LN1@TraceV:

; 294  : 		}
; 295  : 
; 296  : 		TraceV(pszFileName, nLine, dwCategory, nLevel, wszBuf);

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	push	eax
	mov	eax, DWORD PTR _nLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwCategory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszFileName$[ebp]
	push	eax
	call	?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z	; ATL::CTrace::TraceV
	add	esp, 20					; 00000014H

; 297  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN4@TraceV:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@TraceV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@TraceV:
	DD	1
	DD	$LN9@TraceV
$LN9@TraceV:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN7@TraceV
$LN7@TraceV:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z$0:
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	jmp	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
__ehhandler$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z
_TEXT	SEGMENT
_fileName$ = -2632					; size = 520
_wszBuf$ = -2104					; size = 4
_chCount$ = -2092					; size = 4
_pwszCategoryName$ = -2080				; size = 4
_categoryLength$ = -2068				; size = 4
_wszCategory$ = -2056					; size = 2048
__$ArrayPad$ = -4					; size = 4
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszMessage$ = 24					; size = 4
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 149  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 2828				; 00000b0cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2828]
	mov	ecx, 707				; 000002c3H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 150  : 		if (CTrace::m_nLevel == CTrace::DisableTracing || CTrace::m_nLevel < nLevel || (CTrace::m_nCategory & dwCategory) == 0)

	cmp	DWORD PTR ?m_nLevel@CTrace@ATL@@1IA, -1	; ATL::CTrace::m_nLevel
	je	SHORT $LN8@TraceV
	mov	eax, DWORD PTR ?m_nLevel@CTrace@ATL@@1IA ; ATL::CTrace::m_nLevel
	cmp	eax, DWORD PTR _nLevel$[ebp]
	jb	SHORT $LN8@TraceV
	mov	eax, DWORD PTR ?m_nCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nCategory
	and	eax, DWORD PTR _dwCategory$[ebp]
	jne	SHORT $LN9@TraceV
$LN8@TraceV:

; 151  : 		{
; 152  : 			return;

	jmp	$LN10@TraceV
$LN9@TraceV:

; 153  : 		}
; 154  : 
; 155  : 		wchar_t wszCategory[TraceBufferSize] = {'\0'};

	xor	eax, eax
	mov	WORD PTR _wszCategory$[ebp], ax
	push	2046					; 000007feH
	push	0
	lea	eax, DWORD PTR _wszCategory$[ebp+2]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 156  : 		int categoryLength = 0;

	mov	DWORD PTR _categoryLength$[ebp], 0

; 157  : 		const wchar_t *const pwszCategoryName = GetCategoryName(dwCategory);

	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	call	?GetCategoryName@CTrace@ATL@@CAPA_WI@Z	; ATL::CTrace::GetCategoryName
	add	esp, 4
	mov	DWORD PTR _pwszCategoryName$[ebp], eax

; 158  : 		if (pwszCategoryName != nullptr)

	cmp	DWORD PTR _pwszCategoryName$[ebp], 0
	je	SHORT $LN7@TraceV

; 159  : 		{
; 160  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%s - ", pwszCategoryName)) == -1)

	mov	eax, DWORD PTR _pwszCategoryName$[ebp]
	push	eax
	push	OFFSET ??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _wszCategory$[ebp]
	push	ecx
	call	_swprintf_s
	add	esp, 16					; 00000010H
	mov	DWORD PTR _categoryLength$[ebp], eax
	cmp	DWORD PTR _categoryLength$[ebp], -1
	jne	SHORT $LN6@TraceV

; 161  : 			{
; 162  : 				return;

	jmp	$LN10@TraceV
$LN6@TraceV:

; 163  : 			}
; 164  : 		}
; 165  : 		else

	jmp	SHORT $LN5@TraceV
$LN7@TraceV:

; 166  : 		{
; 167  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%u - ", dwCategory)) == -1)

	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	push	OFFSET ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _wszCategory$[ebp]
	push	ecx
	call	_swprintf_s
	add	esp, 16					; 00000010H
	mov	DWORD PTR _categoryLength$[ebp], eax
	cmp	DWORD PTR _categoryLength$[ebp], -1
	jne	SHORT $LN5@TraceV

; 168  : 			{
; 169  : 				return;

	jmp	$LN10@TraceV
$LN5@TraceV:

; 170  : 			}
; 171  : 		}
; 172  : 
; 173  : 		int chCount = (int)wcslen(pwszMessage) + categoryLength + 1;

	mov	eax, DWORD PTR _pwszMessage$[ebp]
	push	eax
	call	_wcslen
	add	esp, 4
	mov	ecx, DWORD PTR _categoryLength$[ebp]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	DWORD PTR _chCount$[ebp], edx

; 174  : 		CHeapPtr<wchar_t> wszBuf;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>

; 175  : 		if (!wszBuf.Allocate(chCount))

	mov	eax, DWORD PTR _chCount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@TraceV

; 176  : 		{
; 177  : 			return;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	$LN10@TraceV
$LN3@TraceV:

; 178  : 		}
; 179  : 
; 180  : 		wszBuf[0] = '\0';

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	mov	ecx, 2
	imul	edx, ecx, 0
	xor	ecx, ecx
	mov	WORD PTR [eax+edx], cx

; 181  : 
; 182  : 		if (swprintf_s(wszBuf, chCount, L"%s%s", wszCategory, pwszMessage) == -1)

	mov	eax, DWORD PTR _pwszMessage$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wszCategory$[ebp]
	push	ecx
	push	OFFSET ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
	mov	edx, DWORD PTR _chCount$[ebp]
	push	edx
	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
	push	eax
	call	_swprintf_s
	add	esp, 20					; 00000014H
	cmp	eax, -1
	jne	SHORT $LN2@TraceV

; 183  : 		{
; 184  : 			return;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	SHORT $LN10@TraceV
$LN2@TraceV:

; 185  : 		}
; 186  : 
; 187  : 		wchar_t fileName[_MAX_PATH] = {'\0'};	

	xor	eax, eax
	mov	WORD PTR _fileName$[ebp], ax
	push	518					; 00000206H
	push	0
	lea	eax, DWORD PTR _fileName$[ebp+2]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 188  : 		if (swprintf_s(fileName, _MAX_PATH, L"%S", pszFileName) == -1)

	mov	eax, DWORD PTR _pszFileName$[ebp]
	push	eax
	push	OFFSET ??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@
	push	260					; 00000104H
	lea	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	_swprintf_s
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $LN1@TraceV

; 189  : 		{
; 190  : 			return;

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
	jmp	SHORT $LN10@TraceV
$LN1@TraceV:

; 191  : 		}
; 192  : 
; 193  : 		_CrtDbgReportW(_CRT_WARN, fileName, nLine, nullptr, L"%s", wszBuf);

	mov	eax, DWORD PTR _wszBuf$[ebp]
	push	eax
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	mov	ecx, DWORD PTR _nLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fileName$[ebp]
	push	edx
	push	0
	call	__CrtDbgReportW
	add	esp, 24					; 00000018H

; 194  : 	}

	lea	ecx, DWORD PTR _wszBuf$[ebp]
	call	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN10@TraceV:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@TraceV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2828				; 00000b0cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN17@TraceV:
	DD	3
	DD	$LN16@TraceV
$LN16@TraceV:
	DD	-2056					; fffff7f8H
	DD	2048					; 00000800H
	DD	$LN13@TraceV
	DD	-2104					; fffff7c8H
	DD	4
	DD	$LN14@TraceV
	DD	-2632					; fffff5b8H
	DD	520					; 00000208H
	DD	$LN15@TraceV
$LN15@TraceV:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN14@TraceV:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN13@TraceV:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ENDP		; ATL::CTrace::TraceV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_nCategory$ = 8						; size = 4
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z PROC		; ATL::CTrace::GetCategoryName, COMDAT

; 131  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 132  : 		for(unsigned int i = 0; i < m_nLastCategory; i++) 

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetCategor
$LN3@GetCategor:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetCategor:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
	jae	SHORT $LN2@GetCategor

; 133  : 		{
; 134  : 			if (m_nMap[i].nCategory == nCategory)

	imul	eax, DWORD PTR _i$1[ebp], 260
	mov	ecx, DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax]
	cmp	ecx, DWORD PTR _nCategory$[ebp]
	jne	SHORT $LN1@GetCategor

; 135  : 			{
; 136  : 				return m_nMap[i].categryName;

	imul	eax, DWORD PTR _i$1[ebp], 260
	add	eax, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
	jmp	SHORT $LN5@GetCategor
$LN1@GetCategor:

; 137  : 			}
; 138  : 		}

	jmp	SHORT $LN3@GetCategor
$LN2@GetCategor:

; 139  : 
; 140  : 		return nullptr;

	xor	eax, eax
$LN5@GetCategor:

; 141  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ENDP		; ATL::CTrace::GetCategoryName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceISAPI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceISAPI@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceISAPI'', COMDAT

; 118  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceISAPI> atlTraceISAPI(_T("atlTraceISAPI"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
	call	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceISAPI@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceISAPI''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	4194304					; 00400000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSync@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSync@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSync'', COMDAT

; 117  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSync> atlTraceSync(_T("atlTraceSync"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
	call	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceSync@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSync''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	2097152					; 00200000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSecurity@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSecurity@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSecurity'', COMDAT

; 116  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSecurity> atlTraceSecurity(_T("atlTraceSecurity"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
	call	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceSecurity@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSecurity''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	1048576					; 00100000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceUtil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceUtil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceUtil'', COMDAT

; 115  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceUtil> atlTraceUtil(_T("atlTraceUtil"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
	call	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceUtil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceUtil''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceMap@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceMap@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceMap'', COMDAT

; 114  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceMap> atlTraceMap(_T("atlTraceMap"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
	call	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceMap@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceMap''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	262144					; 00040000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceString@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceString@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceString'', COMDAT

; 113  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceString> atlTraceString(_T("atlTraceString"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
	call	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceString@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceString''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	131072					; 00020000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceStencil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceStencil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceStencil'', COMDAT

; 112  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceStencil> atlTraceStencil(_T("atlTraceStencil"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
	call	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceStencil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceStencil''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	65536					; 00010000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCache@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCache@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCache'', COMDAT

; 111  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCache> atlTraceCache(_T("atlTraceCache"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
	call	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceCache@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCache''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	32768					; 00008000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceTime@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceTime@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceTime'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceTime> atlTraceTime(_T("atlTraceTime"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
	call	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceTime@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceTime''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	16384					; 00004000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 109  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
	call	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ PROC	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

	mov	eax, 8192				; 00002000H

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ ENDP	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	8192					; 00002000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceAllocation@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceAllocation@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceAllocation'', COMDAT

; 108  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceAllocation> atlTraceAllocation(_T("atlTraceAllocation"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
	call	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceAllocation@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceAllocation''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	4096					; 00001000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceNotImpl@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceNotImpl@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceNotImpl'', COMDAT

; 107  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceNotImpl> atlTraceNotImpl(_T("atlTraceNotImpl"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
	call	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceNotImpl@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceNotImpl''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	2048					; 00000800H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSnapin@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSnapin@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSnapin'', COMDAT

; 106  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSnapin> atlTraceSnapin(_T("atlTraceSnapin"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
	call	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceSnapin@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSnapin''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	1024					; 00000400H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBProvider@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBProvider@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBProvider'', COMDAT

; 105  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBProvider> atlTraceDBProvider(_T("atlTraceDBProvider"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
	call	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceDBProvider@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBProvider''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	512					; 00000200H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBClient@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBClient@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBClient'', COMDAT

; 104  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBClient> atlTraceDBClient(_T("atlTraceDBClient"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
	call	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceDBClient@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBClient''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	256					; 00000100H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceHosting@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceHosting@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceHosting'', COMDAT

; 103  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceHosting> atlTraceHosting(_T("atlTraceHosting"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
	call	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceHosting@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceHosting''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	128					; 00000080H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceControls@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceControls@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceControls'', COMDAT

; 102  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceControls> atlTraceControls(_T("atlTraceControls"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAs?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
	call	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceControls@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceControls''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	64					; 00000040H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceWindowing@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceWindowing@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceWindowing'', COMDAT

; 101  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceWindowing> atlTraceWindowing(_T("atlTraceWindowing"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi?$AAn?$AAg?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
	call	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceWindowing@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceWindowing''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ PROC	; ATL::CTraceCategoryEx<32,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

	mov	eax, 32					; 00000020H

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAEIXZ ENDP	; ATL::CTraceCategoryEx<32,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	32					; 00000020H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRefcount@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRefcount@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRefcount'', COMDAT

; 100  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRefcount> atlTraceRefcount(_T("atlTraceRefcount"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
	call	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceRefcount@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRefcount''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	16					; 00000010H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRegistrar@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRegistrar@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRegistrar'', COMDAT

; 99   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRegistrar> atlTraceRegistrar(_T("atlTraceRegistrar"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr?$AAa?$AAr?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
	call	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceRegistrar@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRegistrar''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	8
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceQI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceQI@ATL@@YAXXZ PROC				; ATL::`dynamic initializer for 'atlTraceQI'', COMDAT

; 98   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceQI> atlTraceQI(_T("atlTraceQI"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
	call	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceQI@ATL@@YAXXZ ENDP				; ATL::`dynamic initializer for 'atlTraceQI''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	4
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCOM@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCOM@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCOM'', COMDAT

; 97   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCom> atlTraceCOM(_T("atlTraceCOM"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
	call	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceCOM@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCOM''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ PROC		; ATL::CTraceCategoryEx<2,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

	mov	eax, 2

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTraceCategoryEx@$01$0A@@ATL@@QAEIXZ ENDP		; ATL::CTraceCategoryEx<2,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	2
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceGeneral@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceGeneral@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceGeneral'', COMDAT

; 96   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceGeneral> atlTraceGeneral(_T("atlTraceGeneral"));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
	mov	ecx, OFFSET ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
	call	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EatlTraceGeneral@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceGeneral''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	1
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

	push	524288					; 00080000H
	mov	eax, DWORD PTR _pszCategoryName$[ebp]
	push	eax
	call	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
	add	esp, 8

; 428  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 106  : #ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
; 107  : 	return CP_ACP;
; 108  : #else
; 109  : 	return CP_THREAD_ACP;

	mov	eax, 3

; 110  : #endif
; 111  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 281  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 282  : 		free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 283  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 276  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 277  : 		return malloc(nBytes);

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	_malloc
	add	esp, 4

; 278  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_i64Result$ = -12					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

	mov	eax, DWORD PTR _iLeft$[ebp]
	mul	DWORD PTR _iRight$[ebp]
	mov	DWORD PTR _i64Result$[ebp], eax
	mov	DWORD PTR _i64Result$[ebp+4], edx

; 152  : 	if(i64Result>UINT_MAX)

	cmp	DWORD PTR _i64Result$[ebp+4], 0
	ja	SHORT $LN4@AtlMultipl
	cmp	DWORD PTR _i64Result$[ebp], -1
	jbe	SHORT $LN1@AtlMultipl
$LN4@AtlMultipl:

; 153  : 	{
; 154  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

	push	534					; 00000216H
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	jmp	SHORT $LN2@AtlMultipl
$LN1@AtlMultipl:

; 155  : 	}
; 156  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

	mov	eax, DWORD PTR _i64Result$[ebp]
	mov	ecx, DWORD PTR _piResult$[ebp]
	mov	DWORD PTR [ecx], eax

; 157  : 	return S_OK;

	xor	eax, eax
$LN2@AtlMultipl:

; 158  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??0?$function@$$A6AXXZ@std@@QAE@$$T@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$function@$$A6AXXZ@std@@QAE@$$T@Z PROC		; std::function<void __cdecl(void)>::function<void __cdecl(void)>, COMDAT
; _this$ = ecx

; 561  : 	function(nullptr_t) _NOEXCEPT

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_class@X$$$V@std@@QAE@XZ	; std::_Func_class<void>::_Func_class<void>

; 562  : 		{	// construct empty function wrapper from null pointer
; 563  : 		this->_Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Reset

; 564  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$function@$$A6AXXZ@std@@QAE@$$T@Z ENDP		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z PROC ; std::_Func_class<void>::_Set, COMDAT
; _this$ = ecx

; 510  : 		{	// store pointer to object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		_Impl = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 512  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ENDP ; std::_Func_class<void>::_Set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ PROC		; std::_Func_class<void>::_Reset, COMDAT
; _this$ = ecx

; 330  : 		{	// remove stored object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 		_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 332  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ ENDP		; std::_Func_class<void>::_Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\functional
;	COMDAT ??0?$_Func_class@X$$$V@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Func_class@X$$$V@std@@QAE@XZ PROC			; std::_Func_class<void>::_Func_class<void>, COMDAT
; _this$ = ecx

; 308  : 		{	// construct without stored object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 309  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Func_class@X$$$V@std@@QAE@XZ ENDP			; std::_Func_class<void>::_Func_class<void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 49   : 	_Ignore()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		{	// construct
; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -32						; size = 4
__Lock$2 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 214  : 	{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

	jmp	SHORT $LN3@Orphan_all
$LN2@Orphan_all:
	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$1[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN3@Orphan_all:
	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Orphan_all

; 222  : 			(*_Pnext)->_Myproxy = 0;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], 0

; 224  : 		}

	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN5@Orphan_all:

; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Orphan_all:
	DD	1
	DD	$LN9@Orphan_all
$LN9@Orphan_all:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@Orphan_all
$LN8@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 96   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 80   : 		{	// construct childless container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 69   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 65   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\swprintf.inl
;	COMDAT _swprintf
_TEXT	SEGMENT
__Ret$ = -20						; size = 4
__Arglist$ = -8						; size = 4
__String$ = 8						; size = 4
__Count$ = 12						; size = 4
__Format$ = 16						; size = 4
_swprintf PROC						; COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 38   :     va_list _Arglist;
; 39   :     int _Ret;
; 40   :     _crt_va_start(_Arglist, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __Arglist$[ebp], eax

; 41   :     _Ret = _vswprintf_c_l(_String, _Count, _Format, NULL, _Arglist);

	mov	eax, DWORD PTR __Arglist$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __String$[ebp]
	push	eax
	call	__vswprintf_c_l
	add	esp, 20					; 00000014H
	mov	DWORD PTR __Ret$[ebp], eax

; 42   :     _crt_va_end(_Arglist);

	mov	DWORD PTR __Arglist$[ebp], 0

; 43   :     return _Ret;

	mov	eax, DWORD PTR __Ret$[ebp]

; 44   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_swprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMReciprocalTwoPi@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMReciprocalTwoPi@DirectX@@YAXXZ PROC		; DirectX::`dynamic initializer for 'g_XMReciprocalTwoPi'', COMDAT

; 1736 : XMGLOBALCONST XMVECTORF32 g_XMReciprocalTwoPi   = {XM_1DIV2PI, XM_1DIV2PI, XM_1DIV2PI, XM_1DIV2PI};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_1DIV2PI
	movss	DWORD PTR ?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B, xmm0
	movss	xmm0, DWORD PTR _XM_1DIV2PI
	movss	DWORD PTR ?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B+4, xmm0
	movss	xmm0, DWORD PTR _XM_1DIV2PI
	movss	DWORD PTR ?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B+8, xmm0
	movss	xmm0, DWORD PTR _XM_1DIV2PI
	movss	DWORD PTR ?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMReciprocalTwoPi@DirectX@@YAXXZ ENDP		; DirectX::`dynamic initializer for 'g_XMReciprocalTwoPi''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMTwoPi@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMTwoPi@DirectX@@YAXXZ PROC			; DirectX::`dynamic initializer for 'g_XMTwoPi'', COMDAT

; 1735 : XMGLOBALCONST XMVECTORF32 g_XMTwoPi             = {XM_2PI, XM_2PI, XM_2PI, XM_2PI};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_2PI
	movss	DWORD PTR ?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B, xmm0
	movss	xmm0, DWORD PTR _XM_2PI
	movss	DWORD PTR ?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B+4, xmm0
	movss	xmm0, DWORD PTR _XM_2PI
	movss	DWORD PTR ?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B+8, xmm0
	movss	xmm0, DWORD PTR _XM_2PI
	movss	DWORD PTR ?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMTwoPi@DirectX@@YAXXZ ENDP			; DirectX::`dynamic initializer for 'g_XMTwoPi''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMReciprocalPi@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMReciprocalPi@DirectX@@YAXXZ PROC		; DirectX::`dynamic initializer for 'g_XMReciprocalPi'', COMDAT

; 1734 : XMGLOBALCONST XMVECTORF32 g_XMReciprocalPi      = {XM_1DIVPI, XM_1DIVPI, XM_1DIVPI, XM_1DIVPI};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_1DIVPI
	movss	DWORD PTR ?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B, xmm0
	movss	xmm0, DWORD PTR _XM_1DIVPI
	movss	DWORD PTR ?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B+4, xmm0
	movss	xmm0, DWORD PTR _XM_1DIVPI
	movss	DWORD PTR ?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B+8, xmm0
	movss	xmm0, DWORD PTR _XM_1DIVPI
	movss	DWORD PTR ?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMReciprocalPi@DirectX@@YAXXZ ENDP		; DirectX::`dynamic initializer for 'g_XMReciprocalPi''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMPi@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMPi@DirectX@@YAXXZ PROC				; DirectX::`dynamic initializer for 'g_XMPi'', COMDAT

; 1733 : XMGLOBALCONST XMVECTORF32 g_XMPi                = {XM_PI, XM_PI, XM_PI, XM_PI};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_PI
	movss	DWORD PTR ?g_XMPi@DirectX@@3UXMVECTORF32@1@B, xmm0
	movss	xmm0, DWORD PTR _XM_PI
	movss	DWORD PTR ?g_XMPi@DirectX@@3UXMVECTORF32@1@B+4, xmm0
	movss	xmm0, DWORD PTR _XM_PI
	movss	DWORD PTR ?g_XMPi@DirectX@@3UXMVECTORF32@1@B+8, xmm0
	movss	xmm0, DWORD PTR _XM_PI
	movss	DWORD PTR ?g_XMPi@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMPi@DirectX@@YAXXZ ENDP				; DirectX::`dynamic initializer for 'g_XMPi''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMHalfPi@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMHalfPi@DirectX@@YAXXZ PROC			; DirectX::`dynamic initializer for 'g_XMHalfPi'', COMDAT

; 1732 : XMGLOBALCONST XMVECTORF32 g_XMHalfPi            = {XM_PIDIV2, XM_PIDIV2, XM_PIDIV2, XM_PIDIV2};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_PIDIV2
	movss	DWORD PTR ?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B, xmm0
	movss	xmm0, DWORD PTR _XM_PIDIV2
	movss	DWORD PTR ?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B+4, xmm0
	movss	xmm0, DWORD PTR _XM_PIDIV2
	movss	DWORD PTR ?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B+8, xmm0
	movss	xmm0, DWORD PTR _XM_PIDIV2
	movss	DWORD PTR ?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMHalfPi@DirectX@@YAXXZ ENDP			; DirectX::`dynamic initializer for 'g_XMHalfPi''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMNegativePi@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMNegativePi@DirectX@@YAXXZ PROC			; DirectX::`dynamic initializer for 'g_XMNegativePi'', COMDAT

; 1731 : XMGLOBALCONST XMVECTORF32 g_XMNegativePi        = {-XM_PI, -XM_PI, -XM_PI, -XM_PI};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_PI
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B, xmm0
	movss	xmm0, DWORD PTR _XM_PI
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B+4, xmm0
	movss	xmm0, DWORD PTR _XM_PI
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B+8, xmm0
	movss	xmm0, DWORD PTR _XM_PI
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMNegativePi@DirectX@@YAXXZ ENDP			; DirectX::`dynamic initializer for 'g_XMNegativePi''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMNegativeTwoPi@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMNegativeTwoPi@DirectX@@YAXXZ PROC		; DirectX::`dynamic initializer for 'g_XMNegativeTwoPi'', COMDAT

; 1730 : XMGLOBALCONST XMVECTORF32 g_XMNegativeTwoPi     = {-XM_2PI, -XM_2PI, -XM_2PI, -XM_2PI};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_2PI
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B, xmm0
	movss	xmm0, DWORD PTR _XM_2PI
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B+4, xmm0
	movss	xmm0, DWORD PTR _XM_2PI
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B+8, xmm0
	movss	xmm0, DWORD PTR _XM_2PI
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMNegativeTwoPi@DirectX@@YAXXZ ENDP		; DirectX::`dynamic initializer for 'g_XMNegativeTwoPi''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMPiConstants0@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMPiConstants0@DirectX@@YAXXZ PROC		; DirectX::`dynamic initializer for 'g_XMPiConstants0'', COMDAT

; 1705 : XMGLOBALCONST XMVECTORF32 g_XMPiConstants0        = {XM_PI, XM_2PI, XM_1DIVPI, XM_1DIV2PI};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_PI
	movss	DWORD PTR ?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B, xmm0
	movss	xmm0, DWORD PTR _XM_2PI
	movss	DWORD PTR ?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B+4, xmm0
	movss	xmm0, DWORD PTR _XM_1DIVPI
	movss	DWORD PTR ?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B+8, xmm0
	movss	xmm0, DWORD PTR _XM_1DIV2PI
	movss	DWORD PTR ?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMPiConstants0@DirectX@@YAXXZ ENDP		; DirectX::`dynamic initializer for 'g_XMPiConstants0''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??__Eg_XMTanEstCoefficients@DirectX@@YAXXZ
text$di	SEGMENT
??__Eg_XMTanEstCoefficients@DirectX@@YAXXZ PROC		; DirectX::`dynamic initializer for 'g_XMTanEstCoefficients'', COMDAT

; 1703 : XMGLOBALCONST XMVECTORF32 g_XMTanEstCoefficients  = {2.484f, -1.954923183e-1f, 2.467401101f, XM_1DIVPI};

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movss	xmm0, DWORD PTR _XM_1DIVPI
	movss	DWORD PTR ?g_XMTanEstCoefficients@DirectX@@3UXMVECTORF32@1@B+12, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_XMTanEstCoefficients@DirectX@@YAXXZ ENDP		; DirectX::`dynamic initializer for 'g_XMTanEstCoefficients''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmathvector.inl
;	COMDAT ?XMVectorSet@DirectX@@YQ?AT__m128@@MMMM@Z
_TEXT	SEGMENT
$T1 = -272						; size = 16
_w$ = -44						; size = 4
_z$ = -32						; size = 4
_y$ = -20						; size = 4
_x$ = -8						; size = 4
?XMVectorSet@DirectX@@YQ?AT__m128@@MMMM@Z PROC		; DirectX::XMVectorSet, COMDAT
; _x$ = xmm0s
; _y$ = xmm1s
; _z$ = xmm2s
; _w$ = xmm3s

; 72   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	movss	DWORD PTR _w$[ebp], xmm3
	movss	DWORD PTR _z$[ebp], xmm2
	movss	DWORD PTR _y$[ebp], xmm1
	movss	DWORD PTR _x$[ebp], xmm0

; 73   : #if defined(_XM_NO_INTRINSICS_)
; 74   :     XMVECTORF32 vResult = {x,y,z,w};
; 75   :     return vResult.v;
; 76   : #elif defined(_XM_ARM_NEON_INTRINSICS_)
; 77   :     float32x2_t V0 = vcreate_f32(((uint64_t)*(const uint32_t *)&x) | ((uint64_t)(*(const uint32_t *)&y) << 32));
; 78   :     float32x2_t V1 = vcreate_f32(((uint64_t)*(const uint32_t *)&z) | ((uint64_t)(*(const uint32_t *)&w) << 32));
; 79   :     return vcombine_f32(V0, V1);
; 80   : #elif defined(_XM_SSE_INTRINSICS_)
; 81   :     return _mm_set_ps( w, z, y, x );

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _y$[ebp]
	movss	xmm2, DWORD PTR _z$[ebp]
	movss	xmm3, DWORD PTR _w$[ebp]
	unpcklps xmm0, xmm2
	unpcklps xmm1, xmm3
	unpcklps xmm0, xmm1
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]

; 82   : #else // _XM_VMX128_INTRINSICS_
; 83   : #endif // _XM_VMX128_INTRINSICS_
; 84   : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?XMVectorSet@DirectX@@YQ?AT__m128@@MMMM@Z ENDP		; DirectX::XMVectorSet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmathconvert.inl
;	COMDAT ?XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@1@T__m128@@@Z
_TEXT	SEGMENT
_V$ = -32						; size = 16
_pDestination$ = -8					; size = 4
?XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@1@T__m128@@@Z PROC ; DirectX::XMStoreFloat4, COMDAT
; _pDestination$ = ecx
; _V$ = xmm0

; 1585 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	movaps	XMMWORD PTR _V$[ebp], xmm0
	mov	DWORD PTR _pDestination$[ebp], ecx

; 1586 :     assert(pDestination);

	cmp	DWORD PTR _pDestination$[ebp], 0
	jne	SHORT $LN3@XMStoreFlo
	mov	eax, DWORD PTR ?__LINE__Var@?1??XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@2@T__m128@@@Z@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1JE@DMOBBMDE@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?5?$AAk@
	push	OFFSET ??_C@_1BK@FHLBGAOP@?$AAp?$AAD?$AAe?$AAs?$AAt?$AAi?$AAn?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@XMStoreFlo:

; 1587 : #if defined(_XM_NO_INTRINSICS_)
; 1588 :     pDestination->x = V.vector4_f32[0];
; 1589 :     pDestination->y = V.vector4_f32[1];
; 1590 :     pDestination->z = V.vector4_f32[2];
; 1591 :     pDestination->w = V.vector4_f32[3];
; 1592 : #elif defined(_XM_ARM_NEON_INTRINSICS_)
; 1593 :     vst1q_f32( reinterpret_cast<float*>(pDestination), V );
; 1594 : #elif defined(_XM_SSE_INTRINSICS_)
; 1595 :     _mm_storeu_ps( &pDestination->x, V );

	movups	xmm0, XMMWORD PTR _V$[ebp]
	mov	eax, DWORD PTR _pDestination$[ebp]
	movups	XMMWORD PTR [eax], xmm0

; 1596 : #else // _XM_VMX128_INTRINSICS_
; 1597 : #endif // _XM_VMX128_INTRINSICS_
; 1598 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?XMStoreFloat4@DirectX@@YQXPAUXMFLOAT4@1@T__m128@@@Z ENDP ; DirectX::XMStoreFloat4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??4XMFLOAT4@DirectX@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_Float4$ = 8						; size = 4
??4XMFLOAT4@DirectX@@QAEAAU01@ABU01@@Z PROC		; DirectX::XMFLOAT4::operator=, COMDAT
; _this$ = ecx

; 582  :     XMFLOAT4& operator= (const XMFLOAT4& Float4) { x = Float4.x; y = Float4.y; z = Float4.z; w = Float4.w; return *this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Float4$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Float4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Float4$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Float4$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4XMFLOAT4@DirectX@@QAEAAU01@ABU01@@Z ENDP		; DirectX::XMFLOAT4::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??0XMFLOAT4@DirectX@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
??0XMFLOAT4@DirectX@@QAE@MMMM@Z PROC			; DirectX::XMFLOAT4::XMFLOAT4, COMDAT
; _this$ = ecx

; 579  :     XMFLOAT4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __x$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __z$[ebp]
	movss	DWORD PTR [eax+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __w$[ebp]
	movss	DWORD PTR [eax+12], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0XMFLOAT4@DirectX@@QAE@MMMM@Z ENDP			; DirectX::XMFLOAT4::XMFLOAT4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??0XMFLOAT4@DirectX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0XMFLOAT4@DirectX@@QAE@XZ PROC			; DirectX::XMFLOAT4::XMFLOAT4, COMDAT
; _this$ = ecx

; 578  :     XMFLOAT4() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0XMFLOAT4@DirectX@@QAE@XZ ENDP			; DirectX::XMFLOAT4::XMFLOAT4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_Float3$ = 8						; size = 4
??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z PROC		; DirectX::XMFLOAT3::operator=, COMDAT
; _this$ = ecx

; 527  :     XMFLOAT3& operator= (const XMFLOAT3& Float3) { x = Float3.x; y = Float3.y; z = Float3.z; return *this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Float3$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Float3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Float3$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4XMFLOAT3@DirectX@@QAEAAU01@ABU01@@Z ENDP		; DirectX::XMFLOAT3::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??0XMFLOAT3@DirectX@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0XMFLOAT3@DirectX@@QAE@MMM@Z PROC			; DirectX::XMFLOAT3::XMFLOAT3, COMDAT
; _this$ = ecx

; 524  :     XMFLOAT3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __x$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __z$[ebp]
	movss	DWORD PTR [eax+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0XMFLOAT3@DirectX@@QAE@MMM@Z ENDP			; DirectX::XMFLOAT3::XMFLOAT3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??0XMFLOAT3@DirectX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0XMFLOAT3@DirectX@@QAE@XZ PROC			; DirectX::XMFLOAT3::XMFLOAT3, COMDAT
; _this$ = ecx

; 523  :     XMFLOAT3() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0XMFLOAT3@DirectX@@QAE@XZ ENDP			; DirectX::XMFLOAT3::XMFLOAT3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??0XMFLOAT2@DirectX@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0XMFLOAT2@DirectX@@QAE@MM@Z PROC			; DirectX::XMFLOAT2::XMFLOAT2, COMDAT
; _this$ = ecx

; 472  :     XMFLOAT2(float _x, float _y) : x(_x), y(_y) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __x$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0XMFLOAT2@DirectX@@QAE@MM@Z ENDP			; DirectX::XMFLOAT2::XMFLOAT2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??0XMFLOAT2@DirectX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0XMFLOAT2@DirectX@@QAE@XZ PROC			; DirectX::XMFLOAT2::XMFLOAT2, COMDAT
; _this$ = ecx

; 471  :     XMFLOAT2() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0XMFLOAT2@DirectX@@QAE@XZ ENDP			; DirectX::XMFLOAT2::XMFLOAT2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??4XMMATRIX@DirectX@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_M$ = 8							; size = 4
??4XMMATRIX@DirectX@@QAEAAU01@ABU01@@Z PROC		; DirectX::XMMATRIX::operator=, COMDAT
; _this$ = ecx

; 444  :     XMMATRIX&   operator= (const XMMATRIX& M) { r[0] = M.r[0]; r[1] = M.r[1]; r[2] = M.r[2]; r[3] = M.r[3]; return *this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _M$[ebp]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _this$[ebp]
	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _M$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _M$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _M$[ebp]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	add	eax, DWORD PTR _this$[ebp]
	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4XMMATRIX@DirectX@@QAEAAU01@ABU01@@Z ENDP		; DirectX::XMMATRIX::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??0XMMATRIX@DirectX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0XMMATRIX@DirectX@@QAE@XZ PROC			; DirectX::XMMATRIX::XMMATRIX, COMDAT
; _this$ = ecx

; 431  :     XMMATRIX() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0XMMATRIX@DirectX@@QAE@XZ ENDP			; DirectX::XMMATRIX::XMMATRIX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\um\directxmath.h
;	COMDAT ??BXMVECTORF32@DirectX@@QBE?AT__m128@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
??BXMVECTORF32@DirectX@@QBE?AT__m128@@XZ PROC		; DirectX::XMVECTORF32::operator __m128, COMDAT
; _this$ = ecx

; 314  :     inline operator XMVECTOR() const { return v; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??BXMVECTORF32@DirectX@@QBE?AT__m128@@XZ ENDP		; DirectX::XMVECTORF32::operator __m128
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 557  :     return _hypot(_X, _Y);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Y$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	__hypot
	add	esp, 16					; 00000010H

; 558  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_hypot	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
tv68 = -196						; size = 4
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _x$[ebp], 0
	jg	SHORT $LN3@HRESULT_FR
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@HRESULT_FR
$LN3@HRESULT_FR:
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv68[ebp], ecx
$LN4@HRESULT_FR:
	mov	eax, DWORD PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	esi, esp
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
