; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Users\Simon\Documents\GitHub\UCLAN-sparta\Dissertation Project\CTimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??0CTimer@@QAE@XZ				; CTimer::CTimer
PUBLIC	?Start@CTimer@@QAEXXZ				; CTimer::Start
PUBLIC	?Stop@CTimer@@QAEXXZ				; CTimer::Stop
PUBLIC	?Reset@CTimer@@QAEXXZ				; CTimer::Reset
PUBLIC	?GetFrequency@CTimer@@QAEMXZ			; CTimer::GetFrequency
PUBLIC	?GetTime@CTimer@@QAEMXZ				; CTimer::GetTime
PUBLIC	?GetLapTime@CTimer@@QAEMXZ			; CTimer::GetLapTime
PUBLIC	__real@447a0000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\ctimer.cpp
;	COMDAT ?GetLapTime@CTimer@@QAEMXZ
_TEXT	SEGMENT
tv155 = -304						; size = 8
tv152 = -296						; size = 8
tv149 = -288						; size = 8
tv146 = -280						; size = 8
tv172 = -276						; size = 8
tv143 = -272						; size = 8
tv169 = -268						; size = 4
_newLowResTime$1 = -68					; size = 4
_dTime$2 = -56						; size = 8
_newHighResTime$3 = -40					; size = 8
_fTime$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?GetLapTime@CTimer@@QAEMXZ PROC				; CTimer::GetLapTime, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 	float fTime;
; 149  : 	if (m_HighRes)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	$LN6@GetLapTime

; 150  : 	{
; 151  : 		LARGE_INTEGER newHighResTime;
; 152  : 		if (m_Running)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@GetLapTime

; 153  : 		{
; 154  : 			QueryPerformanceCounter( &newHighResTime );

	mov	esi, esp
	lea	eax, DWORD PTR _newHighResTime$3[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 155  : 		}
; 156  : 		else

	jmp	SHORT $LN4@GetLapTime
$LN5@GetLapTime:

; 157  : 		{
; 158  : 			newHighResTime = m_HighResStop;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _newHighResTime$3[ebp], ecx
	mov	DWORD PTR _newHighResTime$3[ebp+4], edx
$LN4@GetLapTime:

; 159  : 		}
; 160  : 		double dTime = static_cast<double>(newHighResTime.QuadPart - m_HighResLap.QuadPart) /
; 161  : 			           static_cast<double>(m_HighResFreq.QuadPart);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newHighResTime$3[ebp]
	sub	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _newHighResTime$3[ebp+4]
	sbb	edx, DWORD PTR [eax+28]
	mov	DWORD PTR tv143[ebp], ecx
	mov	DWORD PTR tv143[ebp+4], edx
	fild	QWORD PTR tv143[ebp]
	fstp	QWORD PTR tv146[ebp]
	fld	QWORD PTR tv146[ebp]
	fstp	QWORD PTR tv149[ebp]
	movsd	xmm0, QWORD PTR tv149[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fild	QWORD PTR [eax+8]
	fstp	QWORD PTR tv152[ebp]
	fld	QWORD PTR tv152[ebp]
	fstp	QWORD PTR tv155[ebp]
	divsd	xmm0, QWORD PTR tv155[ebp]
	movsd	QWORD PTR _dTime$2[ebp], xmm0

; 162  : 		fTime = static_cast<float>(dTime);

	cvtsd2ss xmm0, QWORD PTR _dTime$2[ebp]
	movss	DWORD PTR _fTime$[ebp], xmm0

; 163  : 		m_HighResLap = newHighResTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newHighResTime$3[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _newHighResTime$3[ebp+4]
	mov	DWORD PTR [eax+28], edx

; 164  : 	}
; 165  : 	else

	jmp	SHORT $LN3@GetLapTime
$LN6@GetLapTime:

; 166  : 	{
; 167  : 		DWORD newLowResTime;
; 168  : 		if (m_Running)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@GetLapTime

; 169  : 		{
; 170  : 			newLowResTime = timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _newLowResTime$1[ebp], eax

; 171  : 		}
; 172  : 		else

	jmp	SHORT $LN1@GetLapTime
$LN2@GetLapTime:

; 173  : 		{
; 174  : 			newLowResTime = m_LowResStop;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _newLowResTime$1[ebp], ecx
$LN1@GetLapTime:

; 175  : 		}
; 176  : 		fTime = static_cast<float>(newLowResTime - m_LowResLap) / 1000.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newLowResTime$1[ebp]
	sub	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR tv169[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv169[ebp]
	mov	edx, DWORD PTR tv169[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv172[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv172[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fTime$[ebp], xmm0

; 177  : 		m_LowResLap = newLowResTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newLowResTime$1[ebp]
	mov	DWORD PTR [eax+44], ecx
$LN3@GetLapTime:

; 178  : 	}
; 179  : 	return fTime;

	fld	DWORD PTR _fTime$[ebp]

; 180  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@GetLapTime
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@GetLapTime:
	DD	1
	DD	$LN10@GetLapTime
$LN10@GetLapTime:
	DD	-40					; ffffffd8H
	DD	8
	DD	$LN9@GetLapTime
$LN9@GetLapTime:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?GetLapTime@CTimer@@QAEMXZ ENDP				; CTimer::GetLapTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\ctimer.cpp
;	COMDAT ?GetTime@CTimer@@QAEMXZ
_TEXT	SEGMENT
tv153 = -304						; size = 8
tv150 = -296						; size = 8
tv147 = -288						; size = 8
tv144 = -280						; size = 8
tv166 = -276						; size = 8
tv141 = -272						; size = 8
tv163 = -268						; size = 4
_newLowResTime$1 = -68					; size = 4
_dTime$2 = -56						; size = 8
_newHighResTime$3 = -40					; size = 8
_fTime$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?GetTime@CTimer@@QAEMXZ PROC				; CTimer::GetTime, COMDAT
; _this$ = ecx

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 	float fTime;
; 111  : 	if (m_HighRes)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	$LN6@GetTime

; 112  : 	{
; 113  : 
; 114  : 		LARGE_INTEGER newHighResTime;
; 115  : 		if (m_Running)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@GetTime

; 116  : 		{
; 117  : 			QueryPerformanceCounter( &newHighResTime );

	mov	esi, esp
	lea	eax, DWORD PTR _newHighResTime$3[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 118  : 		}
; 119  : 		else

	jmp	SHORT $LN4@GetTime
$LN5@GetTime:

; 120  : 		{
; 121  : 			newHighResTime = m_HighResStop;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _newHighResTime$3[ebp], ecx
	mov	DWORD PTR _newHighResTime$3[ebp+4], edx
$LN4@GetTime:

; 122  : 		}
; 123  : 		double dTime = static_cast<double>(newHighResTime.QuadPart - m_HighResStart.QuadPart) /
; 124  : 			           static_cast<double>(m_HighResFreq.QuadPart);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newHighResTime$3[ebp]
	sub	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _newHighResTime$3[ebp+4]
	sbb	edx, DWORD PTR [eax+20]
	mov	DWORD PTR tv141[ebp], ecx
	mov	DWORD PTR tv141[ebp+4], edx
	fild	QWORD PTR tv141[ebp]
	fstp	QWORD PTR tv144[ebp]
	fld	QWORD PTR tv144[ebp]
	fstp	QWORD PTR tv147[ebp]
	movsd	xmm0, QWORD PTR tv147[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fild	QWORD PTR [eax+8]
	fstp	QWORD PTR tv150[ebp]
	fld	QWORD PTR tv150[ebp]
	fstp	QWORD PTR tv153[ebp]
	divsd	xmm0, QWORD PTR tv153[ebp]
	movsd	QWORD PTR _dTime$2[ebp], xmm0

; 125  : 		fTime = static_cast<float>(dTime);

	cvtsd2ss xmm0, QWORD PTR _dTime$2[ebp]
	movss	DWORD PTR _fTime$[ebp], xmm0

; 126  : 	}
; 127  : 	else

	jmp	SHORT $LN3@GetTime
$LN6@GetTime:

; 128  : 	{
; 129  : 		DWORD newLowResTime;
; 130  : 		if (m_Running)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@GetTime

; 131  : 		{
; 132  : 			newLowResTime = timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _newLowResTime$1[ebp], eax

; 133  : 		}
; 134  : 		else

	jmp	SHORT $LN1@GetTime
$LN2@GetTime:

; 135  : 		{
; 136  : 			newLowResTime = m_LowResStop;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _newLowResTime$1[ebp], ecx
$LN1@GetTime:

; 137  : 		}
; 138  : 		fTime = static_cast<float>(newLowResTime - m_LowResStart) / 1000.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newLowResTime$1[ebp]
	sub	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR tv163[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv163[ebp]
	mov	edx, DWORD PTR tv163[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv166[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv166[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fTime$[ebp], xmm0
$LN3@GetTime:

; 139  : 	}
; 140  : 
; 141  : 	return fTime;

	fld	DWORD PTR _fTime$[ebp]

; 142  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@GetTime
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@GetTime:
	DD	1
	DD	$LN10@GetTime
$LN10@GetTime:
	DD	-40					; ffffffd8H
	DD	8
	DD	$LN9@GetTime
$LN9@GetTime:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?GetTime@CTimer@@QAEMXZ ENDP				; CTimer::GetTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\ctimer.cpp
;	COMDAT ?GetFrequency@CTimer@@QAEMXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?GetFrequency@CTimer@@QAEMXZ PROC			; CTimer::GetFrequency, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	// Select high or low-resolution timer
; 97   : 	if (m_HighRes)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN2@GetFrequen

; 98   : 	{
; 99   : 		return static_cast<float>(m_HighResFreq.QuadPart);

	mov	eax, DWORD PTR _this$[ebp]
	fild	QWORD PTR [eax+8]
	fstp	DWORD PTR tv72[ebp]
	fld	DWORD PTR tv72[ebp]
	jmp	SHORT $LN1@GetFrequen

; 100  : 	}
; 101  : 	else

	jmp	SHORT $LN1@GetFrequen
$LN2@GetFrequen:

; 102  : 	{
; 103  : 		return 1000.0f;

	fld	DWORD PTR __real@447a0000
$LN1@GetFrequen:

; 104  : 	}
; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrequency@CTimer@@QAEMXZ ENDP			; CTimer::GetFrequency
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\ctimer.cpp
;	COMDAT ?Reset@CTimer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Reset@CTimer@@QAEXXZ PROC				; CTimer::Reset, COMDAT
; _this$ = ecx

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 	// Reset start, lap and stop times to current time
; 74   : 	// Select high or low-resolution timer
; 75   : 	if (m_HighRes)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN2@Reset

; 76   : 	{
; 77   : 		QueryPerformanceCounter( &m_HighResStart );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 78   : 		m_HighResLap = m_HighResStart;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], edx

; 79   : 		m_HighResStop = m_HighResStart;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], edx

; 80   : 	}
; 81   : 	else

	jmp	SHORT $LN3@Reset
$LN2@Reset:

; 82   : 	{
; 83   : 		m_LowResStart = timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 84   : 		m_LowResLap = m_LowResStart;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+44], edx

; 85   : 		m_LowResStop = m_LowResStart;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+48], edx
$LN3@Reset:

; 86   : 	}
; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CTimer@@QAEXXZ ENDP				; CTimer::Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\ctimer.cpp
;	COMDAT ?Stop@CTimer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Stop@CTimer@@QAEXXZ PROC				; CTimer::Stop, COMDAT
; _this$ = ecx

; 55   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 	m_Running = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 57   : 
; 58   : 	// Get stop time
; 59   : 	// Select high or low-resolution timer
; 60   : 	if (m_HighRes)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN2@Stop

; 61   : 	{
; 62   : 		QueryPerformanceCounter( &m_HighResStop );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 63   : 	}
; 64   : 	else

	jmp	SHORT $LN3@Stop
$LN2@Stop:

; 65   : 	{
; 66   : 		m_LowResStop = timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN3@Stop:

; 67   : 	}
; 68   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CTimer@@QAEXXZ ENDP				; CTimer::Stop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\ctimer.cpp
;	COMDAT ?Start@CTimer@@QAEXXZ
_TEXT	SEGMENT
_newLowResTime$1 = -40					; size = 4
_newHighResTime$2 = -28					; size = 8
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Start@CTimer@@QAEXXZ PROC				; CTimer::Start, COMDAT
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 30   : 	if (!m_Running)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN4@Start

; 31   : 	{
; 32   : 		m_Running = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1

; 33   : 
; 34   : 		// Get restart time - add time passed since stop time to the start and lap times
; 35   : 		// Select high or low-resolution timer
; 36   : 		if (m_HighRes)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN2@Start

; 37   : 		{
; 38   : 			LARGE_INTEGER newHighResTime;
; 39   : 			QueryPerformanceCounter( &newHighResTime );

	mov	esi, esp
	lea	eax, DWORD PTR _newHighResTime$2[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 40   : 			m_HighResStart.QuadPart += (newHighResTime.QuadPart - m_HighResStop.QuadPart);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newHighResTime$2[ebp]
	sub	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _newHighResTime$2[ebp+4]
	sbb	edx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+16]
	adc	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx

; 41   : 			m_HighResLap.QuadPart += (newHighResTime.QuadPart - m_HighResStop.QuadPart);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newHighResTime$2[ebp]
	sub	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _newHighResTime$2[ebp+4]
	sbb	edx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+24]
	adc	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], edx

; 42   : 		}
; 43   : 		else

	jmp	SHORT $LN4@Start
$LN2@Start:

; 44   : 		{
; 45   : 			DWORD newLowResTime;
; 46   : 			newLowResTime = timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _newLowResTime$1[ebp], eax

; 47   : 			m_LowResStart += (newLowResTime - m_LowResStop);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newLowResTime$1[ebp]
	sub	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 48   : 			m_LowResLap += (newLowResTime - m_LowResStop);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newLowResTime$1[ebp]
	sub	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], ecx
$LN4@Start:

; 49   : 		}
; 50   : 	}
; 51   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Start
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@Start:
	DD	1
	DD	$LN7@Start
$LN7@Start:
	DD	-28					; ffffffe4H
	DD	8
	DD	$LN6@Start
$LN6@Start:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?Start@CTimer@@QAEXXZ ENDP				; CTimer::Start
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\ctimer.cpp
;	COMDAT ??0CTimer@@QAE@XZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
??0CTimer@@QAE@XZ PROC					; CTimer::CTimer, COMDAT
; _this$ = ecx

; 14   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 15   : 	// Try to initialise performance timer, will use low-resolution timer on failure
; 16   : 	m_HighRes = (QueryPerformanceFrequency( &m_HighResFreq ) != 0);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@CTimer
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@CTimer
$LN3@CTimer:
	mov	DWORD PTR tv69[ebp], 0
$LN4@CTimer:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv69[ebp]
	mov	BYTE PTR [ecx+1], dl

; 17   : 
; 18   : 	// Reset and start the timer
; 19   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CTimer@@QAEXXZ			; CTimer::Reset

; 20   : 	m_Running = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1

; 21   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CTimer@@QAE@XZ ENDP					; CTimer::CTimer
_TEXT	ENDS
END
