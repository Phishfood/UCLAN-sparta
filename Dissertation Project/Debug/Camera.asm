; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Users\Simon\Documents\GitHub\UCLAN-sparta\Dissertation Project\Camera.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?mViewportWidth@CCamera@@0HA			; CCamera::mViewportWidth
PUBLIC	?mViewportHeight@CCamera@@0HA			; CCamera::mViewportHeight
_BSS	SEGMENT
?mViewportWidth@CCamera@@0HA DD 01H DUP (?)		; CCamera::mViewportWidth
?mViewportHeight@CCamera@@0HA DD 01H DUP (?)		; CCamera::mViewportHeight
_BSS	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z			; D3DXMATRIX::operator*
PUBLIC	??0_D3DXMATRIXA16@@QAE@XZ			; _D3DXMATRIXA16::_D3DXMATRIXA16
PUBLIC	??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z	; _D3DXMATRIXA16::operator=
PUBLIC	??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z		; CCamera::CCamera
PUBLIC	?SetFOV@CCamera@@QAEXM@Z			; CCamera::SetFOV
PUBLIC	?SetNearClip@CCamera@@QAEXM@Z			; CCamera::SetNearClip
PUBLIC	?SetFarClip@CCamera@@QAEXM@Z			; CCamera::SetFarClip
PUBLIC	?UpdateMatrices@CCamera@@QAEXXZ			; CCamera::UpdateMatrices
PUBLIC	?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z	; CCamera::Control
PUBLIC	__real@40000000
PUBLIC	__real@42480000
EXTRN	_memcpy:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixInverse@12:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	_D3DXMatrixRotationX@8:PROC
EXTRN	_D3DXMatrixRotationY@8:PROC
EXTRN	_D3DXMatrixRotationZ@8:PROC
EXTRN	_D3DXMatrixPerspectiveFovLH@20:PROC
EXTRN	?KeyHeld@@YA_NW4EKeyCode@@@Z:PROC		; KeyHeld
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\camera.cpp
;	COMDAT ?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_frameTime$ = 8						; size = 4
_turnUp$ = 12						; size = 4
_turnDown$ = 16						; size = 4
_turnLeft$ = 20						; size = 4
_turnRight$ = 24					; size = 4
_moveForward$ = 28					; size = 4
_moveBackward$ = 32					; size = 4
_moveLeft$ = 36						; size = 4
_moveRight$ = 40					; size = 4
?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z PROC	; CCamera::Control, COMDAT
; _this$ = ecx

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 	if (KeyHeld( turnDown ))

	mov	eax, DWORD PTR _turnDown$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@Control

; 64   : 	{
; 65   : 		m_Rotation.x += RotSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+20], xmm0
$LN8@Control:

; 66   : 	}
; 67   : 	if (KeyHeld( turnUp ))

	mov	eax, DWORD PTR _turnUp$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@Control

; 68   : 	{
; 69   : 		m_Rotation.x -= RotSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+20]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+20], xmm1
$LN7@Control:

; 70   : 	}
; 71   : 	if (KeyHeld( turnRight ))

	mov	eax, DWORD PTR _turnRight$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@Control

; 72   : 	{
; 73   : 		m_Rotation.y += RotSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+24], xmm0
$LN6@Control:

; 74   : 	}
; 75   : 	if (KeyHeld( turnLeft ))

	mov	eax, DWORD PTR _turnLeft$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Control

; 76   : 	{
; 77   : 		m_Rotation.y -= RotSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+24]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+24], xmm1
$LN5@Control:

; 78   : 	}
; 79   : 
; 80   : 	// Local X movement - move in the direction of the X axis, get axis from camera's "world" matrix
; 81   : 	if (KeyHeld( moveRight ))

	mov	eax, DWORD PTR _moveRight$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Control

; 82   : 	{
; 83   : 		m_Position.x += m_WorldMatrix._11 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 84   : 		m_Position.y += m_WorldMatrix._12 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 85   : 		m_Position.z += m_WorldMatrix._13 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+16], xmm0
$LN4@Control:

; 86   : 	}
; 87   : 	if (KeyHeld( moveLeft ))

	mov	eax, DWORD PTR _moveLeft$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Control

; 88   : 	{
; 89   : 		m_Position.x -= m_WorldMatrix._11 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+8], xmm1

; 90   : 		m_Position.y -= m_WorldMatrix._12 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+12]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+12], xmm1

; 91   : 		m_Position.z -= m_WorldMatrix._13 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+16]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+16], xmm1
$LN3@Control:

; 92   : 	}
; 93   : 
; 94   : 	// Local Z movement - move in the direction of the Z axis, get axis from view matrix
; 95   : 	if (KeyHeld( moveForward ))

	mov	eax, DWORD PTR _moveForward$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Control

; 96   : 	{
; 97   : 		m_Position.x += m_WorldMatrix._31 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+80]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 98   : 		m_Position.y += m_WorldMatrix._32 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 99   : 		m_Position.z += m_WorldMatrix._33 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+16], xmm0
$LN2@Control:

; 100  : 	}
; 101  : 	if (KeyHeld( moveBackward ))

	mov	eax, DWORD PTR _moveBackward$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Control

; 102  : 	{
; 103  : 		m_Position.x -= m_WorldMatrix._31 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+80]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+8], xmm1

; 104  : 		m_Position.y -= m_WorldMatrix._32 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+12]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+12], xmm1

; 105  : 		m_Position.z -= m_WorldMatrix._33 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+16]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+16], xmm1
$LN1@Control:

; 106  : 	}
; 107  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z ENDP	; CCamera::Control
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\camera.cpp
;	COMDAT ?UpdateMatrices@CCamera@@QAEXXZ
_TEXT	SEGMENT
$T1 = -832						; size = 64
$T2 = -760						; size = 64
$T3 = -688						; size = 64
$T4 = -616						; size = 64
_aspect$ = -348						; size = 4
_matrixTranslation$ = -336				; size = 64
_matrixZRot$ = -256					; size = 64
_matrixYRot$ = -176					; size = 64
_matrixXRot$ = -96					; size = 64
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?UpdateMatrices@CCamera@@QAEXXZ PROC			; CCamera::UpdateMatrices, COMDAT
; _this$ = ecx

; 37   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 840				; 00000348H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-840]
	mov	ecx, 210				; 000000d2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	// Make matrices for position and rotations, then multiply together to get a "camera world matrix"
; 39   : 	D3DXMATRIXA16 matrixXRot, matrixYRot, matrixZRot, matrixTranslation;

	lea	ecx, DWORD PTR _matrixXRot$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	lea	ecx, DWORD PTR _matrixYRot$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	lea	ecx, DWORD PTR _matrixZRot$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	lea	ecx, DWORD PTR _matrixTranslation$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16

; 40   : 	D3DXMatrixRotationX( &matrixXRot, m_Rotation.x );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+20]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _matrixXRot$[ebp]
	push	ecx
	call	_D3DXMatrixRotationX@8

; 41   : 	D3DXMatrixRotationY( &matrixYRot, m_Rotation.y );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _matrixYRot$[ebp]
	push	ecx
	call	_D3DXMatrixRotationY@8

; 42   : 	D3DXMatrixRotationZ( &matrixZRot, m_Rotation.z );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _matrixZRot$[ebp]
	push	ecx
	call	_D3DXMatrixRotationZ@8

; 43   : 	D3DXMatrixTranslation( &matrixTranslation, m_Position.x, m_Position.y, m_Position.z);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+8]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _matrixTranslation$[ebp]
	push	eax
	call	_D3DXMatrixTranslation@16

; 44   : 	m_WorldMatrix = matrixZRot * matrixXRot * matrixYRot * matrixTranslation;

	lea	eax, DWORD PTR _matrixTranslation$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrixYRot$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrixXRot$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _matrixZRot$[ebp]
	call	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z		; D3DXMATRIX::operator*
	mov	ecx, eax
	call	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z		; D3DXMATRIX::operator*
	mov	ecx, eax
	call	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z		; D3DXMATRIX::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z ; _D3DXMATRIXA16::operator=

; 45   : 
; 46   : 	// The rendering pipeline actually needs the inverse of the camera world matrix - called the view matrix. Creating an inverse is easy with DirectX:
; 47   : 	D3DXMatrixInverse( &m_ViewMatrix, NULL, &m_WorldMatrix );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	call	_D3DXMatrixInverse@12

; 48   : 
; 49   : 	// Initialize the projection matrix. This determines viewing properties of the camera such as field of view (FOV) and near clip distance
; 50   : 	// One other factor in the projection matrix is the aspect ratio of screen (width/height) - used to adjust FOV between horizontal and vertical
; 51   : 	float aspect = (float)mViewportWidth / mViewportHeight; 

	cvtsi2ss xmm0, DWORD PTR ?mViewportWidth@CCamera@@0HA ; CCamera::mViewportWidth
	cvtsi2ss xmm1, DWORD PTR ?mViewportHeight@CCamera@@0HA ; CCamera::mViewportHeight
	divss	xmm0, xmm1
	movss	DWORD PTR _aspect$[ebp], xmm0

; 52   : 	D3DXMatrixPerspectiveFovLH( &m_ProjMatrix, m_FOV, aspect, m_NearClip, m_FarClip );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _aspect$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	call	_D3DXMatrixPerspectiveFovLH@20

; 53   : 
; 54   : 	// Combine the view and projection matrix into a single matrix - which can (optionally) be used in the vertex shaders to save one matrix multiply per vertex
; 55   : 	m_ViewProjMatrix = m_ViewMatrix * m_ProjMatrix;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z		; D3DXMATRIX::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z ; _D3DXMATRIXA16::operator=

; 56   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@UpdateMatr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
	npad	2
$LN8@UpdateMatr:
	DD	4
	DD	$LN7@UpdateMatr
$LN7@UpdateMatr:
	DD	-96					; ffffffa0H
	DD	64					; 00000040H
	DD	$LN3@UpdateMatr
	DD	-176					; ffffff50H
	DD	64					; 00000040H
	DD	$LN4@UpdateMatr
	DD	-256					; ffffff00H
	DD	64					; 00000040H
	DD	$LN5@UpdateMatr
	DD	-336					; fffffeb0H
	DD	64					; 00000040H
	DD	$LN6@UpdateMatr
$LN6@UpdateMatr:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	84					; 00000054H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN5@UpdateMatr:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	90					; 0000005aH
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
$LN4@UpdateMatr:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	89					; 00000059H
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
$LN3@UpdateMatr:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	88					; 00000058H
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
?UpdateMatrices@CCamera@@QAEXXZ ENDP			; CCamera::UpdateMatrices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\camera.h
;	COMDAT ?SetFarClip@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_farClip$ = 8						; size = 4
?SetFarClip@CCamera@@QAEXM@Z PROC			; CCamera::SetFarClip, COMDAT
; _this$ = ecx

; 115  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		m_FarClip = farClip;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _farClip$[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFarClip@CCamera@@QAEXM@Z ENDP			; CCamera::SetFarClip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\camera.h
;	COMDAT ?SetNearClip@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nearClip$ = 8						; size = 4
?SetNearClip@CCamera@@QAEXM@Z PROC			; CCamera::SetNearClip, COMDAT
; _this$ = ecx

; 111  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		m_NearClip = nearClip;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _nearClip$[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 113  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNearClip@CCamera@@QAEXM@Z ENDP			; CCamera::SetNearClip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\camera.h
;	COMDAT ?SetFOV@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fov$ = 8						; size = 4
?SetFOV@CCamera@@QAEXM@Z PROC				; CCamera::SetFOV, COMDAT
; _this$ = ecx

; 107  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 		m_FOV = fov;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fov$[ebp]
	movss	DWORD PTR [eax+32], xmm0

; 109  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFOV@CCamera@@QAEXM@Z ENDP				; CCamera::SetFOV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\github\uclan-sparta\dissertation project\camera.cpp
;	COMDAT ??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 12
_rotation$ = 20						; size = 12
_fov$ = 32						; size = 4
_nearClip$ = 36						; size = 4
_farClip$ = 40						; size = 4
??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z PROC		; CCamera::CCamera, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0D3DXVECTOR3@@QAE@XZ			; D3DXVECTOR3::D3DXVECTOR3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0D3DXVECTOR3@@QAE@XZ			; D3DXVECTOR3::D3DXVECTOR3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16

; 18   : 	m_Position = position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _position$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _position$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _position$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 19   : 	m_Rotation = rotation;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _rotation$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _rotation$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rotation$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 20   : 	UpdateMatrices();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateMatrices@CCamera@@QAEXXZ		; CCamera::UpdateMatrices

; 21   : 
; 22   : 	SetFOV( fov );

	push	ecx
	movss	xmm0, DWORD PTR _fov$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFOV@CCamera@@QAEXM@Z		; CCamera::SetFOV

; 23   : 	SetNearClip( nearClip );

	push	ecx
	movss	xmm0, DWORD PTR _nearClip$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNearClip@CCamera@@QAEXM@Z		; CCamera::SetNearClip

; 24   : 	SetFarClip( farClip );

	push	ecx
	movss	xmm0, DWORD PTR _farClip$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFarClip@CCamera@@QAEXM@Z		; CCamera::SetFarClip

; 25   : 
; 26   : 	MoveSpeed = 50.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [eax], xmm0

; 27   : 	RotSpeed = 2.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [eax+4], xmm0

; 28   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z ENDP		; CCamera::CCamera
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rhs$ = 8						; size = 4
??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z PROC	; _D3DXMATRIXA16::operator=, COMDAT
; _this$ = ecx

; 1056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1057 :     memcpy(&_11, &rhs, sizeof(D3DXMATRIX));

	push	64					; 00000040H
	mov	eax, DWORD PTR _rhs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1058 :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1059 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z ENDP	; _D3DXMATRIXA16::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0_D3DXMATRIXA16@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_D3DXMATRIXA16@@QAE@XZ PROC				; _D3DXMATRIXA16::_D3DXMATRIXA16, COMDAT
; _this$ = ecx

; 415  :     _D3DXMATRIXA16() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0D3DXMATRIX@@QAE@XZ			; D3DXMATRIX::D3DXMATRIX
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_D3DXMATRIXA16@@QAE@XZ ENDP				; _D3DXMATRIXA16::_D3DXMATRIXA16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??DD3DXMATRIX@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
_matT$ = -84						; size = 64
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_mat$ = 12						; size = 4
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z PROC			; D3DXMATRIX::operator*, COMDAT
; _this$ = ecx

; 896  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 897  :     D3DXMATRIX matT;

	lea	ecx, DWORD PTR _matT$[ebp]
	call	??0D3DXMATRIX@@QAE@XZ			; D3DXMATRIX::D3DXMATRIX

; 898  :     D3DXMatrixMultiply(&matT, this, &mat);

	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matT$[ebp]
	push	edx
	call	_D3DXMatrixMultiply@12

; 899  :     return matT;

	mov	ecx, 16					; 00000010H
	lea	esi, DWORD PTR _matT$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 900  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN5@operator:
	DD	1
	DD	$LN4@operator
$LN4@operator:
	DD	-84					; ffffffacH
	DD	64					; 00000040H
	DD	$LN3@operator
$LN3@operator:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	84					; 00000054H
	DB	0
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 348  :     D3DXMATRIX() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 198  :     D3DXVECTOR3() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
END
